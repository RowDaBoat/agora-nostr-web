import{ac as Rt,ad as ft,ae as St,af as Y,ag as br,ah as vr,ai as qt,aj as tn,ak as Ne,al as Ft,am as vt,an as be,ao as Er,ap as en,aq as Ar,ar as At,as as te,at as nn,o as it,au as Ir,k as ve,av as ee,m as It,N as R,a8 as Re,ab as ae,aw as Sr,q as _r,ax as xe,ay as En,az as An,_ as Br,aA as Tr,aB as Mr,aC as rn,aD as Pr}from"./D0X4VYcq.js";import{_ as Cr}from"./CSbKtK4P.js";/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ee(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function In(n,t){return Array.isArray(t)?t.length===0?!0:n?t.every(e=>typeof e=="string"):t.every(e=>Number.isSafeInteger(e)):!1}function Ur(n){if(typeof n!="function")throw new Error("function expected");return!0}function Ae(n,t){if(typeof t!="string")throw new Error(`${n}: string expected`);return!0}function De(n){if(!Number.isSafeInteger(n))throw new Error(`invalid integer: ${n}`)}function Ie(n){if(!Array.isArray(n))throw new Error("array expected")}function Sn(n,t){if(!In(!0,t))throw new Error(`${n}: array of strings expected`)}function Nr(n,t){if(!In(!1,t))throw new Error(`${n}: array of numbers expected`)}function _n(...n){const t=a=>a,e=(a,u)=>h=>a(u(h)),r=n.map(a=>a.encode).reduceRight(e,t),o=n.map(a=>a.decode).reduce(e,t);return{encode:r,decode:o}}function Rr(n){const t=typeof n=="string"?n.split(""):n,e=t.length;Sn("alphabet",t);const r=new Map(t.map((o,a)=>[o,a]));return{encode:o=>(Ie(o),o.map(a=>{if(!Number.isSafeInteger(a)||a<0||a>=e)throw new Error(`alphabet.encode: digit index outside alphabet "${a}". Allowed: ${n}`);return t[a]})),decode:o=>(Ie(o),o.map(a=>{Ae("alphabet.decode",a);const u=r.get(a);if(u===void 0)throw new Error(`Unknown letter: "${a}". Allowed: ${n}`);return u}))}}function xr(n=""){return Ae("join",n),{encode:t=>(Sn("join.decode",t),t.join(n)),decode:t=>(Ae("join.decode",t),t.split(n))}}function sn(n,t,e){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(e<2)throw new Error(`convertRadix: invalid to=${e}, base cannot be less than 2`);if(Ie(n),!n.length)return[];let r=0;const o=[],a=Array.from(n,h=>{if(De(h),h<0||h>=t)throw new Error(`invalid integer: ${h}`);return h}),u=a.length;for(;;){let h=0,f=!0;for(let p=r;p<u;p++){const l=a[p],k=t*h,g=k+l;if(!Number.isSafeInteger(g)||k/t!==h||g-l!==k)throw new Error("convertRadix: carry overflow");const w=g/e;h=g%e;const b=Math.floor(w);if(a[p]=b,!Number.isSafeInteger(b)||b*e+h!==g)throw new Error("convertRadix: carry overflow");if(f)b?f=!1:r=p;else continue}if(o.push(h),f)break}for(let h=0;h<n.length-1&&n[h]===0;h++)o.push(0);return o.reverse()}function Dr(n){De(n);const t=2**8;return{encode:e=>{if(!Ee(e))throw new Error("radix.encode input should be Uint8Array");return sn(Array.from(e),t,n)},decode:e=>(Nr("radix.decode",e),Uint8Array.from(sn(e,n,t)))}}function $r(n,t){return De(n),Ur(t),{encode(e){if(!Ee(e))throw new Error("checksum.encode: input should be Uint8Array");const r=t(e).slice(0,n),o=new Uint8Array(e.length+n);return o.set(e),o.set(r,e.length),o},decode(e){if(!Ee(e))throw new Error("checksum.decode: input should be Uint8Array");const r=e.slice(0,-n),o=e.slice(-n),a=t(r).slice(0,n);for(let u=0;u<n;u++)if(a[u]!==o[u])throw new Error("Invalid checksum");return r}}}const Lr=n=>_n(Dr(58),Rr(n),xr("")),Kr=Lr("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),Or=n=>_n($r(4,t=>n(n(t))),Kr),on=n=>{let t;const e=new Set,r=(p,l)=>{const k=typeof p=="function"?p(t):p;if(!Object.is(k,t)){const g=t;t=l??(typeof k!="object"||k===null)?k:Object.assign({},t,k),e.forEach(w=>w(t,g))}},o=()=>t,h={setState:r,getState:o,getInitialState:()=>f,subscribe:p=>(e.add(p),()=>e.delete(p))},f=t=n(r,o,h);return h},qr=(n=>n?on(n):on),nt=ft,tt=Rt;var Bn={},ne={};ne.byteLength=Hr;ne.toByteArray=zr;ne.fromByteArray=Vr;var ot=[],X=[],Fr=typeof Uint8Array<"u"?Uint8Array:Array,ce="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var bt=0,Wr=ce.length;bt<Wr;++bt)ot[bt]=ce[bt],X[ce.charCodeAt(bt)]=bt;X[45]=62;X[95]=63;function Tn(n){var t=n.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var e=n.indexOf("=");e===-1&&(e=t);var r=e===t?0:4-e%4;return[e,r]}function Hr(n){var t=Tn(n),e=t[0],r=t[1];return(e+r)*3/4-r}function Qr(n,t,e){return(t+e)*3/4-e}function zr(n){var t,e=Tn(n),r=e[0],o=e[1],a=new Fr(Qr(n,r,o)),u=0,h=o>0?r-4:r,f;for(f=0;f<h;f+=4)t=X[n.charCodeAt(f)]<<18|X[n.charCodeAt(f+1)]<<12|X[n.charCodeAt(f+2)]<<6|X[n.charCodeAt(f+3)],a[u++]=t>>16&255,a[u++]=t>>8&255,a[u++]=t&255;return o===2&&(t=X[n.charCodeAt(f)]<<2|X[n.charCodeAt(f+1)]>>4,a[u++]=t&255),o===1&&(t=X[n.charCodeAt(f)]<<10|X[n.charCodeAt(f+1)]<<4|X[n.charCodeAt(f+2)]>>2,a[u++]=t>>8&255,a[u++]=t&255),a}function jr(n){return ot[n>>18&63]+ot[n>>12&63]+ot[n>>6&63]+ot[n&63]}function Gr(n,t,e){for(var r,o=[],a=t;a<e;a+=3)r=(n[a]<<16&16711680)+(n[a+1]<<8&65280)+(n[a+2]&255),o.push(jr(r));return o.join("")}function Vr(n){for(var t,e=n.length,r=e%3,o=[],a=16383,u=0,h=e-r;u<h;u+=a)o.push(Gr(n,u,u+a>h?h:u+a));return r===1?(t=n[e-1],o.push(ot[t>>2]+ot[t<<4&63]+"==")):r===2&&(t=(n[e-2]<<8)+n[e-1],o.push(ot[t>>10]+ot[t>>4&63]+ot[t<<2&63]+"=")),o.join("")}var $e={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */$e.read=function(n,t,e,r,o){var a,u,h=o*8-r-1,f=(1<<h)-1,p=f>>1,l=-7,k=e?o-1:0,g=e?-1:1,w=n[t+k];for(k+=g,a=w&(1<<-l)-1,w>>=-l,l+=h;l>0;a=a*256+n[t+k],k+=g,l-=8);for(u=a&(1<<-l)-1,a>>=-l,l+=r;l>0;u=u*256+n[t+k],k+=g,l-=8);if(a===0)a=1-p;else{if(a===f)return u?NaN:(w?-1:1)*(1/0);u=u+Math.pow(2,r),a=a-p}return(w?-1:1)*u*Math.pow(2,a-r)};$e.write=function(n,t,e,r,o,a){var u,h,f,p=a*8-o-1,l=(1<<p)-1,k=l>>1,g=o===23?Math.pow(2,-24)-Math.pow(2,-77):0,w=r?0:a-1,b=r?1:-1,E=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(h=isNaN(t)?1:0,u=l):(u=Math.floor(Math.log(t)/Math.LN2),t*(f=Math.pow(2,-u))<1&&(u--,f*=2),u+k>=1?t+=g/f:t+=g*Math.pow(2,1-k),t*f>=2&&(u++,f/=2),u+k>=l?(h=0,u=l):u+k>=1?(h=(t*f-1)*Math.pow(2,o),u=u+k):(h=t*Math.pow(2,k-1)*Math.pow(2,o),u=0));o>=8;n[e+w]=h&255,w+=b,h/=256,o-=8);for(u=u<<o|h,p+=o;p>0;n[e+w]=u&255,w+=b,u/=256,p-=8);n[e+w-b]|=E*128};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(n){const t=ne,e=$e,r=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;n.Buffer=l,n.SlowBuffer=_,n.INSPECT_MAX_BYTES=50;const o=2147483647;n.kMaxLength=o;const{Uint8Array:a,ArrayBuffer:u,SharedArrayBuffer:h}=globalThis;l.TYPED_ARRAY_SUPPORT=f(),!l.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function f(){try{const s=new a(1),i={foo:function(){return 42}};return Object.setPrototypeOf(i,a.prototype),Object.setPrototypeOf(s,i),s.foo()===42}catch{return!1}}Object.defineProperty(l.prototype,"parent",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.buffer}}),Object.defineProperty(l.prototype,"offset",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.byteOffset}});function p(s){if(s>o)throw new RangeError('The value "'+s+'" is invalid for option "size"');const i=new a(s);return Object.setPrototypeOf(i,l.prototype),i}function l(s,i,c){if(typeof s=="number"){if(typeof i=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return b(s)}return k(s,i,c)}l.poolSize=8192;function k(s,i,c){if(typeof s=="string")return E(s,i);if(u.isView(s))return S(s);if(s==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof s);if(rt(s,u)||s&&rt(s.buffer,u)||typeof h<"u"&&(rt(s,h)||s&&rt(s.buffer,h)))return B(s,i,c);if(typeof s=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const d=s.valueOf&&s.valueOf();if(d!=null&&d!==s)return l.from(d,i,c);const y=T(s);if(y)return y;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof s[Symbol.toPrimitive]=="function")return l.from(s[Symbol.toPrimitive]("string"),i,c);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof s)}l.from=function(s,i,c){return k(s,i,c)},Object.setPrototypeOf(l.prototype,a.prototype),Object.setPrototypeOf(l,a);function g(s){if(typeof s!="number")throw new TypeError('"size" argument must be of type number');if(s<0)throw new RangeError('The value "'+s+'" is invalid for option "size"')}function w(s,i,c){return g(s),s<=0?p(s):i!==void 0?typeof c=="string"?p(s).fill(i,c):p(s).fill(i):p(s)}l.alloc=function(s,i,c){return w(s,i,c)};function b(s){return g(s),p(s<0?0:A(s)|0)}l.allocUnsafe=function(s){return b(s)},l.allocUnsafeSlow=function(s){return b(s)};function E(s,i){if((typeof i!="string"||i==="")&&(i="utf8"),!l.isEncoding(i))throw new TypeError("Unknown encoding: "+i);const c=P(s,i)|0;let d=p(c);const y=d.write(s,i);return y!==c&&(d=d.slice(0,y)),d}function I(s){const i=s.length<0?0:A(s.length)|0,c=p(i);for(let d=0;d<i;d+=1)c[d]=s[d]&255;return c}function S(s){if(rt(s,a)){const i=new a(s);return B(i.buffer,i.byteOffset,i.byteLength)}return I(s)}function B(s,i,c){if(i<0||s.byteLength<i)throw new RangeError('"offset" is outside of buffer bounds');if(s.byteLength<i+(c||0))throw new RangeError('"length" is outside of buffer bounds');let d;return i===void 0&&c===void 0?d=new a(s):c===void 0?d=new a(s,i):d=new a(s,i,c),Object.setPrototypeOf(d,l.prototype),d}function T(s){if(l.isBuffer(s)){const i=A(s.length)|0,c=p(i);return c.length===0||s.copy(c,0,0,i),c}if(s.length!==void 0)return typeof s.length!="number"||ie(s.length)?p(0):I(s);if(s.type==="Buffer"&&Array.isArray(s.data))return I(s.data)}function A(s){if(s>=o)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o.toString(16)+" bytes");return s|0}function _(s){return+s!=s&&(s=0),l.alloc(+s)}l.isBuffer=function(s){return s!=null&&s._isBuffer===!0&&s!==l.prototype},l.compare=function(s,i){if(rt(s,a)&&(s=l.from(s,s.offset,s.byteLength)),rt(i,a)&&(i=l.from(i,i.offset,i.byteLength)),!l.isBuffer(s)||!l.isBuffer(i))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(s===i)return 0;let c=s.length,d=i.length;for(let y=0,m=Math.min(c,d);y<m;++y)if(s[y]!==i[y]){c=s[y],d=i[y];break}return c<d?-1:d<c?1:0},l.isEncoding=function(s){switch(String(s).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(s,i){if(!Array.isArray(s))throw new TypeError('"list" argument must be an Array of Buffers');if(s.length===0)return l.alloc(0);let c;if(i===void 0)for(i=0,c=0;c<s.length;++c)i+=s[c].length;const d=l.allocUnsafe(i);let y=0;for(c=0;c<s.length;++c){let m=s[c];if(rt(m,a))y+m.length>d.length?(l.isBuffer(m)||(m=l.from(m)),m.copy(d,y)):a.prototype.set.call(d,m,y);else if(l.isBuffer(m))m.copy(d,y);else throw new TypeError('"list" argument must be an Array of Buffers');y+=m.length}return d};function P(s,i){if(l.isBuffer(s))return s.length;if(u.isView(s)||rt(s,u))return s.byteLength;if(typeof s!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof s);const c=s.length,d=arguments.length>2&&arguments[2]===!0;if(!d&&c===0)return 0;let y=!1;for(;;)switch(i){case"ascii":case"latin1":case"binary":return c;case"utf8":case"utf-8":return oe(s).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return c*2;case"hex":return c>>>1;case"base64":return Xe(s).length;default:if(y)return d?-1:oe(s).length;i=(""+i).toLowerCase(),y=!0}}l.byteLength=P;function M(s,i,c){let d=!1;if((i===void 0||i<0)&&(i=0),i>this.length||((c===void 0||c>this.length)&&(c=this.length),c<=0)||(c>>>=0,i>>>=0,c<=i))return"";for(s||(s="utf8");;)switch(s){case"hex":return lr(this,i,c);case"utf8":case"utf-8":return Kt(this,i,c);case"ascii":return gt(this,i,c);case"latin1":case"binary":return hr(this,i,c);case"base64":return ht(this,i,c);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return fr(this,i,c);default:if(d)throw new TypeError("Unknown encoding: "+s);s=(s+"").toLowerCase(),d=!0}}l.prototype._isBuffer=!0;function O(s,i,c){const d=s[i];s[i]=s[c],s[c]=d}l.prototype.swap16=function(){const s=this.length;if(s%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let i=0;i<s;i+=2)O(this,i,i+1);return this},l.prototype.swap32=function(){const s=this.length;if(s%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let i=0;i<s;i+=4)O(this,i,i+3),O(this,i+1,i+2);return this},l.prototype.swap64=function(){const s=this.length;if(s%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let i=0;i<s;i+=8)O(this,i,i+7),O(this,i+1,i+6),O(this,i+2,i+5),O(this,i+3,i+4);return this},l.prototype.toString=function(){const s=this.length;return s===0?"":arguments.length===0?Kt(this,0,s):M.apply(this,arguments)},l.prototype.toLocaleString=l.prototype.toString,l.prototype.equals=function(s){if(!l.isBuffer(s))throw new TypeError("Argument must be a Buffer");return this===s?!0:l.compare(this,s)===0},l.prototype.inspect=function(){let s="";const i=n.INSPECT_MAX_BYTES;return s=this.toString("hex",0,i).replace(/(.{2})/g,"$1 ").trim(),this.length>i&&(s+=" ... "),"<Buffer "+s+">"},r&&(l.prototype[r]=l.prototype.inspect),l.prototype.compare=function(s,i,c,d,y){if(rt(s,a)&&(s=l.from(s,s.offset,s.byteLength)),!l.isBuffer(s))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof s);if(i===void 0&&(i=0),c===void 0&&(c=s?s.length:0),d===void 0&&(d=0),y===void 0&&(y=this.length),i<0||c>s.length||d<0||y>this.length)throw new RangeError("out of range index");if(d>=y&&i>=c)return 0;if(d>=y)return-1;if(i>=c)return 1;if(i>>>=0,c>>>=0,d>>>=0,y>>>=0,this===s)return 0;let m=y-d,v=c-i;const N=Math.min(m,v),j=this.slice(d,y),D=s.slice(i,c);for(let U=0;U<N;++U)if(j[U]!==D[U]){m=j[U],v=D[U];break}return m<v?-1:v<m?1:0};function z(s,i,c,d,y){if(s.length===0)return-1;if(typeof c=="string"?(d=c,c=0):c>2147483647?c=2147483647:c<-2147483648&&(c=-2147483648),c=+c,ie(c)&&(c=y?0:s.length-1),c<0&&(c=s.length+c),c>=s.length){if(y)return-1;c=s.length-1}else if(c<0)if(y)c=0;else return-1;if(typeof i=="string"&&(i=l.from(i,d)),l.isBuffer(i))return i.length===0?-1:G(s,i,c,d,y);if(typeof i=="number")return i=i&255,typeof a.prototype.indexOf=="function"?y?a.prototype.indexOf.call(s,i,c):a.prototype.lastIndexOf.call(s,i,c):G(s,[i],c,d,y);throw new TypeError("val must be string, number or Buffer")}function G(s,i,c,d,y){let m=1,v=s.length,N=i.length;if(d!==void 0&&(d=String(d).toLowerCase(),d==="ucs2"||d==="ucs-2"||d==="utf16le"||d==="utf-16le")){if(s.length<2||i.length<2)return-1;m=2,v/=2,N/=2,c/=2}function j(U,q){return m===1?U[q]:U.readUInt16BE(q*m)}let D;if(y){let U=-1;for(D=c;D<v;D++)if(j(s,D)===j(i,U===-1?0:D-U)){if(U===-1&&(U=D),D-U+1===N)return U*m}else U!==-1&&(D-=D-U),U=-1}else for(c+N>v&&(c=v-N),D=c;D>=0;D--){let U=!0;for(let q=0;q<N;q++)if(j(s,D+q)!==j(i,q)){U=!1;break}if(U)return D}return-1}l.prototype.includes=function(s,i,c){return this.indexOf(s,i,c)!==-1},l.prototype.indexOf=function(s,i,c){return z(this,s,i,c,!0)},l.prototype.lastIndexOf=function(s,i,c){return z(this,s,i,c,!1)};function et(s,i,c,d){c=Number(c)||0;const y=s.length-c;d?(d=Number(d),d>y&&(d=y)):d=y;const m=i.length;d>m/2&&(d=m/2);let v;for(v=0;v<d;++v){const N=parseInt(i.substr(v*2,2),16);if(ie(N))return v;s[c+v]=N}return v}function K(s,i,c,d){return Ot(oe(i,s.length-c),s,c,d)}function W(s,i,c,d){return Ot(wr(i),s,c,d)}function C(s,i,c,d){return Ot(Xe(i),s,c,d)}function $(s,i,c,d){return Ot(gr(i,s.length-c),s,c,d)}l.prototype.write=function(s,i,c,d){if(i===void 0)d="utf8",c=this.length,i=0;else if(c===void 0&&typeof i=="string")d=i,c=this.length,i=0;else if(isFinite(i))i=i>>>0,isFinite(c)?(c=c>>>0,d===void 0&&(d="utf8")):(d=c,c=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const y=this.length-i;if((c===void 0||c>y)&&(c=y),s.length>0&&(c<0||i<0)||i>this.length)throw new RangeError("Attempt to write outside buffer bounds");d||(d="utf8");let m=!1;for(;;)switch(d){case"hex":return et(this,s,i,c);case"utf8":case"utf-8":return K(this,s,i,c);case"ascii":case"latin1":case"binary":return W(this,s,i,c);case"base64":return C(this,s,i,c);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return $(this,s,i,c);default:if(m)throw new TypeError("Unknown encoding: "+d);d=(""+d).toLowerCase(),m=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function ht(s,i,c){return i===0&&c===s.length?t.fromByteArray(s):t.fromByteArray(s.slice(i,c))}function Kt(s,i,c){c=Math.min(s.length,c);const d=[];let y=i;for(;y<c;){const m=s[y];let v=null,N=m>239?4:m>223?3:m>191?2:1;if(y+N<=c){let j,D,U,q;switch(N){case 1:m<128&&(v=m);break;case 2:j=s[y+1],(j&192)===128&&(q=(m&31)<<6|j&63,q>127&&(v=q));break;case 3:j=s[y+1],D=s[y+2],(j&192)===128&&(D&192)===128&&(q=(m&15)<<12|(j&63)<<6|D&63,q>2047&&(q<55296||q>57343)&&(v=q));break;case 4:j=s[y+1],D=s[y+2],U=s[y+3],(j&192)===128&&(D&192)===128&&(U&192)===128&&(q=(m&15)<<18|(j&63)<<12|(D&63)<<6|U&63,q>65535&&q<1114112&&(v=q))}}v===null?(v=65533,N=1):v>65535&&(v-=65536,d.push(v>>>10&1023|55296),v=56320|v&1023),d.push(v),y+=N}return Pt(d)}const Mt=4096;function Pt(s){const i=s.length;if(i<=Mt)return String.fromCharCode.apply(String,s);let c="",d=0;for(;d<i;)c+=String.fromCharCode.apply(String,s.slice(d,d+=Mt));return c}function gt(s,i,c){let d="";c=Math.min(s.length,c);for(let y=i;y<c;++y)d+=String.fromCharCode(s[y]&127);return d}function hr(s,i,c){let d="";c=Math.min(s.length,c);for(let y=i;y<c;++y)d+=String.fromCharCode(s[y]);return d}function lr(s,i,c){const d=s.length;(!i||i<0)&&(i=0),(!c||c<0||c>d)&&(c=d);let y="";for(let m=i;m<c;++m)y+=mr[s[m]];return y}function fr(s,i,c){const d=s.slice(i,c);let y="";for(let m=0;m<d.length-1;m+=2)y+=String.fromCharCode(d[m]+d[m+1]*256);return y}l.prototype.slice=function(s,i){const c=this.length;s=~~s,i=i===void 0?c:~~i,s<0?(s+=c,s<0&&(s=0)):s>c&&(s=c),i<0?(i+=c,i<0&&(i=0)):i>c&&(i=c),i<s&&(i=s);const d=this.subarray(s,i);return Object.setPrototypeOf(d,l.prototype),d};function H(s,i,c){if(s%1!==0||s<0)throw new RangeError("offset is not uint");if(s+i>c)throw new RangeError("Trying to access beyond buffer length")}l.prototype.readUintLE=l.prototype.readUIntLE=function(s,i,c){s=s>>>0,i=i>>>0,c||H(s,i,this.length);let d=this[s],y=1,m=0;for(;++m<i&&(y*=256);)d+=this[s+m]*y;return d},l.prototype.readUintBE=l.prototype.readUIntBE=function(s,i,c){s=s>>>0,i=i>>>0,c||H(s,i,this.length);let d=this[s+--i],y=1;for(;i>0&&(y*=256);)d+=this[s+--i]*y;return d},l.prototype.readUint8=l.prototype.readUInt8=function(s,i){return s=s>>>0,i||H(s,1,this.length),this[s]},l.prototype.readUint16LE=l.prototype.readUInt16LE=function(s,i){return s=s>>>0,i||H(s,2,this.length),this[s]|this[s+1]<<8},l.prototype.readUint16BE=l.prototype.readUInt16BE=function(s,i){return s=s>>>0,i||H(s,2,this.length),this[s]<<8|this[s+1]},l.prototype.readUint32LE=l.prototype.readUInt32LE=function(s,i){return s=s>>>0,i||H(s,4,this.length),(this[s]|this[s+1]<<8|this[s+2]<<16)+this[s+3]*16777216},l.prototype.readUint32BE=l.prototype.readUInt32BE=function(s,i){return s=s>>>0,i||H(s,4,this.length),this[s]*16777216+(this[s+1]<<16|this[s+2]<<8|this[s+3])},l.prototype.readBigUInt64LE=lt(function(s){s=s>>>0,kt(s,"offset");const i=this[s],c=this[s+7];(i===void 0||c===void 0)&&Ct(s,this.length-8);const d=i+this[++s]*2**8+this[++s]*2**16+this[++s]*2**24,y=this[++s]+this[++s]*2**8+this[++s]*2**16+c*2**24;return BigInt(d)+(BigInt(y)<<BigInt(32))}),l.prototype.readBigUInt64BE=lt(function(s){s=s>>>0,kt(s,"offset");const i=this[s],c=this[s+7];(i===void 0||c===void 0)&&Ct(s,this.length-8);const d=i*2**24+this[++s]*2**16+this[++s]*2**8+this[++s],y=this[++s]*2**24+this[++s]*2**16+this[++s]*2**8+c;return(BigInt(d)<<BigInt(32))+BigInt(y)}),l.prototype.readIntLE=function(s,i,c){s=s>>>0,i=i>>>0,c||H(s,i,this.length);let d=this[s],y=1,m=0;for(;++m<i&&(y*=256);)d+=this[s+m]*y;return y*=128,d>=y&&(d-=Math.pow(2,8*i)),d},l.prototype.readIntBE=function(s,i,c){s=s>>>0,i=i>>>0,c||H(s,i,this.length);let d=i,y=1,m=this[s+--d];for(;d>0&&(y*=256);)m+=this[s+--d]*y;return y*=128,m>=y&&(m-=Math.pow(2,8*i)),m},l.prototype.readInt8=function(s,i){return s=s>>>0,i||H(s,1,this.length),this[s]&128?(255-this[s]+1)*-1:this[s]},l.prototype.readInt16LE=function(s,i){s=s>>>0,i||H(s,2,this.length);const c=this[s]|this[s+1]<<8;return c&32768?c|4294901760:c},l.prototype.readInt16BE=function(s,i){s=s>>>0,i||H(s,2,this.length);const c=this[s+1]|this[s]<<8;return c&32768?c|4294901760:c},l.prototype.readInt32LE=function(s,i){return s=s>>>0,i||H(s,4,this.length),this[s]|this[s+1]<<8|this[s+2]<<16|this[s+3]<<24},l.prototype.readInt32BE=function(s,i){return s=s>>>0,i||H(s,4,this.length),this[s]<<24|this[s+1]<<16|this[s+2]<<8|this[s+3]},l.prototype.readBigInt64LE=lt(function(s){s=s>>>0,kt(s,"offset");const i=this[s],c=this[s+7];(i===void 0||c===void 0)&&Ct(s,this.length-8);const d=this[s+4]+this[s+5]*2**8+this[s+6]*2**16+(c<<24);return(BigInt(d)<<BigInt(32))+BigInt(i+this[++s]*2**8+this[++s]*2**16+this[++s]*2**24)}),l.prototype.readBigInt64BE=lt(function(s){s=s>>>0,kt(s,"offset");const i=this[s],c=this[s+7];(i===void 0||c===void 0)&&Ct(s,this.length-8);const d=(i<<24)+this[++s]*2**16+this[++s]*2**8+this[++s];return(BigInt(d)<<BigInt(32))+BigInt(this[++s]*2**24+this[++s]*2**16+this[++s]*2**8+c)}),l.prototype.readFloatLE=function(s,i){return s=s>>>0,i||H(s,4,this.length),e.read(this,s,!0,23,4)},l.prototype.readFloatBE=function(s,i){return s=s>>>0,i||H(s,4,this.length),e.read(this,s,!1,23,4)},l.prototype.readDoubleLE=function(s,i){return s=s>>>0,i||H(s,8,this.length),e.read(this,s,!0,52,8)},l.prototype.readDoubleBE=function(s,i){return s=s>>>0,i||H(s,8,this.length),e.read(this,s,!1,52,8)};function V(s,i,c,d,y,m){if(!l.isBuffer(s))throw new TypeError('"buffer" argument must be a Buffer instance');if(i>y||i<m)throw new RangeError('"value" argument is out of bounds');if(c+d>s.length)throw new RangeError("Index out of range")}l.prototype.writeUintLE=l.prototype.writeUIntLE=function(s,i,c,d){if(s=+s,i=i>>>0,c=c>>>0,!d){const v=Math.pow(2,8*c)-1;V(this,s,i,c,v,0)}let y=1,m=0;for(this[i]=s&255;++m<c&&(y*=256);)this[i+m]=s/y&255;return i+c},l.prototype.writeUintBE=l.prototype.writeUIntBE=function(s,i,c,d){if(s=+s,i=i>>>0,c=c>>>0,!d){const v=Math.pow(2,8*c)-1;V(this,s,i,c,v,0)}let y=c-1,m=1;for(this[i+y]=s&255;--y>=0&&(m*=256);)this[i+y]=s/m&255;return i+c},l.prototype.writeUint8=l.prototype.writeUInt8=function(s,i,c){return s=+s,i=i>>>0,c||V(this,s,i,1,255,0),this[i]=s&255,i+1},l.prototype.writeUint16LE=l.prototype.writeUInt16LE=function(s,i,c){return s=+s,i=i>>>0,c||V(this,s,i,2,65535,0),this[i]=s&255,this[i+1]=s>>>8,i+2},l.prototype.writeUint16BE=l.prototype.writeUInt16BE=function(s,i,c){return s=+s,i=i>>>0,c||V(this,s,i,2,65535,0),this[i]=s>>>8,this[i+1]=s&255,i+2},l.prototype.writeUint32LE=l.prototype.writeUInt32LE=function(s,i,c){return s=+s,i=i>>>0,c||V(this,s,i,4,4294967295,0),this[i+3]=s>>>24,this[i+2]=s>>>16,this[i+1]=s>>>8,this[i]=s&255,i+4},l.prototype.writeUint32BE=l.prototype.writeUInt32BE=function(s,i,c){return s=+s,i=i>>>0,c||V(this,s,i,4,4294967295,0),this[i]=s>>>24,this[i+1]=s>>>16,this[i+2]=s>>>8,this[i+3]=s&255,i+4};function ze(s,i,c,d,y){Ze(i,d,y,s,c,7);let m=Number(i&BigInt(4294967295));s[c++]=m,m=m>>8,s[c++]=m,m=m>>8,s[c++]=m,m=m>>8,s[c++]=m;let v=Number(i>>BigInt(32)&BigInt(4294967295));return s[c++]=v,v=v>>8,s[c++]=v,v=v>>8,s[c++]=v,v=v>>8,s[c++]=v,c}function je(s,i,c,d,y){Ze(i,d,y,s,c,7);let m=Number(i&BigInt(4294967295));s[c+7]=m,m=m>>8,s[c+6]=m,m=m>>8,s[c+5]=m,m=m>>8,s[c+4]=m;let v=Number(i>>BigInt(32)&BigInt(4294967295));return s[c+3]=v,v=v>>8,s[c+2]=v,v=v>>8,s[c+1]=v,v=v>>8,s[c]=v,c+8}l.prototype.writeBigUInt64LE=lt(function(s,i=0){return ze(this,s,i,BigInt(0),BigInt("0xffffffffffffffff"))}),l.prototype.writeBigUInt64BE=lt(function(s,i=0){return je(this,s,i,BigInt(0),BigInt("0xffffffffffffffff"))}),l.prototype.writeIntLE=function(s,i,c,d){if(s=+s,i=i>>>0,!d){const N=Math.pow(2,8*c-1);V(this,s,i,c,N-1,-N)}let y=0,m=1,v=0;for(this[i]=s&255;++y<c&&(m*=256);)s<0&&v===0&&this[i+y-1]!==0&&(v=1),this[i+y]=(s/m>>0)-v&255;return i+c},l.prototype.writeIntBE=function(s,i,c,d){if(s=+s,i=i>>>0,!d){const N=Math.pow(2,8*c-1);V(this,s,i,c,N-1,-N)}let y=c-1,m=1,v=0;for(this[i+y]=s&255;--y>=0&&(m*=256);)s<0&&v===0&&this[i+y+1]!==0&&(v=1),this[i+y]=(s/m>>0)-v&255;return i+c},l.prototype.writeInt8=function(s,i,c){return s=+s,i=i>>>0,c||V(this,s,i,1,127,-128),s<0&&(s=255+s+1),this[i]=s&255,i+1},l.prototype.writeInt16LE=function(s,i,c){return s=+s,i=i>>>0,c||V(this,s,i,2,32767,-32768),this[i]=s&255,this[i+1]=s>>>8,i+2},l.prototype.writeInt16BE=function(s,i,c){return s=+s,i=i>>>0,c||V(this,s,i,2,32767,-32768),this[i]=s>>>8,this[i+1]=s&255,i+2},l.prototype.writeInt32LE=function(s,i,c){return s=+s,i=i>>>0,c||V(this,s,i,4,2147483647,-2147483648),this[i]=s&255,this[i+1]=s>>>8,this[i+2]=s>>>16,this[i+3]=s>>>24,i+4},l.prototype.writeInt32BE=function(s,i,c){return s=+s,i=i>>>0,c||V(this,s,i,4,2147483647,-2147483648),s<0&&(s=4294967295+s+1),this[i]=s>>>24,this[i+1]=s>>>16,this[i+2]=s>>>8,this[i+3]=s&255,i+4},l.prototype.writeBigInt64LE=lt(function(s,i=0){return ze(this,s,i,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),l.prototype.writeBigInt64BE=lt(function(s,i=0){return je(this,s,i,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Ge(s,i,c,d,y,m){if(c+d>s.length)throw new RangeError("Index out of range");if(c<0)throw new RangeError("Index out of range")}function Ve(s,i,c,d,y){return i=+i,c=c>>>0,y||Ge(s,i,c,4),e.write(s,i,c,d,23,4),c+4}l.prototype.writeFloatLE=function(s,i,c){return Ve(this,s,i,!0,c)},l.prototype.writeFloatBE=function(s,i,c){return Ve(this,s,i,!1,c)};function Je(s,i,c,d,y){return i=+i,c=c>>>0,y||Ge(s,i,c,8),e.write(s,i,c,d,52,8),c+8}l.prototype.writeDoubleLE=function(s,i,c){return Je(this,s,i,!0,c)},l.prototype.writeDoubleBE=function(s,i,c){return Je(this,s,i,!1,c)},l.prototype.copy=function(s,i,c,d){if(!l.isBuffer(s))throw new TypeError("argument should be a Buffer");if(c||(c=0),!d&&d!==0&&(d=this.length),i>=s.length&&(i=s.length),i||(i=0),d>0&&d<c&&(d=c),d===c||s.length===0||this.length===0)return 0;if(i<0)throw new RangeError("targetStart out of bounds");if(c<0||c>=this.length)throw new RangeError("Index out of range");if(d<0)throw new RangeError("sourceEnd out of bounds");d>this.length&&(d=this.length),s.length-i<d-c&&(d=s.length-i+c);const y=d-c;return this===s&&typeof a.prototype.copyWithin=="function"?this.copyWithin(i,c,d):a.prototype.set.call(s,this.subarray(c,d),i),y},l.prototype.fill=function(s,i,c,d){if(typeof s=="string"){if(typeof i=="string"?(d=i,i=0,c=this.length):typeof c=="string"&&(d=c,c=this.length),d!==void 0&&typeof d!="string")throw new TypeError("encoding must be a string");if(typeof d=="string"&&!l.isEncoding(d))throw new TypeError("Unknown encoding: "+d);if(s.length===1){const m=s.charCodeAt(0);(d==="utf8"&&m<128||d==="latin1")&&(s=m)}}else typeof s=="number"?s=s&255:typeof s=="boolean"&&(s=Number(s));if(i<0||this.length<i||this.length<c)throw new RangeError("Out of range index");if(c<=i)return this;i=i>>>0,c=c===void 0?this.length:c>>>0,s||(s=0);let y;if(typeof s=="number")for(y=i;y<c;++y)this[y]=s;else{const m=l.isBuffer(s)?s:l.from(s,d),v=m.length;if(v===0)throw new TypeError('The value "'+s+'" is invalid for argument "value"');for(y=0;y<c-i;++y)this[y+i]=m[y%v]}return this};const mt={};function se(s,i,c){mt[s]=class extends c{constructor(){super(),Object.defineProperty(this,"message",{value:i.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${s}]`,this.stack,delete this.name}get code(){return s}set code(d){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:d,writable:!0})}toString(){return`${this.name} [${s}]: ${this.message}`}}}se("ERR_BUFFER_OUT_OF_BOUNDS",function(s){return s?`${s} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),se("ERR_INVALID_ARG_TYPE",function(s,i){return`The "${s}" argument must be of type number. Received type ${typeof i}`},TypeError),se("ERR_OUT_OF_RANGE",function(s,i,c){let d=`The value of "${s}" is out of range.`,y=c;return Number.isInteger(c)&&Math.abs(c)>2**32?y=Ye(String(c)):typeof c=="bigint"&&(y=String(c),(c>BigInt(2)**BigInt(32)||c<-(BigInt(2)**BigInt(32)))&&(y=Ye(y)),y+="n"),d+=` It must be ${i}. Received ${y}`,d},RangeError);function Ye(s){let i="",c=s.length;const d=s[0]==="-"?1:0;for(;c>=d+4;c-=3)i=`_${s.slice(c-3,c)}${i}`;return`${s.slice(0,c)}${i}`}function dr(s,i,c){kt(i,"offset"),(s[i]===void 0||s[i+c]===void 0)&&Ct(i,s.length-(c+1))}function Ze(s,i,c,d,y,m){if(s>c||s<i){const v=typeof i=="bigint"?"n":"";let N;throw i===0||i===BigInt(0)?N=`>= 0${v} and < 2${v} ** ${(m+1)*8}${v}`:N=`>= -(2${v} ** ${(m+1)*8-1}${v}) and < 2 ** ${(m+1)*8-1}${v}`,new mt.ERR_OUT_OF_RANGE("value",N,s)}dr(d,y,m)}function kt(s,i){if(typeof s!="number")throw new mt.ERR_INVALID_ARG_TYPE(i,"number",s)}function Ct(s,i,c){throw Math.floor(s)!==s?(kt(s,c),new mt.ERR_OUT_OF_RANGE("offset","an integer",s)):i<0?new mt.ERR_BUFFER_OUT_OF_BOUNDS:new mt.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${i}`,s)}const pr=/[^+/0-9A-Za-z-_]/g;function yr(s){if(s=s.split("=")[0],s=s.trim().replace(pr,""),s.length<2)return"";for(;s.length%4!==0;)s=s+"=";return s}function oe(s,i){i=i||1/0;let c;const d=s.length;let y=null;const m=[];for(let v=0;v<d;++v){if(c=s.charCodeAt(v),c>55295&&c<57344){if(!y){if(c>56319){(i-=3)>-1&&m.push(239,191,189);continue}else if(v+1===d){(i-=3)>-1&&m.push(239,191,189);continue}y=c;continue}if(c<56320){(i-=3)>-1&&m.push(239,191,189),y=c;continue}c=(y-55296<<10|c-56320)+65536}else y&&(i-=3)>-1&&m.push(239,191,189);if(y=null,c<128){if((i-=1)<0)break;m.push(c)}else if(c<2048){if((i-=2)<0)break;m.push(c>>6|192,c&63|128)}else if(c<65536){if((i-=3)<0)break;m.push(c>>12|224,c>>6&63|128,c&63|128)}else if(c<1114112){if((i-=4)<0)break;m.push(c>>18|240,c>>12&63|128,c>>6&63|128,c&63|128)}else throw new Error("Invalid code point")}return m}function wr(s){const i=[];for(let c=0;c<s.length;++c)i.push(s.charCodeAt(c)&255);return i}function gr(s,i){let c,d,y;const m=[];for(let v=0;v<s.length&&!((i-=2)<0);++v)c=s.charCodeAt(v),d=c>>8,y=c%256,m.push(y),m.push(d);return m}function Xe(s){return t.toByteArray(yr(s))}function Ot(s,i,c,d){let y;for(y=0;y<d&&!(y+c>=i.length||y>=s.length);++y)i[y+c]=s[y];return y}function rt(s,i){return s instanceof i||s!=null&&s.constructor!=null&&s.constructor.name!=null&&s.constructor.name===i.name}function ie(s){return s!==s}const mr=(function(){const s="0123456789abcdef",i=new Array(256);for(let c=0;c<16;++c){const d=c*16;for(let y=0;y<16;++y)i[d+y]=s[c]+s[y]}return i})();function lt(s){return typeof BigInt>"u"?kr:s}function kr(){throw new Error("BigInt not supported")}})(Bn);const Wt=Bn.Buffer;class x{static fromHex(t){if(t=t.trim(),t.length===0)return new Uint8Array(0);if(t.length<2||t.length&1)throw new Error("Invalid hex string: odd length.");if((t.startsWith("0x")||t.startsWith("0X"))&&(t=t.slice(2)),!t.match(/^[0-9a-fA-F]*$/))throw new Error("Invalid hex string: contains non-hex characters");const e=t.match(/.{1,2}/g);if(!e)throw new Error("Invalid hex string");return new Uint8Array(e.map(r=>parseInt(r,16)))}static toHex(t){return Array.from(t,e=>e.toString(16).padStart(2,"0")).join("")}static fromString(t){return t=t.trim(),new TextEncoder().encode(t)}static toString(t){return new TextDecoder("utf-8").decode(t)}static concat(...t){const e=t.reduce((a,u)=>a+u.length,0),r=new Uint8Array(e);let o=0;for(const a of t)r.set(a,o),o+=a.length;return r}static alloc(t){return new Uint8Array(t)}static writeBigUint64BE(t){const e=new ArrayBuffer(8);return new DataView(e).setBigUint64(0,t,!1),new Uint8Array(e)}static toBase64(t){if(typeof Wt<"u")return Wt.from(t).toString("base64");if(t.length>32768){let e="";for(let r=0;r<t.length;r+=32768){const o=t.slice(r,r+32768);e+=btoa(String.fromCharCode(...o))}return e}return btoa(String.fromCharCode(...t))}static fromBase64(t){if(t=t.trim(),typeof Wt<"u")return new Uint8Array(Wt.from(t,"base64"));let e=t.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4;)e+="=";return new Uint8Array([...atob(e)].map(r=>r.charCodeAt(0)))}static equals(t,e){if(t.length!==e.length)return!1;let r=0;for(let o=0;o<t.length;o++)r|=t[o]^e[o];return r===0}static compare(t,e){const r=Math.min(t.length,e.length);for(let o=0;o<r;o++){if(t[o]<e[o])return-1;if(t[o]>e[o])return 1}return t.length-e.length}}function Nt(n){return Mn(nt(n))}function Mn(n){return BigInt(`0x${n}`)}function Jr(n){return x.fromBase64(n)}const Yr=tt("536563703235366b315f48617368546f43757276655f43617368755f");function Zt(n){const t=St(x.concat(Yr,n)),e=new Uint32Array(1),r=2**16;for(let o=0;o<r;o++){const a=new Uint8Array(e.buffer),u=St(x.concat(t,a));try{return xt(nt(x.concat(new Uint8Array([2]),u)))}catch{e[0]++}}throw new Error("No valid point found")}function Zr(n){const t=n.map(e=>e.toHex(!1)).join("");return St(new TextEncoder().encode(t))}function xt(n){return Y.ProjectivePoint.fromHex(n)}const Xr=n=>{let t;return/^[a-fA-F0-9]+$/.test(n)?t=Mn(n)%BigInt(2**31-1):t=Nt(Jr(n))%BigInt(2**31-1),t};function ts(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}const es=(n,t,e,r)=>{const o=Y.ProjectivePoint.fromPrivateKey(nt(n.s)),a=r.multiply(Nt(n.e)),u=t.multiply(Nt(n.s)),h=e.multiply(Nt(n.e)),f=o.subtract(a),p=u.subtract(h),l=Zr([f,p,r,e]);return ts(l,n.e)},ns=(n,t,e,r)=>{if(t.r===void 0)throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");const o=Zt(n),a=e.add(r.multiply(t.r)),u=Y.ProjectivePoint.fromPrivateKey(t.r),h=o.add(u);return es(t,h,a,r)},rs=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Pn=Uint8Array.from(new Array(16).fill(0).map((n,t)=>t)),ss=Pn.map(n=>(9*n+5)%16),Cn=(()=>{const e=[[Pn],[ss]];for(let r=0;r<4;r++)for(let o of e)o.push(o[r].map(a=>rs[a]));return e})(),Un=Cn[0],Nn=Cn[1],Rn=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(n=>Uint8Array.from(n)),os=Un.map((n,t)=>n.map(e=>Rn[t][e])),is=Nn.map((n,t)=>n.map(e=>Rn[t][e])),as=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),cs=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function an(n,t,e,r){return n===0?t^e^r:n===1?t&e|~t&r:n===2?(t|~e)^r:n===3?t&r|e&~r:t^(e|~r)}const Ht=new Uint32Array(16);class us extends vr{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:r,h3:o,h4:a}=this;return[t,e,r,o,a]}set(t,e,r,o,a){this.h0=t|0,this.h1=e|0,this.h2=r|0,this.h3=o|0,this.h4=a|0}process(t,e){for(let w=0;w<16;w++,e+=4)Ht[w]=t.getUint32(e,!0);let r=this.h0|0,o=r,a=this.h1|0,u=a,h=this.h2|0,f=h,p=this.h3|0,l=p,k=this.h4|0,g=k;for(let w=0;w<5;w++){const b=4-w,E=as[w],I=cs[w],S=Un[w],B=Nn[w],T=os[w],A=is[w];for(let _=0;_<16;_++){const P=qt(r+an(w,a,h,p)+Ht[S[_]]+E,T[_])+k|0;r=k,k=p,p=qt(h,10)|0,h=a,a=P}for(let _=0;_<16;_++){const P=qt(o+an(b,u,f,l)+Ht[B[_]]+I,A[_])+g|0;o=g,g=l,l=qt(f,10)|0,f=u,u=P}}this.set(this.h1+h+l|0,this.h2+p+g|0,this.h3+k+o|0,this.h4+r+u|0,this.h0+a+f|0)}roundClean(){tn(Ht)}destroy(){this.destroyed=!0,tn(this.buffer),this.set(0,0,0,0,0)}}const hs=br(()=>new us);/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */const Qt=Y.ProjectivePoint,ue=Or(At);function cn(n){vt(n);const t=n.length===0?"0":ft(n);return BigInt("0x"+t)}function ls(n){if(typeof n!="bigint")throw new Error("bigint expected");return Rt(n.toString(16).padStart(64,"0"))}const fs=Er("Bitcoin seed"),he={private:76066276,public:76067358},le=2147483648,ds=n=>hs(At(n)),ps=n=>Ne(n).getUint32(0,!1),zt=n=>{if(!Number.isSafeInteger(n)||n<0||n>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+n);const t=new Uint8Array(4);return Ne(t).setUint32(0,n,!1),t};class wt{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return ps(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const t=this.privateKey;if(!t)throw new Error("No private key");return ue.encode(this.serialize(this.versions.private,Ft(new Uint8Array([0]),t)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return ue.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(t,e=he){if(vt(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const r=be(en,fs,t);return new wt({versions:e,chainCode:r.slice(32),privateKey:r.slice(0,32)})}static fromExtendedKey(t,e=he){const r=ue.decode(t),o=Ne(r),a=o.getUint32(0,!1),u={versions:e,depth:r[4],parentFingerprint:o.getUint32(5,!1),index:o.getUint32(9,!1),chainCode:r.slice(13,45)},h=r.slice(45),f=h[0]===0;if(a!==e[f?"private":"public"])throw new Error("Version mismatch");return f?new wt({...u,privateKey:h.slice(1)}):new wt({...u,publicKey:h})}static fromJSON(t){return wt.fromExtendedKey(t.xpriv)}constructor(t){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||he,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!Y.utils.isValidPrivateKey(t.privateKey))throw new Error("Invalid private key");this.privKey=typeof t.privateKey=="bigint"?t.privateKey:cn(t.privateKey),this.privKeyBytes=ls(this.privKey),this.pubKey=Y.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this.pubKey=Qt.fromHex(t.publicKey).toRawBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=ds(this.pubKey)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const e=t.replace(/^[mM]'?\//,"").split("/");let r=this;for(const o of e){const a=/^(\d+)('?)$/.exec(o),u=a&&a[1];if(!a||a.length!==3||typeof u!="string")throw new Error("invalid child index: "+o);let h=+u;if(!Number.isSafeInteger(h)||h>=le)throw new Error("Invalid index");a[2]==="'"&&(h+=le),r=r.deriveChild(h)}return r}deriveChild(t){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let e=zt(t);if(t>=le){const h=this.privateKey;if(!h)throw new Error("Could not derive hardened child key");e=Ft(new Uint8Array([0]),h,e)}else e=Ft(this.pubKey,e);const r=be(en,this.chainCode,e),o=cn(r.slice(0,32)),a=r.slice(32);if(!Y.utils.isValidPrivateKey(o))throw new Error("Tweak bigger than curve order");const u={versions:this.versions,chainCode:a,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t};try{if(this.privateKey){const h=Ar(this.privKey+o,Y.CURVE.n);if(!Y.utils.isValidPrivateKey(h))throw new Error("The tweak was out of range or the resulted private key is invalid");u.privateKey=h}else{const h=Qt.fromHex(this.pubKey).add(Qt.fromPrivateKey(o));if(h.equals(Qt.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");u.publicKey=h.toRawBytes(!0)}return new wt(u)}catch{return this.deriveChild(t+1)}}sign(t){if(!this.privateKey)throw new Error("No privateKey set!");return vt(t,32),Y.sign(t,this.privKey).toCompactRawBytes()}verify(t,e){if(vt(t,32),vt(e,64),!this.publicKey)throw new Error("No publicKey set!");let r;try{r=Y.Signature.fromCompact(e)}catch{return!1}return Y.verify(r,t,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,e){if(!this.chainCode)throw new Error("No chainCode set");return vt(e,33),Ft(zt(t),new Uint8Array([this.depth]),zt(this.parentFingerprint),zt(this.index),this.chainCode,e)}}function ys(n){return x.toBase64(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function ws(n){return x.fromBase64(n)}function gs(n){const t=JSON.stringify(n);return bs(x.toBase64(x.fromString(t)))}function ms(n){const t=x.toString(x.fromBase64(ks(n)));return JSON.parse(t)}function ks(n){return n.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function bs(n){return n.replace(/\+/g,"-").replace(/\//g,"_").split("=")[0]}function Le(n){if(typeof n!="string"||n.length===0)return!1;const t=/^[A-Za-z0-9\-_]+={0,2}$/,e=/^[A-Za-z0-9+/]+={0,2}$/;if(!t.test(n)&&!e.test(n))return!1;const r=n.replace(/-/g,"+").replace(/_/g,"/"),o=(4-r.length%4)%4;if(o>2)return!1;const a=r+"=".repeat(o);try{const u=x.fromBase64(a),h=x.toBase64(u),f=h.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),p=r.replace(/=+$/,"");return h.replace(/=+$/,"")===p||f===p}catch{return!1}}const vs="m/129372'/0'",Es=(n,t,e)=>{const r=/^[a-fA-F0-9]+$/.test(t);if(!r&&Le(t)||r&&t.startsWith("00"))return Dn(n,t,e,0);if(r&&t.startsWith("01"))return xn(n,t,e,0);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},As=(n,t,e)=>{const r=/^[a-fA-F0-9]+$/.test(t);if(!r&&Le(t)||r&&t.startsWith("00"))return Dn(n,t,e,1);if(r&&t.startsWith("01"))return xn(n,t,e,1);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},xn=(n,t,e,r)=>{let o=x.concat(x.fromString("Cashu_KDF_HMAC_SHA256"),x.fromHex(t),x.writeBigUint64BE(BigInt(e)));switch(r){case 0:o=x.concat(o,x.fromHex("00"));break;case 1:o=x.concat(o,x.fromHex("01"))}return be(At,n,o)},Dn=(n,t,e,r)=>{const o=wt.fromMasterSeed(n),a=Xr(t),u=`${vs}/${a}'/${e}'/${r}`,h=o.derive(u);if(h.privateKey===null)throw new Error("Could not derive private key");return h.privateKey},$t=n=>{try{return n instanceof Uint8Array&&(n=new TextDecoder().decode(n)),JSON.parse(n)}catch{throw new Error("can't parse secret")}},Is=(n,t)=>{const e=St(n),r=te.sign(e,t);return nt(r)},Ss=(n,t,e)=>{try{const r=St(t),o=e.length===66?e.slice(2):e;if(te.verify(n,r,tt(o)))return!0}catch(r){console.error("verifyP2PKsecret error:",r)}return!1};function _s(n){try{const t=typeof n=="string"?$t(n):n;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const e=Math.floor(Date.now()/1e3);return Ms(t)>e?Bs(t):Ts(t)}catch{}return[]}function Bs(n){const t=typeof n=="string"?$t(n):n;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{data:e,tags:r}=t[1],o=r&&r.find(u=>u[0]==="pubkeys"),a=o&&o.length>1?o.slice(1):[];return[e,...a].filter(Boolean)}function Ts(n){const t=typeof n=="string"?$t(n):n;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{tags:e}=t[1],r=e&&e.find(o=>o[0]==="refund");return r&&r.length>1?r.slice(1).filter(Boolean):[]}function Ms(n){const t=typeof n=="string"?$t(n):n;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{tags:e}=t[1],r=e&&e.find(o=>o[0]==="locktime");return r&&r.length>1?parseInt(r[1],10):1/0}const Ps=n=>{if(!n)return[];if(typeof n=="string")try{return JSON.parse(n).signatures||[]}catch(t){return console.error("Failed to parse witness string:",t),[]}return n.signatures||[]},un=(n,t,e=!1)=>{const r=Array.isArray(t)?t:[t];return n.map((o,a)=>{let u=o;for(const h of r)try{u=Cs(u,h)}catch(f){const p=f instanceof Error?f.message:"Unknown error";if(e)throw new Error(`Failed signing proof #${a+1}: ${p}`);console.warn(`Proof #${a+1}: ${p}`)}return u})},Cs=(n,t)=>{const e=$t(n.secret);if(e[0]!=="P2PK")throw new Error("not a P2PK secret");const r=nt(te.getPublicKey(t)),o=_s(e);if(!o.length||!o.some(h=>h.includes(r)))throw new Error(`Signature not required from [02|03]${r}`);const a=Ps(n.witness);if(a.some(h=>{try{return Ss(h,n.secret,r)}catch{return!1}}))throw new Error(`Proof already signed by [02|03]${r}`);const u=Is(n.secret,t);return a.push(u),{...n,witness:{signatures:a}}};function Us(n,t){let e=n;for(const o of t)e+=o.B_;const r=new TextEncoder().encode(e);return St(r)}function Ns(n,t,e){const r=Us(t,e),o=Rt(n),a=te.sign(r,o);return ft(a)}function fe(n,t,e){const r=Zt(n);t||(t=Nt(Y.utils.randomPrivateKey()));const o=Y.ProjectivePoint.BASE.multiply(t);return{B_:r.add(o),r:t,secret:n}}function Rs(n,t,e){return n.subtract(e.multiply(t))}function xs(n,t,e,r){const o=r,a=Rs(n.C_,t,o);return{id:n.id,amount:n.amount,secret:e,C:a}}const Ds=n=>({amount:n.amount,C:n.C.toHex(!0),id:n.id,secret:new TextDecoder().decode(n.secret),witness:JSON.stringify(n.witness)});function $s(n){return typeof n=="number"||typeof n=="string"}function Ls(n){const t=[];return Ke(n,t),new Uint8Array(t)}function Ke(n,t){if(n===null)t.push(246);else if(n===void 0)t.push(247);else if(typeof n=="boolean")t.push(n?245:244);else if(typeof n=="number")$n(n,t);else if(typeof n=="string")Ln(n,t);else if(Array.isArray(n))Os(n,t);else if(n instanceof Uint8Array)Ks(n,t);else if(typeof n=="object"&&n!==null&&!Array.isArray(n))qs(n,t);else throw new Error("Unsupported type")}function $n(n,t){if(n<24)t.push(n);else if(n<256)t.push(24,n);else if(n<65536)t.push(25,n>>8,n&255);else if(n<4294967296)t.push(26,n>>24,n>>16&255,n>>8&255,n&255);else throw new Error("Unsupported integer size")}function Ks(n,t){const e=n.length;if(e<24)t.push(64+e);else if(e<256)t.push(88,e);else if(e<65536)t.push(89,e>>8&255,e&255);else if(e<4294967296)t.push(90,e>>24&255,e>>16&255,e>>8&255,e&255);else throw new Error("Byte string too long to encode");for(let r=0;r<n.length;r++)t.push(n[r])}function Ln(n,t){const e=new TextEncoder().encode(n),r=e.length;if(r<24)t.push(96+r);else if(r<256)t.push(120,r);else if(r<65536)t.push(121,r>>8&255,r&255);else if(r<4294967296)t.push(122,r>>24&255,r>>16&255,r>>8&255,r&255);else throw new Error("String too long to encode");for(let o=0;o<e.length;o++)t.push(e[o])}function Os(n,t){const e=n.length;if(e<24)t.push(128|e);else if(e<256)t.push(152,e);else if(e<65536)t.push(153,e>>8,e&255);else throw new Error("Unsupported array length");for(const r of n)Ke(r,t)}function qs(n,t){const e=Object.keys(n);$n(e.length,t),t[t.length-1]|=160;for(const r of e)Ln(r,t),Ke(n[r],t)}function Fs(n){const t=new DataView(n.buffer,n.byteOffset,n.byteLength);return Xt(t,0).value}function Xt(n,t){if(t>=n.byteLength)throw new Error("Unexpected end of data");const e=n.getUint8(t++),r=e>>5,o=e&31;switch(r){case 0:return Ws(n,t,o);case 1:return Hs(n,t,o);case 2:return Qs(n,t,o);case 3:return zs(n,t,o);case 4:return js(n,t,o);case 5:return Gs(n,t,o);case 7:return Js(n,t,o);default:throw new Error(`Unsupported major type: ${r}`)}}function Tt(n,t,e){if(e<24)return{value:e,offset:t};if(e===24)return{value:n.getUint8(t++),offset:t};if(e===25){const r=n.getUint16(t,!1);return t+=2,{value:r,offset:t}}if(e===26){const r=n.getUint32(t,!1);return t+=4,{value:r,offset:t}}if(e===27){const r=n.getUint32(t,!1),o=n.getUint32(t+4,!1);return t+=8,{value:r*2**32+o,offset:t}}throw new Error(`Unsupported length: ${e}`)}function Ws(n,t,e){const{value:r,offset:o}=Tt(n,t,e);return{value:r,offset:o}}function Hs(n,t,e){const{value:r,offset:o}=Tt(n,t,e);return{value:-1-r,offset:o}}function Qs(n,t,e){const{value:r,offset:o}=Tt(n,t,e);if(o+r>n.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(n.buffer,n.byteOffset+o,r),offset:o+r}}function zs(n,t,e){const{value:r,offset:o}=Tt(n,t,e);if(o+r>n.byteLength)throw new Error("String length exceeds data length");const a=new Uint8Array(n.buffer,n.byteOffset+o,r);return{value:new TextDecoder().decode(a),offset:o+r}}function js(n,t,e){const{value:r,offset:o}=Tt(n,t,e),a=[];let u=o;for(let h=0;h<r;h++){const f=Xt(n,u);a.push(f.value),u=f.offset}return{value:a,offset:u}}function Gs(n,t,e){const{value:r,offset:o}=Tt(n,t,e),a={};let u=o;for(let h=0;h<r;h++){const f=Xt(n,u);if(!$s(f.value))throw new Error("Invalid key type");const p=Xt(n,f.offset);a[f.value]=p.value,u=p.offset}return{value:a,offset:u}}function Vs(n){const t=(n&31744)>>10,e=n&1023,r=n&32768?-1:1;return t===0?r*2**-14*(e/1024):t===31?e?NaN:r*(1/0):r*2**(t-15)*(1+e/1024)}function Js(n,t,e){if(e<24)switch(e){case 20:return{value:!1,offset:t};case 21:return{value:!0,offset:t};case 22:return{value:null,offset:t};case 23:return{value:void 0,offset:t};default:throw new Error(`Unknown simple value: ${e}`)}if(e===24)return{value:n.getUint8(t++),offset:t};if(e===25){const r=Vs(n.getUint16(t,!1));return t+=2,{value:r,offset:t}}if(e===26){const r=n.getFloat32(t,!1);return t+=4,{value:r,offset:t}}if(e===27){const r=n.getFloat64(t,!1);return t+=8,{value:r,offset:t}}throw new Error(`Unknown simple or float value: ${e}`)}const Ys="A",Zs="cashu";function J(n,t,e,r){if(e){const a=pn(e);if(n===0&&a===0)return e;const u=e.filter(f=>f>0),h=pn(u);if(h>n)throw new Error(`Split is greater than total amount: ${h} > ${n}`);if(u.some(f=>!On(f,t)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");if(h===n)return u;e=u,n-=h}else e=[];const o=Kn(t,"desc");if(!o||o.length===0)throw new Error("Cannot split amount, keyset is inactive or contains no keys");if(o.forEach(a=>{if(n<=0||a<=0)return;const u=Math.floor(n/a);for(let h=0;h<u;++h)e.push(a);n%=a}),n!==0)throw new Error(`Unable to split remaining amount: ${n}`);return e.sort((a,u)=>a-u)}function hn(n,t,e,r){const o=[],a=n.map(h=>h.amount);Kn(e,"asc").forEach(h=>{const f=a.filter(l=>l===h).length,p=Math.max(r-f,0);for(let l=0;l<p&&!(o.reduce((k,g)=>k+g,0)+h>t);++l)o.push(h)});const u=t-o.reduce((h,f)=>h+f,0);return u&&J(u,e).forEach(h=>{o.push(h)}),o.sort((h,f)=>h-f)}function Kn(n,t="desc"){return t=="desc"?Object.keys(n).map(e=>parseInt(e)).sort((e,r)=>r-e):Object.keys(n).map(e=>parseInt(e)).sort((e,r)=>e-r)}function On(n,t){return n in t}function Xs(n){return qn(nt(n))}function qn(n){return BigInt(`0x${n}`)}function to(n){return n.toString(16).padStart(64,"0")}function ln(n){return/^[a-f0-9]*$/i.test(n)}function Oe(n){return Array.isArray(n)?n.some(t=>!ln(t.id)):!ln(n.id)}function eo(n,t){Oe(n.proofs)||(n.proofs=Fn(n.proofs));const e={token:[{mint:n.mint,proofs:n.proofs}]};return n.unit&&(e.unit=n.unit),n.memo&&(e.memo=n.memo),Zs+Ys+gs(e)}function Fn(n){return n.map(t=>{const e={...t};return e.id=e.id.slice(0,16),e})}function no(n,t){return Oe(n.proofs)||t?.version===3?eo(n):ro(n)}function ro(n,t){if(n.proofs.forEach(h=>{if(h.dleq&&h.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),Oe(n.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");n.proofs=Fn(n.proofs);const e=so(n),r=Ls(e),o="cashu",a="B",u=ys(r);return o+a+u}function so(n){const t={},e=n.mint;for(let o=0;o<n.proofs.length;o++){const a=n.proofs[o];t[a.id]?t[a.id].push(a):t[a.id]=[a]}const r={m:e,u:n.unit||"sat",t:Object.keys(t).map(o=>({i:tt(o),p:t[o].map(a=>({a:a.amount,s:a.secret,c:tt(a.C),...a.dleq&&{d:{e:tt(a.dleq.e),s:tt(a.dleq.s),r:tt(a.dleq.r??"00")}},...a.witness&&{w:JSON.stringify(a.witness)}}))}))};return n.memo&&(r.d=n.memo),r}function oo(n){const t=[];n.t.forEach(r=>r.p.forEach(o=>{t.push({secret:o.s,C:nt(o.c),amount:o.a,id:nt(r.i),...o.d&&{dleq:{r:nt(o.d.r),s:nt(o.d.s),e:nt(o.d.e)}},...o.w&&{witness:o.w}})}));const e={mint:n.m,proofs:t,unit:n.u||"sat"};return n.d&&(e.memo=n.d),e}function Wn(n,t){["web+cashu://","cashu://","cashu:","cashu"].forEach(r=>{n.startsWith(r)&&(n=n.slice(r.length))});const e=io(n);return e.proofs=lo(e.proofs,t),e}function io(n){const t=n.slice(0,1),e=n.slice(1);if(t==="A"){const r=ms(e);if(r.token.length>1)throw new Error("Multi entry token are not supported");const o=r.token[0],a={mint:o.mint,proofs:o.proofs,unit:r.unit||"sat"};return r.memo&&(a.memo=r.memo),a}else if(t==="B"){const r=ws(e),o=Fs(r);return oo(o)}throw new Error("Token version is not supported")}function ao(n,t,e,r=0,o=!1){let a=Object.entries(n).sort((f,p)=>+f[0]-+p[0]).map(([,f])=>tt(f)).reduce((f,p)=>de(f,p),new Uint8Array);if(o){const f=At(a);return x.toBase64(f).slice(0,12)}let u,h;switch(r){case 0:return u=At(a),h=x.toHex(u).slice(0,14),"00"+h;case 1:if(!t)throw new Error("Cannot compute keyset ID version 01: unit is required.");return a=de(a,x.fromString("unit:"+t)),e&&(a=de(a,x.fromString("final_expiry:"+e.toString()))),u=At(a),h=x.toHex(u),"01"+h;default:throw new Error(`Unrecognized keyset ID version: ${r}`)}}function de(n,t){const e=new Uint8Array(n.length+t.length);return e.set(n),e.set(t,n.length),e}function at(n){return typeof n=="object"}function F(...n){return n.map(t=>t.replace(/(^\/+|\/+$)/g,"")).join("/")}function co(n){return n.replace(/\/$/,"")}function dt(n){return n.reduce((t,e)=>t+e.amount,0)}class uo{get value(){return this._value}set value(t){this._value=t}get next(){return this._next}set next(t){this._next=t}constructor(t){this._value=t,this._next=null}}class ho{get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}set size(t){this._size=t}constructor(){this._first=null,this._last=null,this._size=0}enqueue(t){const e=new uo(t);return this._size===0||!this._last?(this._first=e,this._last=e):(this._last.next=e,this._last=e),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const t=this._first;return this._first=t.next,t.next=null,this._size--,t.value}}function fn(n){return n.map(t=>{const e={...t};return delete e.dleq,e})}function dn(n){const t=Le(n.id),e=/^[a-fA-F0-9]+$/.test(n.id),r=e?tt(n.id)[0]:0;return ao(n.keys,n.unit,n.final_expiry,r,t&&!e)===n.id}function lo(n,t){const e=[];for(const r of n){let o;try{o=tt(r.id)}catch{e.push(r);continue}if(o[0]===0)e.push(r);else if(o[0]===1){if(!t)throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");let a=!1;for(const u of t)if(r.id===u.id.slice(0,r.id.length)){r.id=u.id,e.push(r),a=!0;break}if(!a)throw new Error(`Couldn't map short keyset ID ${r.id} to any known keysets of the current Mint`)}else throw new Error(`Unknown keyset ID version: ${o[0]}`)}return e}function fo(n,t){if(n.dleq==null)return!1;const e={e:tt(n.dleq.e),s:tt(n.dleq.s),r:qn(n.dleq.r??"00")};if(!On(n.amount,t.keys))throw new Error(`undefined key for amount ${n.amount}`);const r=t.keys[n.amount];return ns(new TextEncoder().encode(n.secret),e,xt(n.C),xt(r))}function pn(n){return n.reduce((t,e)=>t+e,0)}let Se;typeof WebSocket<"u"&&(Se=WebSocket);function po(){if(Se===void 0)throw new Error("WebSocket implementation not initialized");return Se}const st={fatal(){},error(){},warn(){},info(){},debug(){},trace(){},log(){}};function yo(){const n=Date.now();return{elapsed:()=>Date.now()-n}}class Et{constructor(){this.connectionMap=new Map}static getInstance(){return Et.instance||(Et.instance=new Et),Et.instance}getConnection(t,e){if(this.connectionMap.has(t))return this.connectionMap.get(t);const r=new wo(t,e);return this.connectionMap.set(t,r),r}}class wo{constructor(t,e){this.subListeners={},this.rpcListeners={},this.rpcId=0,this.onCloseCallbacks=[],this._WS=po(),this.url=new URL(t),this.messageQueue=new ho,this._logger=e??st}connect(){return this.connectionPromise||(this.connectionPromise=new Promise((t,e)=>{try{this.ws=new this._WS(this.url.toString()),this.onCloseCallbacks=[]}catch(r){e(r instanceof Error?r:new Error(String(r)));return}this.ws.onopen=()=>{t()},this.ws.onerror=()=>{e(new Error("Failed to open WebSocket"))},this.ws.onmessage=r=>{this.messageQueue.enqueue(r.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMessage.bind(this),0))},this.ws.onclose=r=>{this.connectionPromise=void 0,this.onCloseCallbacks.forEach(o=>o(r))}})),this.connectionPromise}sendRequest(t,e){if(this.ws?.readyState!==1){if(t==="unsubscribe")return;throw this._logger.error("Attempted sendRequest, but socket was not open"),new Error("Socket not open")}const r=this.rpcId;this.rpcId++;const o=JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:r});this.ws?.send(o)}closeSubscription(t){this.ws?.send(JSON.stringify(["CLOSE",t]))}addSubListener(t,e){(this.subListeners[t]=this.subListeners[t]||[]).push(e)}addRpcListener(t,e,r){this.rpcListeners[r]={callback:t,errorCallback:e}}removeRpcListener(t){delete this.rpcListeners[t]}removeListener(t,e){if(this.subListeners[t]){if(this.subListeners[t].length===1){delete this.subListeners[t];return}this.subListeners[t]=this.subListeners[t].filter(r=>r!==e)}}async ensureConnection(){this.ws?.readyState!==1&&await this.connect()}handleNextMessage(){if(this.messageQueue.size===0){clearInterval(this.handlingInterval),this.handlingInterval=void 0;return}const t=this.messageQueue.dequeue();let e;try{if(e=JSON.parse(t),"result"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].callback(),this.removeRpcListener(e.id));else if("error"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].errorCallback(new Error(e.error.message)),this.removeRpcListener(e.id));else if("method"in e&&!("id"in e)){const r=e.params?.subId;if(!r)return;if(this.subListeners[r]?.length>0){const o=e;this.subListeners[r].forEach(a=>a(o.params?.payload))}}}catch(r){this._logger.error("Error doing handleNextMessage",{e:r});return}}createSubscription(t,e,r){if(this.ws?.readyState!==1)throw this._logger.error("Attempted createSubscription, but socket was not open"),new Error("Socket is not open");const o=(Math.random()+1).toString(36).substring(7);return this.addRpcListener(()=>{this.addSubListener(o,e)},r,this.rpcId),this.sendRequest("subscribe",{...t,subId:o}),this.rpcId++,o}cancelSubscription(t,e,r){this.removeListener(t,e),this.addRpcListener(()=>{this._logger.info("Unsubscribed {subId}",{subId:t})},r||(o=>this._logger.error("Unsubscribe failed",{e:o})),this.rpcId),this.sendRequest("unsubscribe",{subId:t})}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){this.ws&&this.ws?.close()}onClose(t){this.onCloseCallbacks.push(t)}}const yn={UNSPENT:"UNSPENT",SPENT:"SPENT"},_t={UNPAID:"UNPAID",PENDING:"PENDING",PAID:"PAID"},_e={UNPAID:"UNPAID",PAID:"PAID"};class Dt extends Error{constructor(t,e){super(t),this.status=e,this.name="HttpResponseError",Object.setPrototypeOf(this,Dt.prototype)}}class qe extends Error{constructor(t){super(t),this.name="NetworkError",Object.setPrototypeOf(this,qe.prototype)}}class Fe extends Dt{constructor(t,e){super(e||"Unknown mint operation error",400),this.code=t,this.name="MintOperationError",Object.setPrototypeOf(this,Fe.prototype)}}let go={},Hn=st;function mo(n){Hn=n}async function ko({endpoint:n,requestBody:t,headers:e,...r}){const o=t?JSON.stringify(t):void 0,a={Accept:"application/json, text/plain, */*",...o?{"Content-Type":"application/json"}:void 0,...e};let u;try{u=await fetch(n,{body:o,headers:a,...r})}catch(h){throw new qe(h instanceof Error?h.message:"Network request failed")}if(!u.ok){let h;try{h=await u.json()}catch{h={error:"bad response"}}if(u.status===400&&"code"in h&&typeof h.code=="number"&&"detail"in h&&typeof h.detail=="string")throw new Fe(h.code,h.detail);let f="HTTP request failed";throw"error"in h&&typeof h.error=="string"?f=h.error:"detail"in h&&typeof h.detail=="string"&&(f=h.detail),new Dt(f,u.status)}try{return await u.json()}catch(h){throw Hn.error("Failed to parse HTTP response",{err:h}),new Dt("bad response",u.status)}}async function Q(n){return await ko({...n,...go})}function pe(n,t){return n.state||(t.warn("Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof n.paid=="boolean"&&(n.state=n.paid?_t.PAID:_t.UNPAID)),n}function wn(n,t){return n.state||(t.warn("Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof n.paid=="boolean"&&(n.state=n.paid?_e.PAID:_e.UNPAID)),n}function bo(n,t){return Array.isArray(n?.contact)&&n?.contact.length>0&&(n.contact=n.contact.map(e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="string"&&typeof e[1]=="string"?(t.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:e[0],info:e[1]}):e)),n}class Be{constructor(t){this._mintInfo=t,t.nuts[22]&&(this._protectedEnpoints={cache:{},apiReturn:t.nuts[22].protected_endpoints.map(e=>({method:e.method,regex:new RegExp(e.path)}))})}isSupported(t){switch(t){case 4:case 5:return this.checkMintMelt(t);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(t);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}requiresBlindAuthToken(t){if(!this._protectedEnpoints)return!1;if(typeof this._protectedEnpoints.cache[t]=="boolean")return this._protectedEnpoints.cache[t];const e=this._protectedEnpoints.apiReturn.some(r=>r.regex.test(t));return this._protectedEnpoints.cache[t]=e,e}checkGenericNut(t){return this._mintInfo.nuts[t]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(t){const e=this._mintInfo.nuts[t];return e&&e.methods.length>0&&!e.disabled?{disabled:!1,params:e.methods}:{disabled:!0,params:e.methods}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}get supportsBolt12Description(){return this._mintInfo.nuts[4]?.methods.some(t=>t.method==="bolt12"&&t.options?.description===!0)}}class L{constructor(t,e,r,o){this._mintUrl=t,this._customRequest=e,this._checkNut22=!1,this._mintUrl=co(t),this._customRequest=e,r&&(this._checkNut22=!0,this._authTokenGetter=r),this._logger=o?.logger??st,mo(this._logger)}get mintUrl(){return this._mintUrl}static async getInfo(t,e,r){const o=r??st,a=await(e||Q)({endpoint:F(t,"/v1/info")});return bo(a,o)}async getInfo(){return L.getInfo(this._mintUrl,this._customRequest,this._logger)}async getLazyMintInfo(){if(this._mintInfo)return this._mintInfo;const t=await L.getInfo(this._mintUrl,this._customRequest);return this._mintInfo=new Be(t),this._mintInfo}static async swap(t,e,r,o){const a=r||Q,u=o?{"Blind-auth":o}:{},h=await a({endpoint:F(t,"/v1/swap"),method:"POST",requestBody:e,headers:u});if(!at(h)||!Array.isArray(h?.signatures))throw new Error(h.detail??"bad response");return h}async swap(t){const e=await this.handleBlindAuth("/v1/swap");return L.swap(this._mintUrl,t,this._customRequest,e)}static async createMintQuote(t,e,r,o,a){const u=a??st,h=r||Q,f=o?{"Blind-auth":o}:{},p=await h({endpoint:F(t,"/v1/mint/quote/bolt11"),method:"POST",requestBody:e,headers:f});return wn(p,u)}async createMintQuote(t){const e=await this.handleBlindAuth("/v1/mint/quote/bolt11");return L.createMintQuote(this._mintUrl,t,this._customRequest,e)}static async createMintQuoteBolt12(t,e,r,o){const a=r||Q,u=o?{"Blind-auth":o}:{};return await a({endpoint:F(t,"/v1/mint/quote/bolt12"),method:"POST",requestBody:e,headers:u})}async createMintQuoteBolt12(t){const e=await this.handleBlindAuth("/v1/mint/quote/bolt12");return L.createMintQuoteBolt12(this._mintUrl,t,this._customRequest,e)}static async checkMintQuote(t,e,r,o,a){const u=a??st,h=r||Q,f=o?{"Blind-auth":o}:{},p=await h({endpoint:F(t,"/v1/mint/quote/bolt11",e),method:"GET",headers:f});return wn(p,u)}async checkMintQuote(t){const e=await this.handleBlindAuth(`/v1/mint/quote/bolt11/${t}`);return L.checkMintQuote(this._mintUrl,t,this._customRequest,e)}static async checkMintQuoteBolt12(t,e,r,o){const a=r||Q,u=o?{"Blind-auth":o}:{};return await a({endpoint:F(t,"/v1/mint/quote/bolt12",e),method:"GET",headers:u})}async checkMintQuoteBolt12(t){const e=await this.handleBlindAuth(`/v1/mint/quote/bolt12/${t}`);return L.checkMintQuoteBolt12(this._mintUrl,t,this._customRequest,e)}static async mint(t,e,r,o){const a=r||Q,u=o?{"Blind-auth":o}:{},h=await a({endpoint:F(t,"/v1/mint/bolt11"),method:"POST",requestBody:e,headers:u});if(!at(h)||!Array.isArray(h?.signatures))throw new Error("bad response");return h}async mint(t){const e=await this.handleBlindAuth("/v1/mint/bolt11");return L.mint(this._mintUrl,t,this._customRequest,e)}static async mintBolt12(t,e,r,o){const a=r||Q,u=o?{"Blind-auth":o}:{},h=await a({endpoint:F(t,"/v1/mint/bolt12"),method:"POST",requestBody:e,headers:u});if(!at(h)||!Array.isArray(h?.signatures))throw new Error("bad response");return h}async mintBolt12(t){const e=await this.handleBlindAuth("/v1/mint/bolt12");return L.mintBolt12(this._mintUrl,t,this._customRequest,e)}static async createMeltQuote(t,e,r,o,a){const u=a??st,h=r||Q,f=o?{"Blind-auth":o}:{},p=await h({endpoint:F(t,"/v1/melt/quote/bolt11"),method:"POST",requestBody:e,headers:f}),l=pe(p,u);if(!at(l)||typeof l?.amount!="number"||typeof l?.fee_reserve!="number"||typeof l?.quote!="string")throw new Error("bad response");return l}async createMeltQuote(t){const e=await this.handleBlindAuth("/v1/melt/quote/bolt11");return L.createMeltQuote(this._mintUrl,t,this._customRequest,e)}static async createMeltQuoteBolt12(t,e,r,o){const a=r||Q,u=o?{"Blind-auth":o}:{};return await a({endpoint:F(t,"/v1/melt/quote/bolt12"),method:"POST",requestBody:e,headers:u})}async createMeltQuoteBolt12(t){const e=await this.handleBlindAuth("/v1/melt/quote/bolt12");return L.createMeltQuoteBolt12(this._mintUrl,t,this._customRequest,e)}static async checkMeltQuote(t,e,r,o,a){const u=a??st,h=r||Q,f=o?{"Blind-auth":o}:{},p=await h({endpoint:F(t,"/v1/melt/quote/bolt11",e),method:"GET",headers:f}),l=pe(p,u);if(!at(l)||typeof l?.amount!="number"||typeof l?.fee_reserve!="number"||typeof l?.quote!="string"||typeof l?.state!="string"||!Object.values(_t).includes(l.state))throw new Error("bad response");return l}async checkMeltQuote(t){const e=await this.handleBlindAuth(`/v1/melt/quote/bolt11/${t}`);return L.checkMeltQuote(this._mintUrl,t,this._customRequest,e)}static async checkMeltQuoteBolt12(t,e,r,o){const a=r||Q,u=o?{"Blind-auth":o}:{};return await a({endpoint:F(t,"/v1/melt/quote/bolt12",e),method:"GET",headers:u})}async checkMeltQuoteBolt12(t){const e=await this.handleBlindAuth(`/v1/melt/quote/bolt12/${t}`);return L.checkMeltQuoteBolt12(this._mintUrl,t,this._customRequest,e)}static async melt(t,e,r,o,a){const u=a??st,h=r||Q,f=o?{"Blind-auth":o}:{},p=await h({endpoint:F(t,"/v1/melt/bolt11"),method:"POST",requestBody:e,headers:f}),l=pe(p,u);if(!at(l)||typeof l?.state!="string"||!Object.values(_t).includes(l.state))throw new Error("bad response");return l}async melt(t){const e=await this.handleBlindAuth("/v1/melt/bolt11");return L.melt(this._mintUrl,t,this._customRequest,e)}static async meltBolt12(t,e,r,o){const a=r||Q,u=o?{"Blind-auth":o}:{};return await a({endpoint:F(t,"/v1/melt/bolt12"),method:"POST",requestBody:e,headers:u})}async meltBolt12(t){const e=await this.handleBlindAuth("/v1/melt/bolt12");return L.meltBolt12(this._mintUrl,t,this._customRequest,e)}static async check(t,e,r){const o=await(r||Q)({endpoint:F(t,"/v1/checkstate"),method:"POST",requestBody:e});if(!at(o)||!Array.isArray(o?.states))throw new Error("bad response");return o}static async getKeys(t,e,r){e&&(e=e.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(r||Q)({endpoint:e?F(t,"/v1/keys",e):F(t,"/v1/keys")});if(!at(o)||!Array.isArray(o.keysets))throw new Error("bad response");return o}async getKeys(t,e){return await L.getKeys(e||this._mintUrl,t,this._customRequest)}static async getKeySets(t,e){return(e||Q)({endpoint:F(t,"/v1/keysets")})}async getKeySets(){return L.getKeySets(this._mintUrl,this._customRequest)}async check(t){return L.check(this._mintUrl,t,this._customRequest)}static async restore(t,e,r){const o=await(r||Q)({endpoint:F(t,"/v1/restore"),method:"POST",requestBody:e});if(!at(o)||!Array.isArray(o?.outputs)||!Array.isArray(o?.signatures))throw new Error("bad response");return o}async restore(t){return L.restore(this._mintUrl,t,this._customRequest)}async connectWebSocket(){if(this.ws)await this.ws.ensureConnection();else{const t=new URL(this._mintUrl),e="v1/ws";t.pathname&&(t.pathname.endsWith("/")?t.pathname+=e:t.pathname+="/"+e),this.ws=Et.getInstance().getConnection(`${t.protocol==="https:"?"wss":"ws"}://${t.host}${t.pathname}`);try{await this.ws.connect()}catch(r){throw this._logger.error("Failed to connect to WebSocket...",{e:r}),new Error("Failed to connect to WebSocket...")}}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}async handleBlindAuth(t){if(this._checkNut22&&(await this.getLazyMintInfo()).requiresBlindAuthToken(t)){if(!this._authTokenGetter)throw new Error("Can not call a protected endpoint without authProofGetter");return this._authTokenGetter()}}}class ye{constructor(t,e,r){this.amount=t,this.B_=e,this.id=r}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}function we(n){return typeof n=="function"}class ct{constructor(t,e,r){this.secret=r,this.blindingFactor=e,this.blindedMessage=t}toProof(t,e){let r;t.dleq&&(r={s:Rt(t.dleq.s),e:Rt(t.dleq.e),r:this.blindingFactor});const o={id:t.id,amount:t.amount,C_:xt(t.C_)},a=xt(e.keys[t.amount]),u=xs(o,this.blindingFactor,this.secret,a);return{...Ds(u),...r&&{dleq:{s:ft(r.s),e:ft(r.e),r:to(r.r??BigInt(0))}}}}static createP2PKData(t,e,r,o){return J(e,r.keys,o).map(a=>this.createSingleP2PKData(t,a,r.id))}static createSingleP2PKData(t,e,r){const o=Array.isArray(t.pubkey)?t.pubkey:[t.pubkey],a=Math.max(1,Math.min(t.requiredSignatures||1,o.length)),u=Math.max(1,Math.min(t.requiredRefundSignatures||1,t.refundKeys?t.refundKeys.length:1)),h=["P2PK",{nonce:ft(nn(32)),data:o[0],tags:[]}];t.locktime&&h[1].tags.push(["locktime",String(t.locktime)]),o.length>1&&(h[1].tags.push(["pubkeys",...o.slice(1)]),a>1&&h[1].tags.push(["n_sigs",String(a)])),t.refundKeys&&(h[1].tags.push(["refund",...t.refundKeys]),u>1&&h[1].tags.push(["n_sigs_refund",String(u)]));const f=JSON.stringify(h),p=new TextEncoder().encode(f),{r:l,B_:k}=fe(p);return new ct(new ye(e,k,r).getSerializedBlindedMessage(),l,p)}static createRandomData(t,e,r){return J(t,e.keys,r).map(o=>this.createSingleRandomData(o,e.id))}static createSingleRandomData(t,e){const r=ft(nn(32)),o=new TextEncoder().encode(r),{r:a,B_:u}=fe(o);return new ct(new ye(t,u,e).getSerializedBlindedMessage(),a,o)}static createDeterministicData(t,e,r,o,a){return J(t,o.keys,a).map((u,h)=>this.createSingleDeterministicData(u,e,r+h,o.id))}static createSingleDeterministicData(t,e,r,o){const a=Es(e,o,r),u=ft(a),h=new TextEncoder().encode(u),f=Xs(As(e,o,r)),{r:p,B_:l}=fe(h,f);return new ct(new ye(t,l,o).getSerializedBlindedMessage(),p,h)}}const vo=3,Eo="sat";class Ao{constructor(t,e){this._keys=new Map,this._keysets=[],this._seed=void 0,this._unit=Eo,this._mintInfo=void 0,this._denominationTarget=vo,this.mint=t,this._logger=e?.logger??st;let r=[];if(e?.keys&&!Array.isArray(e.keys)?r=[e.keys]:e?.keys&&Array.isArray(e?.keys)&&(r=e?.keys),r&&r.forEach(o=>this._keys.set(o.id,o)),e?.unit&&(this._unit=e?.unit),e?.keysets&&(this._keysets=e.keysets),e?.mintInfo&&(this._mintInfo=new Be(e.mintInfo)),e?.denominationTarget&&(this._denominationTarget=e.denominationTarget),e?.bip39seed){if(e.bip39seed instanceof Uint8Array){this._seed=e.bip39seed;return}throw new Error("bip39seed must be a valid UInt8Array")}e?.keepFactory&&(this._keepFactory=e.keepFactory)}get unit(){return this._unit}get keys(){return this._keys}get keysetId(){if(!this._keysetId)throw new Error("No keysetId set");return this._keysetId}set keysetId(t){this._keysetId=t}get keysets(){return this._keysets}get mintInfo(){if(!this._mintInfo)throw new Error("Mint info not loaded");return this._mintInfo}async getMintInfo(){const t=await this.mint.getInfo();return this._mintInfo=new Be(t),this._mintInfo}async lazyGetMintInfo(){return this._mintInfo?this._mintInfo:await this.getMintInfo()}async loadMint(){await Promise.all([this.getMintInfo(),this.getKeys()])}getActiveKeyset(t){let e=t.filter(o=>o.active&&o.unit===this._unit);e=e.filter(o=>o.id.startsWith("00"));const r=e.sort((o,a)=>(o.input_fee_ppk??0)-(a.input_fee_ppk??0))[0];if(!r)throw new Error("No active keyset found");return r}async getKeySets(){const t=(await this.mint.getKeySets()).keysets.filter(e=>e.unit===this._unit);return this._keysets=t,this._keysets}async getAllKeys(){const t=await this.mint.getKeys();return t.keysets.forEach(e=>{if(!dn(e))throw new Error(`Couldn't verify keyset ID ${e.id}`)}),this._keys=new Map(t.keysets.map(e=>[e.id,e])),this.keysetId=this.getActiveKeyset(this._keysets).id,t.keysets}async getKeys(t,e){if((!(this._keysets.length>0)||e)&&await this.getKeySets(),t||(t=this.getActiveKeyset(this._keysets).id),!this._keysets.find(r=>r.id===t)&&(await this.getKeySets(),!this._keysets.find(r=>r.id===t)))throw new Error(`could not initialize keys. No keyset with id '${t}' found`);if(!this._keys.get(t)){const r=await this.mint.getKeys(t);if(!dn(r.keysets[0]))throw new Error(`Couldn't verify keyset ID ${r.keysets[0].id}`);this._keys.set(t,r.keysets[0])}return this.keysetId=t,this._keys.get(t)}async receive(t,e){const{requireDleq:r,keysetId:o,outputAmounts:a,counter:u,pubkey:h,privkey:f,outputData:p,p2pk:l}=e||{};this._keysets.length===0&&await this.getKeySets(),typeof t=="string"&&(t=Wn(t,this._keysets));const k=await this.getKeys(o);if(r&&t.proofs.some(B=>!fo(B,k)))throw new Error("Token contains proofs with invalid DLEQ");const g=dt(t.proofs)-this.getFeesForProofs(t.proofs);let w;p?w={send:p}:this._keepFactory&&(w={send:this._keepFactory});const b=this.createSwapPayload(g,t.proofs,k,a,u,h,f,w,l),{signatures:E}=await this.mint.swap(b.payload),I=b.outputData.map((B,T)=>B.toProof(E[T],k)),S=[];return b.sortedIndices.forEach((B,T)=>{S[B]=I[T]}),S}async send(t,e,r){const{offline:o,includeFees:a,includeDleq:u,keysetId:h,outputAmounts:f,pubkey:p,privkey:l,outputData:k}=r||{};if(u&&(e=e.filter(E=>E.dleq!=null)),dt(e)<t)throw new Error("Not enough funds available to send");const{keep:g,send:w}=this.selectProofsToSend(e,t,r?.includeFees),b=a?this.getFeesForProofs(w):0;if(!o&&(dt(w)!=t+b||f||p||l||h||k)){const E=await this.swap(t,e,r),{keep:I,send:S}=E,B=E.serialized;return{keep:I,send:S,serialized:B}}if(dt(w)<t+b)throw new Error("Not enough funds available to send");return{keep:g,send:w}}selectProofsToSend(t,e,r=!1){const o=yo();let a=null,u=1/0,h=0,f=0;const p=(A,_)=>A-(r?Math.ceil(_/1e3):0),l=A=>{const _=[...A];for(let P=_.length-1;P>0;P--){const M=Math.floor(Math.random()*(P+1));[_[P],_[M]]=[_[M],_[P]]}return _},k=(A,_,P)=>{let M=0,O=A.length-1,z=null;for(;M<=O;){const G=Math.floor((M+O)/2),et=A[G].exFee;(P?et<=_:et>=_)?(z=G,P?M=G+1:O=G-1):P?O=G-1:M=G+1}return P?z:M<A.length?M:null},g=(A,_)=>{const P=_.exFee;let M=0,O=A.length;for(;M<O;){const z=Math.floor((M+O)/2);A[z].exFee<P?M=z+1:O=z}A.splice(M,0,_)},w=(A,_)=>p(A,_)<e?1/0:A+_/1e3-e;let b=0,E=0;const I=t.map(A=>{const _=this.getProofFeePPK(A),P=r?A.amount-_/1e3:A.amount,M={proof:A,exFee:P,ppkfee:_};return(!r||P>0)&&(b+=A.amount,E+=_),M});let S=r?I.filter(A=>A.exFee>0):I;if(S.sort((A,_)=>A.exFee-_.exFee),S.length>0){let A;{const _=k(S,e,!1);if(_!==null){const P=S[_].exFee,M=k(S,P,!0);if(M===null)throw new Error("Unexpected null rightIndex in binary search");A=M+1}else A=S.length}for(let _=A;_<S.length;_++)b-=S[_].proof.amount,E-=S[_].ppkfee;S=S.slice(0,A)}const B=p(b,E);if(e<=0||e>B)return{keep:t,send:[]};const T=Math.min(Math.ceil(e*(1+0/100)),e+0,B);for(let A=0;A<60;A++){const _=[];let P=0,M=0;for(const K of l(S)){const W=P+K.proof.amount,C=M+K.ppkfee,$=p(W,C);if(_.push(K),P=W,M=C,$>=e)break}const O=new Set(_),z=S.filter(K=>!O.has(K)),G=l(Array.from({length:_.length},(K,W)=>W)).slice(0,5e3);for(const K of G){const W=p(P,M);if(W===e||W>=e&&W<=T)break;const C=_[K],$=P-C.proof.amount,ht=M-C.ppkfee,Kt=p($,ht),Mt=e-Kt,Pt=k(z,Mt,!1);if(Pt!==null){const gt=z[Pt];(Mt>=0||gt.exFee<=C.exFee)&&(_[K]=gt,P=$+gt.proof.amount,M=ht+gt.ppkfee,z.splice(Pt,1),g(z,C))}}const et=w(P,M);if(et<u){this._logger.debug("selectProofsToSend: best solution found in trial #{trial} - amount: {amount}, delta: {delta}",{trial:A,amount:P,delta:et}),a=[..._].sort((W,C)=>C.exFee-W.exFee),u=et,h=P,f=M;const K=[...a];for(;K.length>1&&u>0;){const W=K.pop(),C=P-W.proof.amount,$=M-W.ppkfee,ht=w(C,$);if(ht==1/0)break;ht<u&&(a=[...K],u=ht,h=C,f=$,P=C,M=$)}}if(a&&u<1/0){const K=p(h,f);if(K===e||K>=e&&K<=T)break}if(o.elapsed()>1e3){this._logger.warn("Proof selection took too long. Returning best selection so far.");break}}if(a&&u<1/0){const A=a.map(M=>M.proof),_=new Set(A),P=t.filter(M=>!_.has(M));return this._logger.info("Proof selection took {time}ms",{time:o.elapsed()}),{keep:P,send:A}}return{keep:t,send:[]}}getFeesForProofs(t){const e=t.reduce((r,o)=>r+this.getProofFeePPK(o),0);return Math.ceil(e/1e3)}getProofFeePPK(t){const e=this._keysets.find(r=>r.id===t.id);if(!e)throw new Error(`Could not get fee. No keyset found for keyset id: ${t.id}`);return e?.input_fee_ppk||0}getFeesForKeyset(t,e){return Math.floor(Math.max((t*(this._keysets.find(r=>r.id===e)?.input_fee_ppk||0)+999)/1e3,0))}async swap(t,e,r){let{outputAmounts:o}=r||{};const{includeFees:a,keysetId:u,counter:h,pubkey:f,privkey:p,proofsWeHave:l,outputData:k,p2pk:g}=r||{},w=await this.getKeys(u);let b=t;const E=dt(e);let I=o?.sendAmounts||J(b,w.keys);if(a){let C=this.getFeesForKeyset(I.length,w.id),$=J(C,w.keys);for(;this.getFeesForKeyset(I.concat($).length,w.id)>C;)C++,$=J(C,w.keys);I=I.concat($),b+=C}const{keep:S,send:B}=this.selectProofsToSend(e,b,!0),T=dt(B)-this.getFeesForProofs(B)-b;if(T<0)throw new Error("Not enough balance to send");let A;if(!o?.keepAmounts&&!l)A=J(T,w.keys);else if(!o?.keepAmounts&&l)A=hn(l,T,w.keys,this._denominationTarget);else if(o){if(o.keepAmounts?.reduce((C,$)=>C+$,0)!=T)throw new Error("Keep amounts do not match amount to keep");A=o.keepAmounts}if(b+this.getFeesForProofs(B)>E)throw this._logger.error(`Not enough funds available (${E}) for swap amountToSend: ${b} + fee: ${this.getFeesForProofs(B)} | length: ${B.length}`),new Error("Not enough funds available for swap");o={keepAmounts:A,sendAmounts:I};const _=k?.keep||this._keepFactory,P=k?.send,M=this.createSwapPayload(b,B,w,o,h,f,p,{keep:_,send:P},g),{signatures:O}=await this.mint.swap(M.payload),z=M.outputData.map((C,$)=>C.toProof(O[$],w)),G=[],et=[],K=Array(M.keepVector.length),W=Array(z.length);return M.sortedIndices.forEach((C,$)=>{K[C]=M.keepVector[$],W[C]=z[$]}),W.forEach((C,$)=>{K[$]?G.push(C):et.push(C)}),{keep:[...G,...S],send:et}}async batchRestore(t=300,e=100,r=0,o){const a=Math.ceil(t/e),u=[];let h,f=0;for(;f<a;){const p=await this.restore(r,e,{keysetId:o});p.proofs.length>0?(f=0,u.push(...p.proofs),h=p.lastCounterWithSignature):f++,r+=e}return{proofs:u,lastCounterWithSignature:h}}async restore(t,e,r){const{keysetId:o}=r||{},a=await this.getKeys(o);if(!this._seed)throw new Error("CashuWallet must be initialized with a seed to use restore");const u=Array(e).fill(0),h=ct.createDeterministicData(0,this._seed,t,a,u),{outputs:f,signatures:p}=await this.mint.restore({outputs:h.map(w=>w.blindedMessage)}),l={};f.forEach((w,b)=>l[w.B_]=p[b]);const k=[];let g;for(let w=0;w<h.length;w++){const b=l[h[w].blindedMessage.B_];b&&(g=t+w,h[w].blindedMessage.amount=b.amount,k.push(h[w].toProof(b,a)))}return{proofs:k,lastCounterWithSignature:g}}async createMintQuote(t,e){const r={unit:this._unit,amount:t,description:e},o=await this.mint.createMintQuote(r);return{...o,amount:o.amount||t,unit:o.unit||this.unit}}async createLockedMintQuote(t,e,r){const{supported:o}=(await this.lazyGetMintInfo()).isSupported(20);if(!o)throw new Error("Mint does not support NUT-20");const a={unit:this._unit,amount:t,description:r,pubkey:e},u=await this.mint.createMintQuote(a);if(typeof u.pubkey!="string")throw new Error("Mint returned unlocked mint quote");{const h=u.pubkey;return{...u,pubkey:h,amount:u.amount||t,unit:u.unit||this.unit}}}async createMintQuoteBolt12(t,e){const r=await this.lazyGetMintInfo();if(e?.description&&!r.supportsBolt12Description)throw new Error("Mint does not support description for bolt12");const o={pubkey:t,unit:this._unit,amount:e?.amount,description:e?.description};return this.mint.createMintQuoteBolt12(o)}async checkMintQuote(t){const e=typeof t=="string"?t:t.quote,r=await this.mint.checkMintQuote(e);return typeof t=="string"?r:{...r,amount:r.amount||t.amount,unit:r.unit||t.unit}}async checkMintQuoteBolt12(t){return this.mint.checkMintQuoteBolt12(t)}async mintProofs(t,e,r){return this._mintProofs("bolt11",t,e,r)}async mintProofsBolt12(t,e,r,o){return this._mintProofs("bolt12",t,e,{...o,privateKey:r})}async createMeltQuote(t){const e={unit:this._unit,request:t},r=await this.mint.createMeltQuote(e);return{...r,unit:r.unit||this.unit,request:r.request||t}}async createMeltQuoteBolt12(t,e){return this.mint.createMeltQuoteBolt12({unit:this._unit,request:t,options:e?{amountless:{amount_msat:e}}:void 0})}async createMultiPathMeltQuote(t,e){const{supported:r,params:o}=(await this.lazyGetMintInfo()).isSupported(15);if(!r)throw new Error("Mint does not support NUT-15");if(!o?.some(h=>h.method==="bolt11"&&h.unit===this.unit))throw new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);const a={mpp:{amount:e}},u={unit:this._unit,request:t,options:a};return{...await this.mint.createMeltQuote(u),request:t,unit:this._unit}}async checkMeltQuote(t){const e=typeof t=="string"?t:t.quote,r=await this.mint.checkMeltQuote(e);return typeof t=="string"?r:{...r,request:t.request,unit:t.unit}}async checkMeltQuoteBolt12(t){return this.mint.checkMeltQuoteBolt12(t)}async meltProofs(t,e,r){return this._meltProofs("bolt11",t,e,r)}async meltProofsBolt12(t,e,r){return this._meltProofs("bolt12",t,e,r)}createSwapPayload(t,e,r,o,a,u,h,f,p){const l=e.reduce((T,A)=>T+A.amount,0);o&&o.sendAmounts&&!o.keepAmounts&&(o.keepAmounts=J(l-t-this.getFeesForProofs(e),r.keys));const k=l-t-this.getFeesForProofs(e);let g=[],w=[];if(f?.keep)if(we(f.keep)){const T=f.keep;J(k,r.keys).forEach(A=>{g.push(T(A,r))})}else g=f.keep;else g=this.createOutputData(k,r,a,void 0,o?.keepAmounts,void 0,this._keepFactory);if(f?.send)if(we(f.send)){const T=f.send;J(t,r.keys).forEach(A=>{w.push(T(A,r))})}else w=f.send;else w=this.createOutputData(t,r,a?a+g.length:void 0,u,o?.sendAmounts,p);h&&(e=un(e,h)),e=fn(e),e=e.map(T=>{const A=T.witness&&typeof T.witness!="string"?JSON.stringify(T.witness):T.witness;return{...T,witness:A}});const b=[...g,...w],E=b.map((T,A)=>A).sort((T,A)=>b[T].blindedMessage.amount-b[A].blindedMessage.amount),I=[...Array.from({length:g.length},()=>!0),...Array.from({length:w.length},()=>!1)],S=E.map(T=>b[T]),B=E.map(T=>I[T]);return{payload:{inputs:e,outputs:S.map(T=>T.blindedMessage)},outputData:S,keepVector:B,sortedIndices:E}}async checkProofsStates(t){const e=new TextEncoder,r=t.map(u=>Zt(e.encode(u.secret)).toHex(!0)),o=100,a=[];for(let u=0;u<r.length;u+=o){const h=r.slice(u,u+o),{states:f}=await this.mint.check({Ys:h}),p={};f.forEach(l=>{p[l.Y]=l});for(let l=0;l<h.length;l++){const k=p[h[l]];if(!k)throw new Error("Could not find state for proof with Y: "+h[l]);a.push(k)}}return a}async onMintQuoteUpdates(t,e,r){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const o=this.mint.webSocketConnection.createSubscription({kind:"bolt11_mint_quote",filters:t},e,r);return()=>{this.mint.webSocketConnection?.cancelSubscription(o,e)}}async onMeltQuotePaid(t,e,r){return this.onMeltQuoteUpdates([t],o=>{o.state===_t.PAID&&e(o)},r)}async onMintQuotePaid(t,e,r){return this.onMintQuoteUpdates([t],o=>{o.state===_e.PAID&&e(o)},r)}async onMeltQuoteUpdates(t,e,r){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const o=this.mint.webSocketConnection.createSubscription({kind:"bolt11_melt_quote",filters:t},e,r);return()=>{this.mint.webSocketConnection?.cancelSubscription(o,e)}}async onProofStateUpdates(t,e,r){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const o=new TextEncoder,a={};for(let f=0;f<t.length;f++){const p=Zt(o.encode(t[f].secret)).toHex(!0);a[p]=t[f]}const u=Object.keys(a),h=this.mint.webSocketConnection.createSubscription({kind:"proof_state",filters:u},f=>{e({...f,proof:a[f.Y]})},r);return()=>{this.mint.webSocketConnection?.cancelSubscription(h,e)}}createOutputData(t,e,r,o,a,u,h){let f;if(o)f=ct.createP2PKData({pubkey:o},t,e,a);else if(r||r===0){if(!this._seed)throw new Error("cannot create deterministic messages without seed");f=ct.createDeterministicData(t,this._seed,r,e,a)}else u?f=ct.createP2PKData(u,t,e,a):h?f=J(t,e.keys).map(p=>h(p,e)):f=ct.createRandomData(t,e,a);return f}createBlankOutputs(t,e,r,o){let a=Math.ceil(Math.log2(t))||1;a<0&&(a=0);const u=a?Array(a).fill(0):[];return this.createOutputData(0,e,r,void 0,u,void 0,o)}async _mintProofs(t,e,r,o){let{outputAmounts:a}=o||{};const{counter:u,pubkey:h,p2pk:f,keysetId:p,proofsWeHave:l,outputData:k,privateKey:g}=o||{},w=await this.getKeys(p);!a&&l&&(a={keepAmounts:hn(l,e,w.keys,this._denominationTarget),sendAmounts:[]});let b=[];if(k)if(we(k)){const S=J(e,w.keys,a?.keepAmounts);for(let B=0;B<S.length;B++)b.push(k(S[B],w))}else b=k;else if(this._keepFactory){const S=J(e,w.keys,a?.keepAmounts);for(let B=0;B<S.length;B++)b.push(this._keepFactory(S[B],w))}else b=this.createOutputData(e,w,u,h,a?.keepAmounts,f);let E;if(typeof r!="string"){if(!g)throw new Error("Can not sign locked quote without private key");const S=b.map(T=>T.blindedMessage),B=Ns(g,r.quote,S);E={outputs:S,quote:r.quote,signature:B}}else E={outputs:b.map(S=>S.blindedMessage),quote:r};if(t==="bolt12"){const{signatures:S}=await this.mint.mintBolt12(E);return b.map((B,T)=>B.toProof(S[T],w))}const{signatures:I}=await this.mint.mint(E);return b.map((S,B)=>S.toProof(I[B],w))}async _meltProofs(t,e,r,o){const{keysetId:a,counter:u,privkey:h}=o||{},f=await this.getKeys(a),p=this.createBlankOutputs(dt(r)-e.amount,f,u,this._keepFactory);h!=null&&(r=un(r,h)),r=fn(r),r=r.map(g=>{const w=g.witness&&typeof g.witness!="string"?JSON.stringify(g.witness):g.witness;return{...g,witness:w}});const l={quote:e.quote,inputs:r,outputs:p.map(g=>g.blindedMessage)};if(t==="bolt12"){const g=await this.mint.meltBolt12(l);return{quote:{...g,unit:e.unit,request:e.request},change:g.change?.map((w,b)=>p[b].toProof(w,f))??[]}}const k=await this.mint.melt(l);return{quote:{...k,unit:e.unit,request:e.request},change:k.change?.map((g,w)=>p[w].toProof(g,f))??[]}}}var Te={MINIMUM:4096,DEFAULT:5e4},Lt={SYNC_SESSION:5e3,CACHE_QUERY:5e3,EVENT_FETCH:1e4,RELAY_CONNECTION:3e4},gn={BUCKET_COUNT:16,MIN_ELEMENTS_FOR_BUCKETS:32},Qn={DEFAULT_WRAPPED_BUFFER_SIZE:512,FRAME_SIZE_SAFETY_MARGIN:200};function Bt(n){return n instanceof yt}function We(n){return n instanceof Uint8Array&&!Bt(n)}var jt=97,ut=32,zn=16;function Z(n){if(n===0)return new Uint8Array([0]);const t=[];for(;n!==0;)t.push(n&127),n>>>=7;t.reverse();for(let e=0;e<t.length-1;e++)t[e]|=128;return new Uint8Array(t)}function Gt(n){if(!Bt(n)&&!We(n))throw new Error("Invalid buffer type: expected Uint8Array or WrappedBuffer");let t=0;for(;;){if(n.length===0)throw new Error("VarInt decoding: unexpected end of buffer");const e=So(n);if(t=t<<7|e&127,(e&128)===0)break}return t}function Io(n){return Yt(n,1)[0]}function Yt(n,t){if(!Bt(n)&&!We(n))throw new Error("Invalid buffer type: expected Uint8Array or WrappedBuffer");if(n.length<t)throw new Error("getBytes: unexpected end of buffer");return Bt(n)?n.shiftN(t):n.slice(0,t)}function So(n){if(!Bt(n)&&!We(n))throw new Error("Invalid buffer type: expected Uint8Array or WrappedBuffer");return Bt(n)?n.shift():n[0]}function jn(n,t){const e=Math.min(n.length,t.length);for(let r=0;r<e;r++){if(n[r]<t[r])return-1;if(n[r]>t[r])return 1}return n.length<t.length?-1:n.length>t.length?1:0}function Gn(n){if(n.startsWith("0x")&&(n=n.slice(2)),n.length%2!==0)throw new Error("Hex string has odd length");const t=new Uint8Array(n.length/2);for(let e=0;e<t.length;e++)t[e]=Number.parseInt(n.slice(e*2,e*2+2),16);return t}var Vn=new Array(256);{const n=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];for(let t=0;t<256;t++)Vn[t]=n[t>>>4&15]+n[t&15]}function Vt(n){let t="";for(let e=0;e<n.length;e++)t+=Vn[n[e]];return t}var yt=class Jn{constructor(t){typeof t=="number"?(this._raw=new Uint8Array(t),this.length=0):t?(this._raw=new Uint8Array(t),this.length=t.length):(this._raw=new Uint8Array(Qn.DEFAULT_WRAPPED_BUFFER_SIZE),this.length=0)}unwrap(){return this._raw.subarray(0,this.length)}get capacity(){return this._raw.byteLength}append(t){const e=t instanceof Jn?t.unwrap():t,r=e.length+this.length;if(this.capacity<r){const o=this._raw,a=Math.max(this.capacity*2,r);this._raw=new Uint8Array(a),this._raw.set(o)}this._raw.set(e,this.length),this.length+=e.length}set(t){const e=t instanceof Uint8Array?t:new Uint8Array(t);this.capacity<e.length&&(this._raw=new Uint8Array(Math.max(this.capacity*2,e.length))),this._raw.set(e),this.length=e.length}shift(){if(this.length===0)throw new Error("Cannot shift from empty buffer");const t=this._raw[0];return this._raw=this._raw.subarray(1),this.length--,t}shiftN(t){if(this.length<t)throw new Error("Cannot shift more bytes than available");const e=this._raw.subarray(0,t);return this._raw=this._raw.subarray(t),this.length-=t,e}clear(){this.length=0}},_o=class{constructor(){this.buf=new Uint8Array(ut),this.setToZero()}setToZero(){this.buf=new Uint8Array(ut)}add(n){let t=0,e=0;const r=new DataView(this.buf.buffer),o=new DataView(n.buffer);for(let a=0;a<8;a++){const u=a*4,h=r.getUint32(u,!0),f=o.getUint32(u,!0);let p=h;p+=t,p+=f,p>4294967295&&(e=1),r.setUint32(u,p&4294967295,!0),t=e,e=0}}negate(){const n=new DataView(this.buf.buffer);for(let e=0;e<8;e++){const r=e*4;n.setUint32(r,~n.getUint32(r,!0),!0)}const t=new Uint8Array(ut);t[0]=1,this.add(t)}async getFingerprint(n){const t=new Uint8Array(this.buf.length+Z(n).length);return t.set(this.buf),t.set(Z(n),this.buf.length),(await this.sha256(t)).subarray(0,zn)}async sha256(n){if(crypto?.subtle){const t=await crypto.subtle.digest("SHA-256",n.buffer);return new Uint8Array(t)}try{const t=await Cr(()=>import("./BIHI7g3E.js"),[],import.meta.url);return new Uint8Array(t.createHash("sha256").update(n).digest())}catch{throw new Error("No SHA256 implementation available")}}};function ge(n,t){return n.timestamp!==t.timestamp?n.timestamp-t.timestamp:jn(n.id,t.id)}var Bo=class Yn{constructor(){this.items=[],this.sealed=!1}static fromEvents(t){const e=new Yn;for(const r of t)e.insert(r.created_at||0,r.id);return e.seal(),e}insert(t,e){if(this.sealed)throw new Error("Storage is sealed, cannot insert");const r=typeof e=="string"?Gn(e):e;if(r.length!==ut)throw new Error(`Invalid ID size: expected ${ut}, got ${r.length}`);this.items.push({timestamp:t,id:r})}seal(){if(this.sealed)throw new Error("Storage is already sealed");this.sealed=!0,this.items.sort(ge);for(let t=1;t<this.items.length;t++)if(ge(this.items[t-1],this.items[t])===0)throw new Error("Duplicate item in storage")}unseal(){this.sealed=!1}size(){return this.checkSealed(),this.items.length}getItem(t){if(this.checkSealed(),t>=this.items.length)throw new Error("Index out of range");return this.items[t]}iterate(t,e,r){this.checkSealed(),this.checkBounds(t,e);for(let o=t;o<e&&r(this.items[o],o);o++);}findLowerBound(t,e,r){return this.checkSealed(),this.checkBounds(t,e),this.binarySearch(this.items,t,e,o=>ge(o,r)<0)}async fingerprint(t,e){const r=new _o;return r.setToZero(),this.iterate(t,e,o=>(r.add(o.id),!0)),await r.getFingerprint(e-t)}checkSealed(){if(!this.sealed)throw new Error("Storage is not sealed")}checkBounds(t,e){if(t>e||e>this.items.length)throw new Error("Invalid range")}binarySearch(t,e,r,o){let a=r-e;for(;a>0;){let u=e;const h=Math.floor(a/2);u+=h,o(t[u])?(e=++u,a-=h+1):a=h}return e}},To=class{constructor(n,t=0){if(this.lastTimestampIn=0,this.lastTimestampOut=0,this.isInitiator=!1,t!==0&&t<Te.MINIMUM)throw new Error(`frameSizeLimit too small (minimum ${Te.MINIMUM} bytes)`);this.storage=n,this.frameSizeLimit=t}bound(n,t){return{timestamp:n,id:t||new Uint8Array(0)}}async initiate(){if(this.isInitiator)throw new Error("Already initiated");this.isInitiator=!0;const n=new yt;return n.set([jt]),await this.splitRange(0,this.storage.size(),this.bound(Number.MAX_VALUE),n),n.unwrap()}setInitiator(){this.isInitiator=!0}async reconcile(n){const t=[],e=[],r=new yt(n);this.lastTimestampIn=this.lastTimestampOut=0;const o=new yt;o.set([jt]);const a=this.validateProtocolVersion(r);if(!a.isValid)return{nextMessage:a.output.unwrap(),have:t,need:e};const u=this.storage.size();let h=this.bound(0),f=0,p=!1;for(;r.length!==0;){const l=new yt,k=()=>{p&&(p=!1,l.append(this.encodeBound(h)),l.append(Z(0)))},g=this.decodeBound(r),w=r.length===0?0:Gt(r),b=f,E=this.storage.findLowerBound(f,u,g),I=await this.processByMode(w,b,E,g,r,l,o,k,t,e);if(I.shouldSkip&&(p=!0),this.exceededFrameSizeLimit(o.length+l.length)){const S=await this.storage.fingerprint(E,u);o.append(this.encodeBound(this.bound(Number.MAX_VALUE))),o.append(Z(1)),o.append(S);break}I.outputAlreadyAppended||o.append(l.unwrap()),f=E,h=g}return{nextMessage:o.length===1&&this.isInitiator?void 0:o.unwrap(),have:t,need:e}}validateProtocolVersion(n){const t=new yt;t.set([jt]);const e=Io(n);if(e<96||e>111)throw new Error("Invalid negentropy protocol version byte");if(e!==jt){if(this.isInitiator)throw new Error(`Unsupported negentropy protocol version requested: ${e-96}`);return{isValid:!1,output:t}}return{isValid:!0,output:t}}async processByMode(n,t,e,r,o,a,u,h,f,p){if(n===0)return this.handleModeSkip();if(n===1)return await this.handleModeFingerprint(t,e,r,o,a,h);if(n===2)return await this.handleModeIdList(t,e,r,o,a,u,h,f,p);throw new Error("Unexpected mode")}handleModeSkip(){return{shouldSkip:!0,outputAlreadyAppended:!1}}async handleModeFingerprint(n,t,e,r,o,a){const u=Yt(r,zn),h=await this.storage.fingerprint(n,t);return jn(u,h)!==0?(a(),await this.splitRange(n,t,e,o),{shouldSkip:!1,outputAlreadyAppended:!1}):{shouldSkip:!0,outputAlreadyAppended:!1}}async handleModeIdList(n,t,e,r,o,a,u,h,f){const p=Gt(r),l=new Map;for(let k=0;k<p;k++){const g=Yt(r,ut),w=Array.from(g).join(",");l.set(w,g)}return this.isInitiator?this.handleIdListAsInitiator(n,t,l,h,f):await this.handleIdListAsResponder(n,t,e,o,a,u)}handleIdListAsInitiator(n,t,e,r,o){this.storage.iterate(n,t,a=>{const u=Array.from(a.id).join(",");return e.has(u)?e.delete(u):r.push(a.id),!0});for(const a of e.values())o.push(a);return{shouldSkip:!0,outputAlreadyAppended:!1}}async handleIdListAsResponder(n,t,e,r,o,a){a();const u=new yt;let h=0,f=e;return this.storage.iterate(n,t,(p,l)=>this.exceededFrameSizeLimit(o.length+u.length)?(f=p,!1):(u.append(p.id),h++,!0)),r.append(this.encodeBound(f)),r.append(Z(2)),r.append(Z(h)),r.append(u.unwrap()),o.append(r.unwrap()),r.clear(),{shouldSkip:!1,outputAlreadyAppended:!0}}async splitRange(n,t,e,r){const o=t-n,a=gn.BUCKET_COUNT;if(o<gn.MIN_ELEMENTS_FOR_BUCKETS)r.append(this.encodeBound(e)),r.append(Z(2)),r.append(Z(o)),this.storage.iterate(n,t,u=>(r.append(u.id),!0));else{const u=Math.floor(o/a),h=o%a;let f=n;for(let p=0;p<a;p++){const l=u+(p<h?1:0),k=await this.storage.fingerprint(f,f+l);f+=l;let g;if(f===t)g=e;else{let w,b;if(this.storage.iterate(f-1,f+1,(E,I)=>(I===f-1?w=E:b=E,!0)),!w||!b)throw new Error(`Failed to get items at index ${f-1} and ${f} for bound calculation`);g=this.getMinimalBound(w,b)}r.append(this.encodeBound(g)),r.append(Z(1)),r.append(k)}}}exceededFrameSizeLimit(n){return this.frameSizeLimit>0&&n>this.frameSizeLimit-Qn.FRAME_SIZE_SAFETY_MARGIN}decodeTimestampIn(n){let t=Gt(n);return t=t===0?Number.MAX_VALUE:t-1,this.lastTimestampIn===Number.MAX_VALUE||t===Number.MAX_VALUE?(this.lastTimestampIn=Number.MAX_VALUE,Number.MAX_VALUE):(t+=this.lastTimestampIn,this.lastTimestampIn=t,t)}decodeBound(n){const t=this.decodeTimestampIn(n),e=Gt(n);if(e>ut)throw new Error("Bound key too long");const r=new Uint8Array(ut),o=Yt(n,Math.min(e,n.length));return r.set(o),{timestamp:t,id:r}}encodeTimestampOut(n){if(n===Number.MAX_VALUE)return this.lastTimestampOut=Number.MAX_VALUE,Z(0);const t=n;return n-=this.lastTimestampOut,this.lastTimestampOut=t,Z(n+1)}encodeBound(n){const t=this.encodeTimestampOut(n.timestamp),e=Z(n.id.length),r=new Uint8Array(t.length+e.length+n.id.length);return r.set(t),r.set(e,t.length),r.set(n.id,t.length+e.length),r}getMinimalBound(n,t){if(t.timestamp!==n.timestamp)return this.bound(t.timestamp);let e=0;for(let r=0;r<ut&&t.id[r]===n.id[r];r++)e++;return this.bound(t.timestamp,t.id.subarray(0,e+1))}};function Zn(n){return Array.isArray(n)&&n.length>=2&&typeof n[0]=="string"&&typeof n[1]=="string"}function mn(n){return Zn(n)&&n.length===3&&typeof n[2]=="string"}function Mo(n){return"connectivity"in n&&n.connectivity&&typeof n.connectivity.send=="function"}var Po=class extends ee.EventEmitter{constructor(n,t,e,r){super(),this.need=new Set,this.have=new Set,this.active=!1,this.relay=n,this.filters=t,this.sessionId=this.generateSessionId(),this.opts=r,this.negentropy=new To(e,r.frameSizeLimit||Te.DEFAULT),this.setupRelayMonitoring()}async start(){if(this.active)throw new Error("Sync session already active");this.active=!0,this.relay.registerProtocolHandler("NEG-MSG",this.handleNegMsg.bind(this)),this.relay.registerProtocolHandler("NEG-ERR",this.handleNegErr.bind(this)),this.relay.registerProtocolHandler("NEG-CLOSE",this.handleNegClose.bind(this)),this.relay.on("notice",this.handleNotice.bind(this));try{const n=await this.negentropy.initiate(),t=JSON.stringify(["NEG-OPEN",this.sessionId,this.filters,Vt(n)]);return await this.sendRaw(t),await new Promise((e,r)=>{this.once("complete",e),this.once("error",r),setTimeout(()=>{this.active&&(this.cleanup(),r(new Error("Sync session timeout")))},this.opts.timeout||Lt.SYNC_SESSION)})}catch(n){throw this.cleanup(),n}}async handleNegMsg(n,t){try{if(!mn(t))throw new Error("Invalid NEG-MSG format: expected [string, string, string]");const[,e,r]=t;if(e!==this.sessionId)return;const o=Gn(r),a=await this.negentropy.reconcile(o);for(const u of a.need)this.need.add(Vt(u));for(const u of a.have)this.have.add(Vt(u));if(a.nextMessage){const u=JSON.stringify(["NEG-MSG",this.sessionId,Vt(a.nextMessage)]);await this.sendRaw(u)}else{const u=JSON.stringify(["NEG-CLOSE",this.sessionId]);await this.sendRaw(u),this.complete()}}catch(e){this.error(e instanceof Error?e:new Error(String(e)))}}handleNegErr(n,t){if(!mn(t)){this.error(new Error("Invalid NEG-ERR format: expected [string, string, string]"));return}const[,e,r]=t;e===this.sessionId&&this.error(new Error(`Relay sync error: ${r}`))}handleNegClose(n,t){if(!Zn(t)){this.error(new Error("Invalid NEG-CLOSE format: expected [string, string]"));return}const[,e]=t;e===this.sessionId&&this.complete()}handleNotice(n){if(typeof n!="string")return;const t=n.toLowerCase();(t.includes("negentropy")||t.includes("bad msg")||t.includes("bad message")||t.includes("unknown")&&t.includes("msg")||t.includes("unsupported")&&t.includes("protocol"))&&this.error(new Error(`Relay does not support negentropy: ${n}`))}complete(){this.active&&(this.cleanup(),this.emit("complete",{need:this.need,have:this.have}))}error(n){this.active&&(this.cleanup(),this.emit("error",n))}cleanup(){this.active=!1,this.relay.unregisterProtocolHandler("NEG-MSG"),this.relay.unregisterProtocolHandler("NEG-ERR"),this.relay.unregisterProtocolHandler("NEG-CLOSE"),this.relay.off("notice",this.handleNotice),this.relay.off("disconnect",this.handleRelayDisconnect)}setupRelayMonitoring(){this.relay.once("disconnect",this.handleRelayDisconnect.bind(this))}handleRelayDisconnect(){this.active&&this.error(new Error("Relay disconnected during sync session"))}async sendRaw(n){const t=this.relay.url;if(!this.relay.connected)throw new Error(`Relay ${t} is not connected`);if(!Mo(this.relay))throw new Error(`Relay ${t} does not support direct message sending`);try{await this.relay.connectivity.send(n)}catch(e){throw new Error(`Failed to send message to relay ${t}: ${e instanceof Error?e.message:String(e)}`)}}generateSessionId(){return`neg-${Math.random().toString(36).substring(2,15)}`}};async function Co(n,t={}){if(!this.cacheAdapter)throw new Error("NDK sync requires a cache adapter. Configure NDK with cacheAdapter option.");const e=Array.isArray(n)?n:[n],r=Uo.call(this,t),o=Array.from(r.relays),a={events:[],need:new Set,have:new Set},u=o.map(async h=>{if(h.connected||await new Promise(f=>{const p=()=>{h.off("ready",p),f()};h.once("ready",p),setTimeout(()=>{h.off("ready",p),f()},Lt.RELAY_CONNECTION)}),!h.connected){console.warn(`[NDK Sync] Relay ${h.url} did not connect in time, skipping`);return}try{await No.call(this,h,e,t,a)}catch(f){const p=f instanceof Error?f.message:String(f);console.error(`[NDK Sync] Failed to sync with relay ${h.url}: ${p}`),t.onRelayError&&await t.onRelayError(h,f instanceof Error?f:new Error(String(f)))}});return await Promise.all(u),a}function Uo(n){if(n.relaySet)return n.relaySet;if(n.relayUrls)return it.fromRelayUrls(n.relayUrls,this);const t=this.pool?.relays;if(!t||t.size===0)throw new Error("No relays available for sync");const e=new Set(t.values());return new it(e,this)}async function No(n,t,e,r){try{const o=await xo.call(this,t),a=Bo.fromEvents(o),u=new Po(n,t,a,e),{need:h,have:f}=await u.start();for(const p of h)r.need.add(p);for(const p of f)r.have.add(p);if(e.autoFetch!==!1&&h.size>0){const p=await Do.call(this,n,h);r.events.push(...p),this.cacheAdapter&&await Ro.call(this,p,t,n)}}catch(o){const a=o instanceof Error?o.message:String(o);throw new Error(`Sync failed with relay ${n.url}: ${a}`)}}async function Ro(n,t,e){if(this.cacheAdapter)for(const r of n)await this.cacheAdapter.setEvent(r,t,e)}async function xo(n){if(!this.cacheAdapter)return[];const t=[];return new Promise(e=>{const r=this.subscribe(n,{cacheUsage:ve.ONLY_CACHE,closeOnEose:!0,onEvent:o=>{t.push(o)},onEose:()=>{e(t)}});setTimeout(()=>{r.stop(),e(t)},Lt.CACHE_QUERY)})}async function Do(n,t){const e=[],r=new it(new Set([n]),this);return new Promise(o=>{const a=this.subscribe({ids:Array.from(t)},{closeOnEose:!0,relaySet:r,exclusiveRelay:!0,groupable:!1,onEvent:u=>{e.push(u)},onEose:()=>{o(e)}});setTimeout(()=>{a.stop(),o(e)},Lt.EVENT_FETCH)})}async function $o(n){try{return(typeof n=="string"?await Ir(n):await n.fetchInfo()).supported_nips?.includes(77)??!1}catch{return!1}}var Lo=class Me{constructor(t){this.CAPABILITY_CACHE_TTL=36e5,this.ndk=t}async checkRelaySupport(t){const r=(await this.ndk.cacheAdapter?.getRelayStatus?.(t.url))?.metadata?.sync,o=Date.now();if(r?.lastChecked&&o-r.lastChecked<this.CAPABILITY_CACHE_TTL)return r.supportsNegentropy??!1;try{const a=await $o(t);return await this.ndk.cacheAdapter?.updateRelayStatus?.(t.url,{metadata:{sync:{supportsNegentropy:a,lastChecked:o}}}),a}catch(a){return await this.ndk.cacheAdapter?.updateRelayStatus?.(t.url,{metadata:{sync:{supportsNegentropy:!1,lastChecked:o,lastError:a instanceof Error?a.message:"Unknown error"}}}),!1}}async getNegentropyRelays(t){const e=t||Array.from(this.ndk.pool?.relays?.values()||[]);return(await Promise.all(e.map(async o=>({relay:o,supports:await this.checkRelaySupport(o)})))).filter(o=>o.supports).map(o=>o.relay)}async getRelayCapability(t){return(await this.ndk.cacheAdapter?.getRelayStatus?.(t))?.metadata?.sync}async clearCapabilityCache(t){t?await this.ndk.cacheAdapter?.updateRelayStatus?.(t,{metadata:{sync:void 0}}):console.warn("clearCapabilityCache() without relayUrl is not supported with persistent cache")}async markRelayAsNotSupporting(t,e){await this.ndk.cacheAdapter?.updateRelayStatus?.(t,{metadata:{sync:{supportsNegentropy:!1,lastChecked:Date.now(),lastError:e.message}}})}createErrorHandler(t){return async(e,r)=>{await t?.(e,r),await this.markRelayAsNotSupporting(e.url,r)}}async syncSingleRelay(t,e,r={}){if(await this.checkRelaySupport(t))return await Co.call(this.ndk,e,{...r,relaySet:new it(new Set([t]),this.ndk)});const a=await this.ndk.guardrailOff("fetch-events-usage").fetchEvents(e,{relaySet:new it(new Set([t]),this.ndk),subId:"sync-fetch-fallback",groupable:!1});return{events:Array.from(a),need:new Set,have:new Set}}async sync(t,e){const r=Array.isArray(t)?t:[t],o=e?.relaySet||(e?.relayUrls?it.fromRelayUrls(e.relayUrls,this.ndk):void 0),a=o?Array.from(o.relays):Array.from(this.ndk.pool?.relays?.values()||[]);if(a.length===0)return console.warn("[NDK Sync] No relays available for sync"),{events:[],need:new Set,have:new Set};const u={events:[],need:new Set,have:new Set},h={...e,onRelayError:this.createErrorHandler(e?.onRelayError)};return await Promise.all(a.map(async f=>{try{const p=await this.syncSingleRelay(f,r,h);u.events.push(...p.events);for(const l of p.need)u.need.add(l);for(const l of p.have)u.have.add(l)}catch(p){console.error(`[NDK Sync] Failed to sync with relay ${f.url}:`,p)}})),u}async syncAndSubscribe(t,e={}){this.ndk.cacheAdapter||console.warn("[NDKSync] No cache adapter - sync will not work, using subscription only");const r=Array.isArray(t)?t:[t],o=e.relaySet||(e.relayUrls?it.fromRelayUrls(e.relayUrls,this.ndk):void 0),a=o?Array.from(o.relays):Array.from(this.ndk.pool?.relays?.values()||[]);if(a.length===0)throw new Error("No relays available for syncAndSubscribe");const u=r.map(f=>({...f,limit:0})),h=this.ndk.subscribe(u,{...e,relaySet:o,closeOnEose:!1});if(this.ndk.cacheAdapter){let f=0;const p=a.length,l=async k=>{try{const g=await this.syncSingleRelay(k,r,{autoFetch:!0,onRelayError:this.createErrorHandler(e.onRelayError)});e.onRelaySynced?.(k,g.events.length)}catch(g){console.error(`[NDKSync] Failed to sync from ${k.url}:`,g)}finally{f++,f===p&&e.onSyncComplete?.()}};for(const k of a)if(k.connected)l(k);else{let g=!1;const w=()=>{g||(g=!0,k.off("ready",w),l(k))};k.once("ready",w),setTimeout(()=>{g||(g=!0,k.off("ready",w),f++,f===p&&e.onSyncComplete?.())},Lt.RELAY_CONNECTION)}}else setTimeout(()=>e.onSyncComplete?.(),0);return h}static sync(t,e,r){return new Me(t).sync(e,r)}static syncAndSubscribe(t,e,r){return new Me(t).syncAndSubscribe(e,r)}};async function Ko(n,t){if(t.cacheAdapter?.getCacheData)try{const e=await t.cacheAdapter.getCacheData("wallet:mint:info",n);if(e)return{isOnline:!0,info:e}}catch(e){console.error("Error reading mint info from cache:",e)}try{const e=await fetch(`${n}/v1/info`);if(e.ok){const r=await e.json();if(t.cacheAdapter?.setCacheData)try{await t.cacheAdapter.setCacheData("wallet:mint:info",n,r)}catch(o){console.error("Error caching mint info:",o)}return{isOnline:!0,info:r}}return{isOnline:!1}}catch{return{isOnline:!1}}}function _i(n,t={}){const{network:e="mainnet",timeout:r=1e4,followUsers:o}=t;let a,u,h;const f=new Map,p=qr()((k,g)=>({mints:[],progress:{announcementsFound:0,recommendationsFound:0},getMint:w=>f.get(w),getTopMints:(w=10,b=0)=>{let E=g().mints;return b>0&&(E=E.filter(I=>I.recommendations.length>=b)),E.sort((I,S)=>S.score-I.score).slice(0,w)},searchMints:w=>{const b=w.toLowerCase();return g().mints.filter(E=>E.url.toLowerCase().includes(b)||E.name?.toLowerCase().includes(b)||E.description?.toLowerCase().includes(b))},recommendMint:async(w,b)=>{const E=new rn(n);E.recommendedKind=R.CashuMintAnnouncement,E.urls=[w],E.review=b,await E.sign(),await E.publish()},stop:()=>{a?.stop(),u?.stop(),h&&clearTimeout(h)}}));a=n.subscribe({kinds:[R.CashuMintAnnouncement],limit:100},{closeOnEose:!1});const l={kinds:[R.EcashMintRecommendation],"#k":[R.CashuMintAnnouncement.toString()],limit:500};return o&&o.length>0&&(l.authors=o),u=n.subscribe(l,{closeOnEose:!1}),a.on("event",async k=>{const g=await Pr.from(k);if(!g||e&&g.network!==e)return;const w=g.url;if(!w)return;const b=f.get(w),E={url:w,identifier:g.identifier,network:g.network,nuts:g.nuts||[],name:g.metadata?.name,description:g.metadata?.description,icon:g.metadata?.icon,longDescription:g.metadata?.longDescription,contact:g.metadata?.contact,motd:g.metadata?.motd,recommendations:b?.recommendations||[],score:b?.score||0,lastUpdated:Date.now()};f.set(w,E),p.setState(I=>({mints:Array.from(f.values()),progress:{...I.progress,announcementsFound:I.progress.announcementsFound+1}})),Ko(w,n).then(({isOnline:I,info:S})=>{const B=f.get(w);B&&(f.set(w,{...B,isOnline:I,name:S?.name||B.name,description:S?.description||B.description,icon:S?.icon||B.icon,longDescription:S?.longDescription||B.longDescription,contact:S?.contact||B.contact,motd:S?.motd||B.motd,lastUpdated:Date.now()}),p.setState({mints:Array.from(f.values())}))})}),u.on("event",async k=>{const g=await rn.from(k);if(!g)return;const w=g.urls;for(const b of w){const E=f.get(b);E?(E.recommendations.push(g),E.score=E.recommendations.length,f.set(b,{...E})):f.set(b,{url:b,nuts:[],recommendations:[g],score:1,lastUpdated:Date.now()}),p.setState(I=>({mints:Array.from(f.values()),progress:{...I.progress,recommendationsFound:I.progress.recommendationsFound+1}}))}}),r>0&&(h=setTimeout(()=>{p.getState().stop()},r)),p}var me=new Map,Ut=new Map;function Oo(n,t,e){if(e){const r=new TextDecoder().decode(e);return`${n}-${t}-${r}`}return`${n}-${t}`}async function He(n,{pk:t,timeout:e=5e3,mintInfo:r,mintKeys:o,onMintInfoNeeded:a,onMintInfoLoaded:u,onMintKeysNeeded:h,onMintKeysLoaded:f}={}){const p=Date.now(),l=()=>`+${Date.now()-p}ms`;if(a){console.log(`[MINT-CACHE ${l()}] Querying cache for mint info: ${n}`);const E=Date.now();r??=await a(n);const I=Date.now()-E;r?console.log(`[MINT-CACHE ${l()}]  Cache HIT for mint info: ${n} (${I}ms)`,{name:r.name}):console.log(`[MINT-CACHE ${l()}]  Cache MISS for mint info: ${n} (${I}ms)`)}if(h){console.log(`[MINT-CACHE ${l()}] Querying cache for mint keys: ${n}`);const E=Date.now();o??=await h(n);const I=Date.now()-E;o?console.log(`[MINT-CACHE ${l()}]  Cache HIT for mint keys: ${n} (${I}ms)`,{count:o.length}):console.log(`[MINT-CACHE ${l()}]  Cache MISS for mint keys: ${n} (${I}ms)`)}if(!r&&u){console.log(`[MINT-CACHE ${l()}] Fetching mint info from ${n}/v1/info`);const E=Date.now();r=await L.getInfo(n);const I=Date.now()-E;console.log(`[MINT-CACHE ${l()}] Caching mint info: ${n} (fetched in ${I}ms)`,{name:r.name}),u?.(n,r)}const k="sat",g=Oo(n,k,t);if(me.has(g))return console.log(`[MINT-CACHE ${l()}] Returning cached wallet instance: ${n}`),me.get(g);if(Ut.has(g))return console.log(`[MINT-CACHE ${l()}] Wallet loading in progress, returning existing promise: ${n}`),Ut.get(g);if(!r){if(a){console.log(`[MINT-CACHE ${l()}] Querying cache for mint info (second check): ${n}`);const E=Date.now();r=await a(n);const I=Date.now()-E;r?console.log(`[MINT-CACHE ${l()}]  Cache HIT for mint info (second check): ${n} (${I}ms)`,{name:r.name}):console.log(`[MINT-CACHE ${l()}]  Cache MISS for mint info (second check): ${n} (${I}ms)`)}if(!r&&u){console.log(`[MINT-CACHE ${l()}] Fetching mint info from ${n}/v1/info (second check)`);const E=Date.now();r=await L.getInfo(n);const I=Date.now()-E;console.log(`[MINT-CACHE ${l()}] Caching mint info (second check): ${n} (fetched in ${I}ms)`,{name:r.name}),u(n,r)}}if(!o&&h){console.log(`[MINT-CACHE ${l()}] Querying cache for mint keys (second check): ${n}`);const E=Date.now();o=await h(n);const I=Date.now()-E;o?console.log(`[MINT-CACHE ${l()}]  Cache HIT for mint keys (second check): ${n} (${I}ms)`,{count:o.length}):console.log(`[MINT-CACHE ${l()}]  Cache MISS for mint keys (second check): ${n} (${I}ms)`)}const w=new Ao(new L(n),{unit:k,bip39seed:t,mintInfo:r,keys:o}),b=new Promise(async E=>{try{console.log(`[MINT-CACHE ${l()}] Loading mint wallet: ${n}`);const I=Date.now(),S=new Promise((T,A)=>{setTimeout(()=>{A(new Error("timeout loading mint"))},e)});await Promise.race([w.loadMint(),S]);const B=Date.now()-I;console.log(`[MINT-CACHE ${l()}] Mint wallet loaded: ${n} (${B}ms)`),me.set(g,w),Ut.delete(g),w.keys&&(console.log(`[MINT-CACHE ${l()}] Caching mint keys after loadMint: ${n}`,{count:w.keys.size}),f?.(n,w.keys)),E(w)}catch(I){console.error(`[WALLET ${l()}] error loading mint`,n,I.message),Ut.delete(g),E(null)}});return Ut.set(g,b),b}function qo(n){return{onMintInfoNeeded:async t=>{if(n.getCacheData)return n.getCacheData("wallet:mint:info",t)},onMintInfoLoaded:async(t,e)=>{n.setCacheData&&await n.setCacheData("wallet:mint:info",t,e)},onMintKeysNeeded:async t=>{if(n.getCacheData)return n.getCacheData("wallet:mint:keys",t)},onMintKeysLoaded:async(t,e)=>{if(!n.setCacheData)return;const r=Array.from(e.values());await n.setCacheData("wallet:mint:keys",t,r)}}}async function Fo(n){if(this.cashuWallets.has(n))return this.cashuWallets.get(n);const t=await He(n,{onMintInfoNeeded:this.onMintInfoNeeded,onMintInfoLoaded:this.onMintInfoLoaded,onMintKeysNeeded:this.onMintKeysNeeded,onMintKeysLoaded:this.onMintKeysLoaded});if(!t)throw new Error(`unable to load wallet for mint ${n}`);return this.cashuWallets.set(n,t),t}var Wo=(n=>(n.INITIAL="initial",n.LOADING="loading",n.READY="ready",n.FAILED="failed",n))(Wo||{}),Ho=class extends ee.EventEmitter{cashuWallets=new Map;onMintInfoNeeded;onMintInfoLoaded;onMintKeysNeeded;onMintKeysLoaded;getCashuWallet=Fo.bind(this);ndk;constructor(n){super(),this.ndk=n}status="initial";get type(){throw new Error("Not implemented")}walletId="unknown";get balance(){throw new Error("Not implemented")}redeemNutzaps(n,t,e){throw new Error("Not implemented")}};function Qo(n){const t=xe.decode(n),e=t.expiry,r=t.sections.find(o=>o.name==="timestamp").value;if(typeof e=="number"&&typeof r=="number")return e+r}function re(n){const r=xe.decode(n).sections.find(o=>o.name==="amount")?.value;return Number(r)}function zo(n){return xe.decode(n).sections.find(o=>o.name==="description")?.value}var Xn=class tr extends It{quoteId;mint;amount;unit;_wallet;static kind=R.CashuQuote;constructor(t,e){super(t,e),this.kind??=R.CashuQuote}static async from(t){const e=new tr(t.ndk,t),r=t;try{await e.decrypt()}catch{e.content=r.content}try{const o=JSON.parse(e.content);e.quoteId=o.quoteId,e.mint=o.mint,e.amount=o.amount,e.unit=o.unit}catch{return}return e}set wallet(t){this._wallet=t}set invoice(t){const e=Qo(t);e&&this.tags.push(["expiration",e.toString()])}async save(){if(!this.ndk)throw new Error("NDK is required");this.content=JSON.stringify({quoteId:this.quoteId,mint:this.mint,amount:this.amount,unit:this.unit}),await this.encrypt(this.ndk.activeUser,void 0,"nip44"),await this.sign(),await this.publish(this._wallet?.relaySet)}};async function Pe(n,t,e,r,{nutzaps:o}={}){let a=t.paymentDescription,u;t.pr?(u=re(t.pr),a??=zo(t.pr),u&&(u/=1e3)):u=t.amount,u||console.error("BUG: Unable to find amount for paymentRequest",t);const h=new An(n);if(h.direction="out",h.amount=u??0,h.mint=e.mint,h.description=a,e.fee&&(h.fee=e.fee),t.target&&(h.tags.push(t.target.tagReference()),t.target instanceof Br||h.tags.push(["p",t.target.pubkey])),o){h.description??="nutzap redeem";for(const f of o)h.addRedeemedNutzap(f)}return e.stateUpdate?.created&&(h.createdTokens=[e.stateUpdate.created]),e.stateUpdate?.deleted&&(h.destroyedTokenIds=e.stateUpdate.deleted),e.stateUpdate?.reserved&&(h.reservedTokens=[e.stateUpdate.reserved]),await h.sign(),h.publish(r),h}async function Ce(n,t,e,r,{nutzaps:o,fee:a,description:u},h){const f=new An(n),p=Tr(t);if(f.direction="in",f.amount=p,f.mint=e,f.description=u,r.created&&(f.createdTokens=[r.created]),r.deleted&&(f.destroyedTokenIds=r.deleted),r.reserved&&(f.reservedTokens=[r.reserved]),o)for(const l of o)f.addRedeemedNutzap(l);return a&&(f.fee=a),await f.sign(),f.publish(h),f}var pt=Re("ndk-wallet:cashu:deposit");function jo(n){const t=n.mints;return t[Math.floor(Math.random()*t.length)]}var er=class nr extends ee.EventEmitter{mint;amount;quoteId;wallet;checkTimeout;checkIntervalLength=2500;finalized=!1;quoteEvent;constructor(t,e,r){super(),this.wallet=t,this.mint=r||jo(t),this.amount=e}static fromQuoteEvent(t,e){if(!e.amount)throw new Error("quote has no amount");if(!e.mint)throw new Error("quote has no mint");const r=new nr(t,e.amount,e.mint);return r.quoteId=e.quoteId,r}async start(t=2500){const r=await(await this.wallet.getCashuWallet(this.mint)).createMintQuote(this.amount);return pt("created quote %s for %d %s",r.quote,this.amount,this.mint),this.quoteId=r.quote,this.wallet.depositMonitor.addDeposit(this),setTimeout(this.check.bind(this,t),t),this.createQuoteEvent(r.quote,r.request).then(o=>this.quoteEvent=o),r.request}async createQuoteEvent(t,e){const{ndk:r}=this.wallet,o=new Xn(r);o.quoteId=t,o.mint=this.mint,o.amount=this.amount,o.wallet=this.wallet,o.invoice=e;try{await o.save(),pt("saved quote on event %s",o.rawEvent())}catch(a){pt("error saving quote on event %s",a.relayErrors)}return o}async runCheck(){this.finalized||await this.finalize(),this.finalized||this.delayCheck()}delayCheck(){setTimeout(()=>{this.runCheck(),this.checkIntervalLength+=500},this.checkIntervalLength)}async check(t){this.runCheck(),t&&setTimeout(()=>{clearTimeout(this.checkTimeout)},t)}async finalize(){if(!this.quoteId)throw new Error("No quoteId set.");let t;try{pt("Checking for minting status of %s",this.quoteId);const e=await this.wallet.getCashuWallet(this.mint),r=await this.wallet.state.getProofs({mint:this.mint});if(t=await e.mintProofs(this.amount,this.quoteId,{proofsWeHave:r}),t.length===0)return}catch(e){if(e.message.match(/not paid/i))return;if(e.message.match(/already issued/i)){pt("Mint is saying the quote has already been issued, destroying quote event: %s",e.message),this.destroyQuoteEvent(),this.finalized=!0;return}if(e.message.match(/rate limit/i)){pt("Mint seems to be rate limiting, lowering check interval"),this.checkIntervalLength+=5e3;return}pt(e.message);return}try{this.finalized=!0;const e=await this.wallet.state.update({store:t,mint:this.mint},"Deposit"),r=e.created;if(!r)throw new Error("no token event created");Ce(this.wallet.ndk,t,this.mint,e,{description:"Deposit"},this.wallet.relaySet),this.emit("success",r),this.destroyQuoteEvent()}catch(e){this.emit("error",e.message),console.error(e)}}async destroyQuoteEvent(){if(!this.quoteEvent)return;(await this.quoteEvent.delete(void 0,!1)).publish(this.wallet.relaySet)}},Go=class extends ee.EventEmitter{deposits=new Map;addDeposit(n){const{quoteId:t}=n;if(!t)throw new Error("deposit has no quote ID");return this.deposits.has(t)?!1:(n.once("success",e=>{this.removeDeposit(t)}),this.deposits.set(t,n),this.emit("change"),!0)}removeDeposit(n){this.deposits.delete(n),this.emit("change")}};async function Vo(n){const t=n.getMatchingTags("e").map(e=>e[1]);for(const e of t)this.state.removeTokenId(e)}async function Jo(n){const t=await Xn.from(n);if(!t)return;const e=Date.now()/1e3-3600;if(n.created_at&&n.created_at<e)return;const r=er.fromQuoteEvent(this,t);this.depositMonitor.addDeposit(r)&&r.finalize()}async function Yo(n){if(this.state.tokens.has(n.id))return;const t=await En.from(n);if(t){for(const e of t.deletedTokens)this.state.removeTokenId(e);this.state.addToken(t)}}setInterval(()=>{},5e3);var Zo={[R.CashuToken]:Yo,[R.CashuQuote]:Jo,[R.EventDeletion]:Vo},ke=null;async function Jt(n){const t=Zo[n.kind];t&&(ke&&clearTimeout(ke),await t.call(this,n),ke=setTimeout(()=>{this.emit("balance_updated")},100))}async function kn(n,t,e,r,o){}var bn=Re("ndk-wallet:cashu:validate");async function Xo(){bn("checking %d tokens for spent proofs",this.state.tokens.size);const n=new Set(this.state.getMintsProofs({validStates:new Set(["available","reserved","deleted"])}).keys());bn("found %d mints",n.size),n.forEach(t=>{rr(t,this)})}async function rr(n,t,e,r,o){e??=t.state.getProofs({mint:n,includeDeleted:!0,onlyAvailable:!1});const a=await He(n);if(!a)return;let u=[];try{u=await a.checkProofsStates(e)}catch{return}const h=[],f=[],p=[];e.forEach((g,w)=>{const{state:b}=u[w];b===yn.SPENT?h.push(g):b===yn.UNSPENT?f.push(g):p.push(g)});const l={mint:n,store:f,destroy:h};if(h.reduce((g,w)=>g+w.amount,0),l.destroy?.length===0)return;l.store?.push(...p);const k=p.reduce((g,w)=>g+w.amount,0);return t.state.reserveProofs(p,k),t.state.update(l,"Consolidate")}function sr(n,t,e){const r=t.reduce((u,h)=>u+h.amount,0),o=e.reduce((u,h)=>u+h.amount,0),a=r-n-o;if(a<0)throw new Error("Invalid fee calculation: received more proofs than sent to mint");return a}async function or(n,t,e,r,o,a){t??=await n.getCashuWallet(e);const u=n.state.getProofs({mint:e,onlyAvailable:!0}),h=t.selectProofsToSend(u,r);if(h.send.reduce((g,w)=>g+w.amount,0)<r)return null;n.state.reserveProofs(h.send,r);let p=null,l=null,k=null;try{if(p=await a(h.send,u),!p)return null;l={mint:e,store:p.change,destroy:h.send},k=await n.state.update(l)}catch(g){throw n.state.unreserveProofs(h.send,r,"available"),g}return p?{result:p.result,proofsChange:l,stateUpdate:k,mint:e,fee:sr(o,h.send,p.change)}:null}async function ir(n,t,{amount:e,unit:r}={}){let o=re(t);if(!o)throw new Error("invoice amount is required");o=o/1e3,e&&r&&r==="msat"&&(e=e/1e3);const a=n.getMintsWithBalance(o+3);if(!a.length)return null;for(const u of a)try{const h=await ti(u,t,e??o,n);if(h)return e&&(h.fee=sr(e,h.proofsChange?.destroy??[],h.proofsChange?.store??[])),h}catch(h){n.warn(`Failed to execute payment with min ${u}: ${h}`)}return null}async function ti(n,t,e,r){const o=await r.getCashuWallet(n);try{const a=await o.createMeltQuote(t),u=a.amount+a.fee_reserve;return await or(r,o,n,u,e,async(f,p)=>{const l=await o.meltProofs(a,f);return l.quote.state===_t.PAID?{result:{preimage:l.quote.payment_preimage??""},change:l.change}:null})}catch(a){if(a instanceof Error)if(a.message.match(/already spent/i))setTimeout(()=>{rr(n,r)},2500);else throw a;return null}}function ar(n){if(!n)return;let t=n;if(t.length===64&&(t=`02${t}`),t.length!==66)throw new Error("Invalid pubkey");return t}async function ei(n,t,e,r,o){const a=(u,h,f)=>{const p=ar(o);n.mintProofs(e,t.quote,{pubkey:p}).then(l=>{console.debug("minted tokens",l),u({proofs:l,mint:r})}).catch(l=>{f++,f<=3?(console.error("error minting tokens",l),setTimeout(()=>a(u,h,f),f*1500)):h(l)})};return new Promise((u,h)=>{a(u,h,0)})}async function vn(n,t,e,r){console.log("[createToken] Starting token creation",{amount:t,recipientMints:e,p2pk:r}),r=ar(r);const o=n.getMintsWithBalance(t);console.log("[createToken] My mints with enough balance",o);const a=e&&e.length>0,u=a?si([e,o]):o;console.log("[createToken] Mints in common",{hasRecipientMints:a,mintsInCommon:u});for(const h of u){console.log("[createToken] Attempting to create token in mint",h);try{const f=await ni(n,h,t,r);if(f)return console.log("[createToken] Successfully created token in mint",h),f;console.log("[createToken] Failed to create token in mint",h)}catch(f){console.error("[createToken] Error creating token in mint",h,f)}}return a?(console.log("[createToken] Attempting cross-mint transfer"),await ri(n,t,e,r)):(console.error("[createToken] All token creation attempts failed"),null)}async function ni(n,t,e,r){console.log("[createTokenInMint] Starting",{mint:t,amount:e,p2pk:r});const o=await n.getCashuWallet(t);console.log("[createTokenInMint] Got cashu wallet for mint",t);try{const a=await or(n,o,t,e,e,async(u,h)=>{console.log("[createTokenInMint] Inside withProofReserve callback",{proofsToUseCount:u.length,allOurProofsCount:h.length});const f=await o.send(e,u,{pubkey:r,proofsWeHave:h});return console.log("[createTokenInMint] Send result",{sendCount:f.send.length,keepCount:f.keep.length}),{result:{proofs:f.send,mint:t},change:f.keep,mint:t}});return console.log("[createTokenInMint] Success",a),a}catch(a){console.error("[createTokenInMint] Error",{mint:t,error:a.message,stack:a.stack})}return null}async function ri(n,t,e,r){const o=async()=>{const w=async B=>{const T=await He(B);if(!T)throw new Error(`unable to load wallet for mint ${B}`);return{quote:await T.createMintQuote(t),mint:B,targetMintWallet:T}},b=e.map(w),{quote:E,mint:I,targetMintWallet:S}=await Promise.any(b);if(!E)throw new Error("failed to get quote from any mint");return{quote:E,mint:I,targetMintWallet:S}},{quote:a,mint:u,targetMintWallet:h}=await o();if(!a)return null;const f=re(a.request);if(!f)throw new Error("invoice amount is required");const p=f/1e3;if(p>t)throw new Error(`invoice amount is more than the amount passed in (${p} vs ${t})`);const l=await ir(n,a.request,{amount:t});if(!l)return null;const{proofs:k,mint:g}=await ei(h,a,t,u,r);return{...l,result:{proofs:k,mint:g},fee:l.fee}}function si(n){const t=new Map;for(const r of n)for(const o of r){const a=Mr(o);t.has(a)?t.set(a,t.get(a)+1):t.set(a,1)}const e=[];for(const[r,o]of t.entries())o===n.length&&e.push(r);return e}var oi=class{wallet;constructor(n){this.wallet=n}async lnPay(n,t=!0){if(!n.pr)throw new Error("pr is required");const e=re(n.pr);if(!e)throw new Error("invoice amount is required");if(n.amount&&e>n.amount)throw new Error("invoice amount is more than the amount passed in");const r=await ir(this.wallet,n.pr,{amount:n.amount,unit:n.unit});if(r?.result?.preimage)return t&&Pe(this.wallet.ndk,n,r,this.wallet.relaySet),r.result}async cashuPay(n){console.log("[PaymentHandler.cashuPay] Starting cashu payment",{originalAmount:n.amount,unit:n.unit,mints:n.mints,p2pk:n.p2pk,allowIntramintFallback:n.allowIntramintFallback});const t={...n};t.unit?.startsWith("msat")&&(t.amount=t.amount/1e3,t.unit="sat",console.log("[PaymentHandler.cashuPay] Converted msat to sat",{newAmount:t.amount,newUnit:t.unit})),console.log("[PaymentHandler.cashuPay] Creating token with mints",n.mints);let e=await vn(this.wallet,t.amount,n.mints,n.p2pk);if(!e?.result&&(console.log("[PaymentHandler.cashuPay] Token creation failed with specified mints"),n.allowIntramintFallback&&(console.log("[PaymentHandler.cashuPay] Attempting intramint fallback"),e=await vn(this.wallet,t.amount,void 0,n.p2pk)),!e?.result)){console.error("[PaymentHandler.cashuPay] Token creation failed completely");return}return console.log("[PaymentHandler.cashuPay] Token created successfully",{proofsCount:e.result.proofs.length,mint:e.result.mint}),Pe(this.wallet.ndk,t,e,this.wallet.relaySet),e.result}};function ii(n){return this.getProofEntries(n).reduce((e,r)=>e+r.proof.amount,0)}function ai({onlyAvailable:n}={onlyAvailable:!0}){const t={},e=this.getProofEntries({onlyAvailable:n});for(const r of e)r.mint&&(t[r.mint]??=0,t[r.mint]+=r.proof.amount);return t}function ci(n){this.proofs.set(n.proof.C,n),this.journal.push({memo:"Added proof",timestamp:Date.now(),metadata:{type:"proof",id:n.proof.C,amount:n.proof.amount,mint:n.mint}})}function ui(n,t){for(const e of n)this.updateProof(e,{state:"reserved"});this.reserveAmounts.push(t)}function hi(n,t,e){for(const o of n)this.updateProof(o,{state:e});const r=this.reserveAmounts.indexOf(t);if(r!==-1)this.reserveAmounts.splice(r,1);else throw new Error(`BUG: Amount ${t} not found in reserveAmounts`)}function li(n={}){const t=new Map,e=new Set(["available"]);let{mint:r,onlyAvailable:o,includeDeleted:a}=n;o??=!0,o||e.add("reserved"),a&&e.add("deleted");for(const u of this.proofs.values())r&&u.mint!==r||e.has(u.state)&&u.proof&&t.set(u.proof.C,u);return Array.from(t.values())}function fi(n,t){const e=n.C,r=this.proofs.get(e);if(!r)throw new Error("Proof not found");const o={...r,...t};this.proofs.set(e,o),this.journal.push({memo:`Updated proof state: ${JSON.stringify(t)}`,timestamp:Date.now(),metadata:{type:"proof",id:e,amount:n.amount,mint:r.mint}})}function di(n){if(!n.mint)throw new Error("BUG: Token has no mint");const e=this.tokens.get(n.id)?.state??"available";this.tokens.set(n.id,{token:n,state:e});for(const r of n.proofs)pi(this,r,n,e)}function pi(n,t,e,r){const o=t.C,a=n.proofs.get(o);if(!a)return n.addProof({mint:e.mint,state:r,tokenId:e.id,timestamp:e.created_at,proof:t}),!0;if(a.tokenId){if(a.tokenId===e.id)return null;const u=n.tokens.get(a.tokenId);if(!u)throw new Error(`BUG: Token id ${a.tokenId} not found, was expected to be associated with proof ${o}`);const h=u.token;return h&&h.created_at&&(!e.created_at||e.created_at<h.created_at)?!1:(n.updateProof(t,{tokenId:e.id,state:r}),!0)}return n.updateProof(t,{tokenId:e.id,state:r}),!0}function yi(n){const t=this.tokens.get(n)||{};this.tokens.set(n,{...t,state:"deleted"});for(const e of this.proofs.values()){const{proof:r}=e;if(e.tokenId===n){if(!r)throw new Error("BUG: Proof entry has no proof");this.updateProof(r,{state:"deleted"})}}}async function wi(n,t){return gi(this,n),this.wallet.emit("balance_updated"),mi(this,n)}function gi(n,t){if(t.store&&t.store.length>0)for(const e of t.store)n.addProof({mint:t.mint,state:"available",proof:e,timestamp:Date.now()});if(t.destroy&&t.destroy.length>0)for(const e of t.destroy)n.updateProof(e,{state:"deleted"});if(t.reserve&&t.reserve.length>0)throw new Error("BUG: Proofs should not be reserved via update")}async function mi(n,t){const e=bi(n,t);if(e.deletedTokenIds.size>0){const o=new It(n.wallet.ndk,{kind:R.EventDeletion,tags:[["k",R.CashuToken.toString()],...Array.from(e.deletedTokenIds).map(a=>["e",a])]});await o.sign(),Qe(n,o,n.wallet.relaySet);for(const a of e.deletedTokenIds)n.removeTokenId(a)}const r={};if(e.saveProofs.length>0){const o=await ki(n,t.mint,e);r.created=o}return r}async function Qe(n,t,e,r=10*1e3){let o;o=await t.publish(e);let a;t.kind===R.EventDeletion&&(a="deletion"),t.kind===R.CashuToken&&(a="token"),t.kind===R.CashuWallet&&(a="wallet");const u={type:a,id:t.id,relayUrl:e?.relayUrls.join(",")};if(o)return n.journal.push({memo:`Publish kind:${t.kind} succeesfully`,timestamp:Date.now(),metadata:u}),o;n.journal.push({memo:"Publish failed",timestamp:Date.now(),metadata:u}),setTimeout(()=>{Qe(n,t,e,r)},r)}async function ki(n,t,e){const r=new En(n.wallet.ndk);return r.mint=t,r.proofs=e.saveProofs,await r.toNostrEvent(),n.addToken(r),r.deletedTokens=Array.from(e.deletedTokenIds),await r.sign(),n.addToken(r),Qe(n,r,n.wallet.relaySet),r}function bi(n,t){const e=new Set;for(const a of t.destroy||[])e.add(a.C);const r=new Map;let o;for(const a of t.store||[])r.set(a.C,a);o=vi(n,t);for(const a of o.values())for(const u of a.proofs)e.has(u.C)||r.set(u.C,u);return{deletedTokenIds:new Set(o.keys()),deletedProofs:e,reserveProofs:[],saveProofs:Array.from(r.values())}}function vi(n,t){const e=new Map;for(const r of t.destroy||[]){const o=n.proofs.get(r.C);if(!o)continue;const a=o.tokenId;if(!a)continue;const u=n.tokens.get(a);u?.token&&e.set(a,u.token)}return e}var Ei=class{constructor(n,t=new Set){this.wallet=n,this.reservedProofCs=t}reserveAmounts=[];proofs=new Map;tokens=new Map;journal=[];dump(){return{proofs:Array.from(this.proofs.values()),balances:this.getMintsBalance(),totalBalance:this.getBalance(),tokens:Array.from(this.tokens.values())}}addToken=di.bind(this);removeTokenId=yi.bind(this);addProof=ci.bind(this);reserveProofs=ui.bind(this);unreserveProofs=hi.bind(this);getProofEntries=li.bind(this);updateProof=fi.bind(this);getProofs(n){return this.getProofEntries(n).map(t=>t.proof)}getTokens(n={onlyAvailable:!0}){const t=this.getProofEntries(n),e=new Map;for(const r of t){const o=r.tokenId??null,a=e.get(o)??{tokenId:o,mint:r.mint,proofEntries:[]};a.token??=o?this.tokens.get(o)?.token:void 0,a.proofEntries.push(r),e.set(o,a)}return e}getMintsProofs({validStates:n=new Set(["available"])}={}){const t=new Map;for(const e of this.proofs.values()){if(!e.mint||!e.proof||!n.has(e.state))continue;const r=t.get(e.mint)||[];r.push(e.proof),t.set(e.mint,r)}return t}getBalance=ii.bind(this);getMintsBalance=ai.bind(this);update=wi.bind(this)};(class Ue extends Ho{get type(){return"nip-60"}_p2pk;sub;status="initial";static kind=R.CashuWallet;static kinds=[R.CashuWallet];mints=[];privkeys=new Map;signer;walletId="nip-60";depositMonitor=new Go;warnings=[];paymentHandler;state;relaySet;_walletRelays=[];constructor(t){if(super(t),this.ndk=t,this.paymentHandler=new oi(this),this.state=new Ei(this),t.cacheAdapter?.getCacheData&&t.cacheAdapter?.setCacheData){const e=qo(t.cacheAdapter);this.onMintInfoNeeded=e.onMintInfoNeeded,this.onMintInfoLoaded=e.onMintInfoLoaded,this.onMintKeysNeeded=e.onMintKeysNeeded,this.onMintKeysLoaded=e.onMintKeysLoaded}}async backup(t=!0){if(this.privkeys.size===0)throw new Error("no privkey to backup");const e=new Ai(this.ndk),r=[];for(const[o,a]of this.privkeys.entries())r.push(a.privateKey);return e.privkeys=r,e.mints=this.mints,t&&e.save(this.relaySet),e}consolidateTokens=Xo.bind(this);async mintNuts(t){let e;const r=t.reduce((o,a)=>o+a,0);for(const o of this.mints){const a=await this.getCashuWallet(o),u=await this.state.getProofs({mint:o});if(e=await a.send(r,u,{proofsWeHave:u,includeFees:!0,outputAmounts:{sendAmounts:t}}),e.send.length>0){const h={store:e?.keep??[],destroy:e.send,mint:o},f=await this.state.update(h);return Pe(this.ndk,{paymentDescription:"minted nuts",amount:t.reduce((p,l)=>p+l,0)},{result:{proofs:e.send},stateUpdate:f,mint:o,fee:0},this.relaySet),this.emit("balance_updated"),e}}}async send(t,e){if(this.mints.length===0)throw new Error("No mints configured");const r=await this.mintNuts([t]);if(!r)throw new Error("Failed to create token");return no({mint:this.mints[0],proofs:r.send,memo:e})}async loadFromEvent(t){const e=new It(t.ndk,t.rawEvent());await e.decrypt();const r=JSON.parse(e.content);for(const o of r)o[0]==="mint"?this.mints.push(o[1]):o[0]==="privkey"?await this.addPrivkey(o[1]):o[0]==="relay"&&this._walletRelays.push(o[1]);await this.getP2pk()}static async from(t){if(!t.ndk)throw new Error("no ndk instance on event");const e=new Ue(t.ndk);return await e.loadFromEvent(t),e}static async create(t,e,r){const o=new Ue(t),a=ae.generate();return await o.addPrivkey(a.privateKey),o.mints=e,r&&r.length>0&&(o.relaySet=it.fromRelayUrls(r,t)),await o.publish(),await o.backup(!0),o}async fetchWalletRelays(t){if(this._walletRelays.length>0)return it.fromRelayUrls(this._walletRelays,this.ndk);const e=await this.ndk.fetchEvent({kinds:[R.RelayList],authors:[t]},{cacheUsage:ve.PARALLEL});if(e)return Sr.from(e).relaySet}async start(t){const e=this.ndk?.activeUser;if(this.status==="ready")return Promise.resolve();this.setStatus("loading");const r=t?.pubkey??e?.pubkey;if(!r)throw new Error("no pubkey");this.relaySet||(this.relaySet=await this.fetchWalletRelays(r));const o=[{kinds:[R.CashuToken],authors:[r]},{kinds:[R.CashuQuote],authors:[r]},{kinds:[R.EventDeletion],authors:[r],"#k":[R.CashuToken.toString()]}];if(t?.since&&(o[0].since=t.since,o[1].since=t.since,o[2].since=t.since),this.ndk.cacheAdapter){const a=[],u=await this.ndk.fetchEvents([{kinds:[R.CashuToken],authors:[r]}],{cacheUsage:ve.ONLY_CACHE});a.push(...u);for(const h of a)Jt.call(this,h);this.emit("balance_updated")}if(this.ndk.cacheAdapter)try{const a=await Lo.sync(this.ndk,o,{relaySet:this.relaySet,autoFetch:!0});for(const f of a.events)Jt.call(this,f);const u=t??{};u.subId??="cashu-wallet-state";const h=o.map(f=>({...f,since:Math.floor(Date.now()/1e3)-60}));this.sub=this.ndk.subscribe(h,{...u,relaySet:this.relaySet,closeOnEose:!1,onEvent:f=>{Jt.call(this,f)},onEventDup:kn.bind(this)}),this.emit("ready"),this.setStatus("ready")}catch(a){console.error("[NDKCashuWallet] Sync failed, falling back to subscription:",a),await this.startWithSubscription(o,t)}else await this.startWithSubscription(o,t)}async startWithSubscription(t,e){const r=e??{};return r.subId??="cashu-wallet-state",new Promise(o=>{this.sub=this.ndk.subscribe(t,{...r,relaySet:this.relaySet,onEvent:a=>{Jt.call(this,a)},onEose:async()=>{this.emit("ready"),this.setStatus("ready"),o()},onEventDup:kn.bind(this)})})}stop(){this.sub?.stop(),this.setStatus("initial")}setStatus(t){this.status!==t&&(this.status=t,this.emit("status_changed",t))}async getP2pk(){if(this._p2pk)return this._p2pk;if(this.privkeys.size===0){const t=ae.generate();await this.addPrivkey(t.privateKey)}return this.p2pk}get p2pks(){return Array.from(this.privkeys.keys())}async addPrivkey(t){const e=new ae(t),r=await e.user();return this.privkeys.set(r.pubkey,e),this._p2pk??=r.pubkey,this._p2pk}get p2pk(){if(!this._p2pk)throw new Error("p2pk not set");return this._p2pk}set p2pk(t){if(this.privkeys.has(t))this.signer=this.privkeys.get(t),this.p2pk=t;else throw new Error(`privkey for ${t} not found`)}walletPayload(){const t=Array.from(this.privkeys.values()).map(r=>r.privateKey),e=ur(t,this.mints);return this._walletRelays.length>0&&e.push(...this._walletRelays.map(r=>["relay",r])),e}async publish(){this.relaySet&&(this._walletRelays=Array.from(this.relaySet.relays).map(r=>r.url));const t=new It(this.ndk,{content:JSON.stringify(this.walletPayload()),kind:R.CashuWallet}),e=await this.ndk?.signer?.user();return await t.encrypt(e,void 0,"nip44"),t.publish(this.relaySet)}async publishMintList(){const t=new _r(this.ndk);return t.mints=this.mints,this.relaySet&&(t.relays=Array.from(this.relaySet.relays).map(e=>e.url)),t.p2pk=this.p2pk,t.publishReplaceable(this.relaySet)}async update(t){this.mints=t.mints,t.relays&&t.relays.length>0?(this.relaySet=it.fromRelayUrls(t.relays,this.ndk),this._walletRelays=t.relays):(this.relaySet=void 0,this._walletRelays=[]);const e=new It(this.ndk,{content:JSON.stringify(this.walletPayload()),kind:R.CashuWallet}),r=await this.ndk?.signer?.user();return await e.encrypt(r,void 0,"nip44"),e.publishReplaceable(this.relaySet)}deposit(t,e){const r=new er(this,t,e);return r.on("success",o=>{this.state.addToken(o)}),r}async receiveToken(t,e){const{mint:r}=Wn(t),a=await(await this.getCashuWallet(r)).receive(t),u=await this.state.update({store:a,mint:r}),h=u.created;return Ce(this.ndk,a,r,u,{description:e},this.relaySet),h}async lnPay(t,e=!0){return this.paymentHandler.lnPay(t,e)}async cashuPay(t){return this.paymentHandler.cashuPay(t)}wallets=new Map;async redeemNutzaps(t,e,{mint:r,proofs:o,cashuWallet:a}){if(a)r??=a.mint.mintUrl;else{if(!r)throw new Error("mint not set");a=await this.getCashuWallet(r)}if(!r)throw new Error("mint not set");if(!o)throw new Error("proofs not set");try{const u=this.state.getProofs({mint:r}),h=await a.receive({proofs:o,mint:r},{proofsWeHave:u,privkey:e}),f=o.reduce((g,w)=>g+w.amount,0),p=h.reduce((g,w)=>g+w.amount,0),l=f-p,k=await this.state.update({store:h,mint:r});return Ce(this.ndk,h,r,k,{nutzaps:t,fee:l},this.relaySet),f}catch(u){throw console.error("error redeeming nutzaps",t.map(h=>h.encode()),u),u}}warn(t,e,r){r??=e?.onRelays,this.warnings.push({msg:t,event:e,relays:r}),this.emit("warning",{msg:t,event:e,relays:r})}get balance(){return{amount:this.state.getBalance({onlyAvailable:!0})}}mintBalance(t){return this.mintBalances[t]||0}get mintBalances(){return this.state.getMintsBalance({onlyAvailable:!0})}getMintsWithBalance(t){const e=this.state.getMintsBalance({onlyAvailable:!0});return Object.entries(e).filter(([r,o])=>o>=t).map(([r])=>r)}async getMintInfo(t){return await(await this.getCashuWallet(t)).mint.getInfo()}});var Ai=class cr extends It{privkeys=[];mints=[];constructor(t,e){super(t,e),this.kind??=R.CashuWalletBackup}static async from(t){if(!t.ndk)throw new Error("no ndk instance on event");const e=new cr(t.ndk,t);try{await e.decrypt();const r=JSON.parse(e.content);for(const o of r)o[0]==="mint"?e.mints.push(o[1]):o[0]==="privkey"&&e.privkeys.push(o[1])}catch(r){console.error("error decrypting backup event",e.encode(),r);return}return e}async save(t){if(!this.ndk)throw new Error("no ndk instance");if(!this.privkeys.length)throw new Error("no privkeys");return this.content=JSON.stringify(ur(this.privkeys,this.mints)),await this.encrypt(this.ndk.activeUser,void 0,"nip44"),this.publish(t)}};function ur(n,t){if(n.length===0)throw new Error("privkey not set");return[...t.map(r=>["mint",r]),...n.map(r=>["privkey",r])]}Re("ndk-wallet:nwc");export{Wo as N,_i as c};
