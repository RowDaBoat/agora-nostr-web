import{_ as __vitePreload}from"./CSbKtK4P.js";import{u as NDKEvent,v as NDKPrivateKeySigner,w as NDKRelaySet,x as NDKKind,y as NDKSubscriptionCacheUsage,z as NDKRelayList,B as NDKCashuMintList,C as NDKCashuWalletTx,D as NDKUser,E as proofsTotalBalance,F as NDKCashuToken,G as fetchRelayInformation,H as normalizeUrl,I as NdkNutzapStatus,J as NDKNutzap,K as proofP2pk,L as cashuPubkeyToNostrPubkey}from"./D0X4VYcq.js";var __create=Object.create,__defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty,__defNormalProp=(t,n,r)=>n in t?__defProp(t,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[n]=r,__require=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(n,r)=>(typeof require<"u"?require:n)[r]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')}),__commonJS=(t,n)=>function(){return n||(0,t[__getOwnPropNames(t)[0]])((n={exports:{}}).exports,n),n.exports},__copyProps=(t,n,r,s)=>{if(n&&typeof n=="object"||typeof n=="function")for(let o of __getOwnPropNames(n))!__hasOwnProp.call(t,o)&&o!==r&&__defProp(t,o,{get:()=>n[o],enumerable:!(s=__getOwnPropDesc(n,o))||s.enumerable});return t},__toESM=(t,n,r)=>(r=t!=null?__create(__getProtoOf(t)):{},__copyProps(__defProp(r,"default",{value:t,enumerable:!0}),t)),__publicField=(t,n,r)=>__defNormalProp(t,typeof n!="symbol"?n+"":n,r),define_process_env_default={},require_types=__commonJS({"../node_modules/tseep/lib/types.js"(t){Object.defineProperty(t,"__esModule",{value:!0})}}),require_utils=__commonJS({"../node_modules/tseep/lib/task-collection/utils.js"(t){Object.defineProperty(t,"__esModule",{value:!0}),t._fast_remove_single=void 0;function n(r,s){s!==-1&&(s===0?r.shift():s===r.length-1?r.length=r.length-1:r.splice(s,1))}t._fast_remove_single=n}}),require_bake_collection=__commonJS({"../node_modules/tseep/lib/task-collection/bake-collection.js"(exports,module){Object.defineProperty(exports,"__esModule",{value:!0}),exports.bakeCollectionVariadic=exports.bakeCollectionAwait=exports.bakeCollection=exports.BAKED_EMPTY_FUNC=void 0,exports.BAKED_EMPTY_FUNC=(function(){});var FORLOOP_FALLBACK=1500;function generateArgsDefCode(t){var n="";if(t===0)return n;for(var r=0;r<t-1;++r)n+="arg"+String(r)+", ";return n+="arg"+String(t-1),n}function generateBodyPartsCode(t,n){for(var r="",s="",o=0;o<n;++o)r+="var f".concat(o," = collection[").concat(o,`];
`),s+="f".concat(o,"(").concat(t,`)
`);return{funcDefCode:r,funcCallCode:s}}function generateBodyPartsVariadicCode(t){for(var n="",r="",s=0;s<t;++s)n+="var f".concat(s," = collection[").concat(s,`];
`),r+="f".concat(s,`.apply(undefined, arguments)
`);return{funcDefCode:n,funcCallCode:r}}function bakeCollection(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                `).concat(funcCallCode,`
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);collection.length%10===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 10) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                        collection[i+4](`).concat(argsDefCode,`);
                        collection[i+5](`).concat(argsDefCode,`);
                        collection[i+6](`).concat(argsDefCode,`);
                        collection[i+7](`).concat(argsDefCode,`);
                        collection[i+8](`).concat(argsDefCode,`);
                        collection[i+9](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%4===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 4) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%3===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 3) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                    }
                });
            })`):funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; ++i) {
                        collection[i](`).concat(argsDefCode,`);
                    }
                });
            })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollection=bakeCollection;function bakeCollectionAwait(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                return Promise.all([ `).concat(funcCallCode,` ]);
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);funcFactoryCode=`(function(collection) {
            return (function(`.concat(argsDefCode,`) {
                var promises = Array(collection.length);
                for (var i = 0; i < collection.length; ++i) {
                    promises[i] = collection[i](`).concat(argsDefCode,`);
                }
                return Promise.all(promises);
            });
        })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionAwait=bakeCollectionAwait;function bakeCollectionVariadic(collection){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var _a=generateBodyPartsVariadicCode(collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function() {
                `).concat(funcCallCode,`
            });
        })`)}else funcFactoryCode=`(function(collection) {
            return (function() {
                for (var i = 0; i < collection.length; ++i) {
                    collection[i].apply(undefined, arguments);
                }
            });
        })`;{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionVariadic=bakeCollectionVariadic}}),require_task_collection=__commonJS({"../node_modules/tseep/lib/task-collection/task-collection.js"(t){var n=t&&t.__spreadArray||function(He,Ge,ee){if(ee||arguments.length===2)for(var oe=0,Ue=Ge.length,Ce;oe<Ue;oe++)(Ce||!(oe in Ge))&&(Ce||(Ce=Array.prototype.slice.call(Ge,0,oe)),Ce[oe]=Ge[oe]);return He.concat(Ce||Array.prototype.slice.call(Ge))};Object.defineProperty(t,"__esModule",{value:!0}),t.TaskCollection=void 0;var r=require_utils(),s=require_bake_collection();function o(He,Ge){var ee=this.length;if(ee>1)if(Ge){var oe;(oe=this._tasks).push.apply(oe,arguments),this.length+=arguments.length}else this._tasks.push(He),this.length++;else if(Ge){if(ee===1){var Ue=Array(1+arguments.length);Ue.push(Ue),Ue.push.apply(Ue,arguments),this._tasks=Ue}else{var Ue=Array(arguments.length);Ue.push.apply(Ue,arguments),this._tasks=Ue}this.length+=arguments.length}else ee===1?this._tasks=[this._tasks,He]:this._tasks=He,this.length++}function a(He,Ge){var ee=this.length;if(ee>1)if(Ge){var oe;(oe=this._tasks).push.apply(oe,arguments),this.length+=arguments.length}else this._tasks.push(He),this.length++;else if(Ge){if(ee===1){var Ue=Array(1+arguments.length);Ue.push(Ue),Ue.push.apply(Ue,arguments),this._tasks=Ue}else{var Ue=Array(arguments.length);Ue.push.apply(Ue,arguments),this._tasks=Ue}this.length+=arguments.length}else ee===1?this._tasks=[this._tasks,He]:this._tasks=He,this.length++;this.firstEmitBuildStrategy?this.call=k:this.rebuild()}function f(He){this.length!==0&&(this.length===1?this._tasks===He&&(this.length=0):((0,r._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(He)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length))}function g(He){if(this.length!==0){if(this.length===1)if(this._tasks===He&&(this.length=0),this.firstEmitBuildStrategy){this.call=s.BAKED_EMPTY_FUNC;return}else{this.rebuild();return}else(0,r._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(He)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length;this.firstEmitBuildStrategy?this.call=k:this.rebuild()}}function _(He){for(var Ge,ee=[],oe=1;oe<arguments.length;oe++)ee[oe-1]=arguments[oe];this.length===0?(this._tasks=ee,this.length=1):this.length===1?(ee.unshift(this._tasks),this._tasks=ee,this.length=this._tasks.length):((Ge=this._tasks).splice.apply(Ge,n([He,0],ee,!1)),this.length=this._tasks.length)}function P(He){for(var Ge,ee=[],oe=1;oe<arguments.length;oe++)ee[oe-1]=arguments[oe];this.length===0?(this._tasks=ee,this.length=1):this.length===1?(ee.unshift(this._tasks),this._tasks=ee,this.length=this._tasks.length):((Ge=this._tasks).splice.apply(Ge,n([He,0],ee,!1)),this.length=this._tasks.length),this.firstEmitBuildStrategy?this.call=k:this.rebuild()}function b(){this.length===0?this.call=s.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,s.bakeCollection)(this._tasks,this.argsNum)}function q(){this.length===0?this.call=s.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,s.bakeCollectionAwait)(this._tasks,this.argsNum)}function k(){this.rebuild(),this.call.apply(void 0,arguments)}var B=(function(){function He(Ge,ee,oe,Ue){ee===void 0&&(ee=!0),oe===void 0&&(oe=null),Ue===void 0&&(Ue=!1),this.awaitTasks=Ue,this.call=s.BAKED_EMPTY_FUNC,this.argsNum=Ge,this.firstEmitBuildStrategy=!0,Ue?this.rebuild=q.bind(this):this.rebuild=b.bind(this),this.setAutoRebuild(ee),oe?typeof oe=="function"?(this._tasks=oe,this.length=1):(this._tasks=oe,this.length=oe.length):(this._tasks=null,this.length=0),ee&&this.rebuild()}return He})();t.TaskCollection=B;function Y(){this._tasks=null,this.length=0,this.call=s.BAKED_EMPTY_FUNC}function te(){this._tasks=null,this.length=0,this.call=s.BAKED_EMPTY_FUNC}function ve(He){this.argsNum<He&&(this.argsNum=He,this.firstEmitBuildStrategy?this.call=k:this.rebuild())}function je(He){He?(this.push=a.bind(this),this.insert=P.bind(this),this.removeLast=g.bind(this)):(this.push=o.bind(this),this.insert=_.bind(this),this.removeLast=f.bind(this))}function Ve(){return this.length===0?[]:this.length===1?[this._tasks]:this._tasks}function $e(He){He.length===0?(this.length=0,this.call=s.BAKED_EMPTY_FUNC):He.length===1?(this.length=1,this.call=He[0],this._tasks=He[0]):(this.length=He.length,this._tasks=He,this.firstEmitBuildStrategy?this.call=k:this.rebuild())}B.prototype.fastClear=Y,B.prototype.clear=te,B.prototype.growArgsNum=ve,B.prototype.setAutoRebuild=je,B.prototype.tasksAsArray=Ve,B.prototype.setTasks=$e}}),require_task_collection2=__commonJS({"../node_modules/tseep/lib/task-collection/index.js"(t){var n=t&&t.__createBinding||(Object.create?(function(s,o,a,f){f===void 0&&(f=a);var g=Object.getOwnPropertyDescriptor(o,a);(!g||("get"in g?!o.__esModule:g.writable||g.configurable))&&(g={enumerable:!0,get:function(){return o[a]}}),Object.defineProperty(s,f,g)}):(function(s,o,a,f){f===void 0&&(f=a),s[f]=o[a]})),r=t&&t.__exportStar||function(s,o){for(var a in s)a!=="default"&&!Object.prototype.hasOwnProperty.call(o,a)&&n(o,s,a)};Object.defineProperty(t,"__esModule",{value:!0}),r(require_task_collection(),t)}}),require_utils2=__commonJS({"../node_modules/tseep/lib/utils.js"(t){Object.defineProperty(t,"__esModule",{value:!0}),t.nullObj=void 0;function n(){var r={};return r.__proto__=null,r}t.nullObj=n}}),require_ee=__commonJS({"../node_modules/tseep/lib/ee.js"(t){var n=t&&t.__spreadArray||function(ee,oe,Ue){if(Ue||arguments.length===2)for(var Ce=0,Xe=oe.length,re;Ce<Xe;Ce++)(re||!(Ce in oe))&&(re||(re=Array.prototype.slice.call(oe,0,Ce)),re[Ce]=oe[Ce]);return ee.concat(re||Array.prototype.slice.call(oe))};Object.defineProperty(t,"__esModule",{value:!0}),t.EventEmitter=void 0;var r=require_task_collection2(),s=require_utils(),o=require_utils2();function a(ee,oe,Ue,Ce,Xe,re){var X=this.events[ee];if(X){if(X.length===0)return!1;if(X.argsNum<6)X.call(oe,Ue,Ce,Xe,re);else{for(var L=new Array(X.argsNum),Z=0,ne=L.length;Z<ne;++Z)L[Z]=arguments[Z+1];X.call.apply(void 0,L)}return!0}return!1}function f(ee,oe,Ue,Ce,Xe,re){var X=this.events[ee],L;if(X!==void 0){if(X.length===0)return!1;if(X.argsNum<6)X.call(oe,Ue,Ce,Xe,re);else{L=new Array(X.argsNum);for(var Z=0,ne=L.length;Z<ne;++Z)L[Z]=arguments[Z+1];X.call.apply(void 0,L)}}var Le=this.onceEvents[ee];if(Le){if(typeof Le=="function")if(this.onceEvents[ee]=void 0,arguments.length<6)Le(oe,Ue,Ce,Xe,re);else{if(L===void 0){L=new Array(arguments.length-1);for(var Z=0,ne=L.length;Z<ne;++Z)L[Z]=arguments[Z+1]}Le.apply(void 0,L)}else{var We=Le;if(this.onceEvents[ee]=void 0,arguments.length<6)for(var Z=0;Z<We.length;++Z)We[Z](oe,Ue,Ce,Xe,re);else{if(L===void 0){L=new Array(arguments.length-1);for(var Z=0,ne=L.length;Z<ne;++Z)L[Z]=arguments[Z+1]}for(var Z=0;Z<We.length;++Z)We[Z].apply(void 0,L)}}return!0}return X!==void 0}var g=(function(){function ee(){this.events=(0,o.nullObj)(),this.onceEvents=(0,o.nullObj)(),this._symbolKeys=new Set,this.maxListeners=1/0}return Object.defineProperty(ee.prototype,"_eventsCount",{get:function(){return this.eventNames().length},enumerable:!1,configurable:!0}),ee})();t.EventEmitter=g;function _(ee,oe){switch(this.emit===a&&(this.emit=f),typeof this.onceEvents[ee]){case"undefined":this.onceEvents[ee]=oe,typeof ee=="symbol"&&this._symbolKeys.add(ee);break;case"function":this.onceEvents[ee]=[this.onceEvents[ee],oe];break;case"object":this.onceEvents[ee].push(oe)}return this}function P(ee,oe,Ue){if(Ue===void 0&&(Ue=oe.length),typeof oe!="function")throw new TypeError("The listener must be a function");var Ce=this.events[ee];return Ce?(Ce.push(oe),Ce.growArgsNum(Ue),this.maxListeners!==1/0&&this.maxListeners<=Ce.length&&console.warn('Maximum event listeners for "'.concat(String(ee),'" event!'))):(this.events[ee]=new r.TaskCollection(Ue,!0,oe,!1),typeof ee=="symbol"&&this._symbolKeys.add(ee)),this}function b(ee,oe){var Ue=this.events[ee];Ue&&Ue.removeLast(oe);var Ce=this.onceEvents[ee];return Ce&&(typeof Ce=="function"?this.onceEvents[ee]=void 0:typeof Ce=="object"&&(Ce.length===1&&Ce[0]===oe?this.onceEvents[ee]=void 0:(0,s._fast_remove_single)(Ce,Ce.lastIndexOf(oe)))),this}function q(ee,oe,Ue,Ce){Ue===void 0&&(Ue=this),Ce===void 0&&(Ce=oe.length),this.boundFuncs||(this.boundFuncs=new Map);var Xe=oe.bind(Ue);return this.boundFuncs.set(oe,Xe),this.addListener(ee,Xe,Ce)}function k(ee,oe){var Ue,Ce,Xe=(Ue=this.boundFuncs)===null||Ue===void 0?void 0:Ue.get(oe);return(Ce=this.boundFuncs)===null||Ce===void 0||Ce.delete(oe),this.removeListener(ee,Xe)}function B(ee){return this.events[ee]&&!!this.events[ee].length}function Y(ee,oe,Ue){if(Ue===void 0&&(Ue=oe.length),typeof oe!="function")throw new TypeError("The listener must be a function");var Ce=this.events[ee];return!Ce||!(Ce instanceof r.TaskCollection)?(Ce=this.events[ee]=new r.TaskCollection(Ue,!0,oe,!1),typeof ee=="symbol"&&this._symbolKeys.add(ee)):(Ce.insert(0,oe),Ce.growArgsNum(Ue),this.maxListeners!==1/0&&this.maxListeners<=Ce.length&&console.warn('Maximum event listeners for "'.concat(String(ee),'" event!'))),this}function te(ee,oe){this.emit===a&&(this.emit=f);var Ue=this.onceEvents[ee];return Ue?typeof Ue!="object"?(this.onceEvents[ee]=[oe,Ue],typeof ee=="symbol"&&this._symbolKeys.add(ee)):(Ue.unshift(oe),this.maxListeners!==1/0&&this.maxListeners<=Ue.length&&console.warn('Maximum event listeners for "'.concat(String(ee),'" once event!'))):(this.onceEvents[ee]=[oe],typeof ee=="symbol"&&this._symbolKeys.add(ee)),this}function ve(ee){return ee===void 0?(this.events=(0,o.nullObj)(),this.onceEvents=(0,o.nullObj)(),this._symbolKeys=new Set):(this.events[ee]=void 0,this.onceEvents[ee]=void 0,typeof ee=="symbol"&&this._symbolKeys.delete(ee)),this}function je(ee){return this.maxListeners=ee,this}function Ve(){return this.maxListeners}function $e(ee){return this.emit===a?this.events[ee]?this.events[ee].tasksAsArray().slice():[]:this.events[ee]&&this.onceEvents[ee]?n(n([],this.events[ee].tasksAsArray(),!0),typeof this.onceEvents[ee]=="function"?[this.onceEvents[ee]]:this.onceEvents[ee],!0):this.events[ee]?this.events[ee].tasksAsArray():this.onceEvents[ee]?typeof this.onceEvents[ee]=="function"?[this.onceEvents[ee]]:this.onceEvents[ee]:[]}function He(){var ee=this;if(this.emit===a){var oe=Object.keys(this.events);return n(n([],oe,!0),Array.from(this._symbolKeys),!0).filter(function(Ce){return Ce in ee.events&&ee.events[Ce]&&ee.events[Ce].length})}else{var oe=Object.keys(this.events).filter(function(Xe){return ee.events[Xe]&&ee.events[Xe].length}),Ue=Object.keys(this.onceEvents).filter(function(Xe){return ee.onceEvents[Xe]&&ee.onceEvents[Xe].length});return n(n(n([],oe,!0),Ue,!0),Array.from(this._symbolKeys).filter(function(Xe){return Xe in ee.events&&ee.events[Xe]&&ee.events[Xe].length||Xe in ee.onceEvents&&ee.onceEvents[Xe]&&ee.onceEvents[Xe].length}),!0)}}function Ge(ee){return this.emit===a?this.events[ee]&&this.events[ee].length||0:(this.events[ee]&&this.events[ee].length||0)+(this.onceEvents[ee]&&this.onceEvents[ee].length||0)}g.prototype.emit=a,g.prototype.on=P,g.prototype.once=_,g.prototype.addListener=P,g.prototype.removeListener=b,g.prototype.addListenerBound=q,g.prototype.removeListenerBound=k,g.prototype.hasListeners=B,g.prototype.prependListener=Y,g.prototype.prependOnceListener=te,g.prototype.off=b,g.prototype.removeAllListeners=ve,g.prototype.setMaxListeners=je,g.prototype.getMaxListeners=Ve,g.prototype.listeners=$e,g.prototype.eventNames=He,g.prototype.listenerCount=Ge}}),require_lib=__commonJS({"../node_modules/tseep/lib/index.js"(t){var n=t&&t.__createBinding||(Object.create?(function(s,o,a,f){f===void 0&&(f=a);var g=Object.getOwnPropertyDescriptor(o,a);(!g||("get"in g?!o.__esModule:g.writable||g.configurable))&&(g={enumerable:!0,get:function(){return o[a]}}),Object.defineProperty(s,f,g)}):(function(s,o,a,f){f===void 0&&(f=a),s[f]=o[a]})),r=t&&t.__exportStar||function(s,o){for(var a in s)a!=="default"&&!Object.prototype.hasOwnProperty.call(o,a)&&n(o,s,a)};Object.defineProperty(t,"__esModule",{value:!0}),r(require_types(),t),r(require_ee(),t)}}),require_ms=__commonJS({"../node_modules/ms/index.js"(t,n){var r=1e3,s=r*60,o=s*60,a=o*24,f=a*7,g=a*365.25;n.exports=function(k,B){B=B||{};var Y=typeof k;if(Y==="string"&&k.length>0)return _(k);if(Y==="number"&&isFinite(k))return B.long?b(k):P(k);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(k))};function _(k){if(k=String(k),!(k.length>100)){var B=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(k);if(B){var Y=parseFloat(B[1]),te=(B[2]||"ms").toLowerCase();switch(te){case"years":case"year":case"yrs":case"yr":case"y":return Y*g;case"weeks":case"week":case"w":return Y*f;case"days":case"day":case"d":return Y*a;case"hours":case"hour":case"hrs":case"hr":case"h":return Y*o;case"minutes":case"minute":case"mins":case"min":case"m":return Y*s;case"seconds":case"second":case"secs":case"sec":case"s":return Y*r;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return Y;default:return}}}}function P(k){var B=Math.abs(k);return B>=a?Math.round(k/a)+"d":B>=o?Math.round(k/o)+"h":B>=s?Math.round(k/s)+"m":B>=r?Math.round(k/r)+"s":k+"ms"}function b(k){var B=Math.abs(k);return B>=a?q(k,B,a,"day"):B>=o?q(k,B,o,"hour"):B>=s?q(k,B,s,"minute"):B>=r?q(k,B,r,"second"):k+" ms"}function q(k,B,Y,te){var ve=B>=Y*1.5;return Math.round(k/Y)+" "+te+(ve?"s":"")}}}),require_common=__commonJS({"../node_modules/debug/src/common.js"(t,n){function r(s){a.debug=a,a.default=a,a.coerce=q,a.disable=P,a.enable=g,a.enabled=b,a.humanize=require_ms(),a.destroy=k,Object.keys(s).forEach(B=>{a[B]=s[B]}),a.names=[],a.skips=[],a.formatters={};function o(B){let Y=0;for(let te=0;te<B.length;te++)Y=(Y<<5)-Y+B.charCodeAt(te),Y|=0;return a.colors[Math.abs(Y)%a.colors.length]}a.selectColor=o;function a(B){let Y,te=null,ve,je;function Ve(...$e){if(!Ve.enabled)return;const He=Ve,Ge=Number(new Date),ee=Ge-(Y||Ge);He.diff=ee,He.prev=Y,He.curr=Ge,Y=Ge,$e[0]=a.coerce($e[0]),typeof $e[0]!="string"&&$e.unshift("%O");let oe=0;$e[0]=$e[0].replace(/%([a-zA-Z%])/g,(Ce,Xe)=>{if(Ce==="%%")return"%";oe++;const re=a.formatters[Xe];if(typeof re=="function"){const X=$e[oe];Ce=re.call(He,X),$e.splice(oe,1),oe--}return Ce}),a.formatArgs.call(He,$e),(He.log||a.log).apply(He,$e)}return Ve.namespace=B,Ve.useColors=a.useColors(),Ve.color=a.selectColor(B),Ve.extend=f,Ve.destroy=a.destroy,Object.defineProperty(Ve,"enabled",{enumerable:!0,configurable:!1,get:()=>te!==null?te:(ve!==a.namespaces&&(ve=a.namespaces,je=a.enabled(B)),je),set:$e=>{te=$e}}),typeof a.init=="function"&&a.init(Ve),Ve}function f(B,Y){const te=a(this.namespace+(typeof Y>"u"?":":Y)+B);return te.log=this.log,te}function g(B){a.save(B),a.namespaces=B,a.names=[],a.skips=[];const Y=(typeof B=="string"?B:"").trim().replace(/\s+/g,",").split(",").filter(Boolean);for(const te of Y)te[0]==="-"?a.skips.push(te.slice(1)):a.names.push(te)}function _(B,Y){let te=0,ve=0,je=-1,Ve=0;for(;te<B.length;)if(ve<Y.length&&(Y[ve]===B[te]||Y[ve]==="*"))Y[ve]==="*"?(je=ve,Ve=te,ve++):(te++,ve++);else if(je!==-1)ve=je+1,Ve++,te=Ve;else return!1;for(;ve<Y.length&&Y[ve]==="*";)ve++;return ve===Y.length}function P(){const B=[...a.names,...a.skips.map(Y=>"-"+Y)].join(",");return a.enable(""),B}function b(B){for(const Y of a.skips)if(_(B,Y))return!1;for(const Y of a.names)if(_(B,Y))return!0;return!1}function q(B){return B instanceof Error?B.stack||B.message:B}function k(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return a.enable(a.load()),a}n.exports=r}}),require_browser=__commonJS({"../node_modules/debug/src/browser.js"(t,n){t.formatArgs=s,t.save=o,t.load=a,t.useColors=r,t.storage=f(),t.destroy=(()=>{let _=!1;return()=>{_||(_=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function r(){if(typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let _;return typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&(_=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(_[1],10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function s(_){if(_[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+_[0]+(this.useColors?"%c ":" ")+"+"+n.exports.humanize(this.diff),!this.useColors)return;const P="color: "+this.color;_.splice(1,0,P,"color: inherit");let b=0,q=0;_[0].replace(/%[a-zA-Z%]/g,k=>{k!=="%%"&&(b++,k==="%c"&&(q=b))}),_.splice(q,0,P)}t.log=console.debug||console.log||(()=>{});function o(_){try{_?t.storage.setItem("debug",_):t.storage.removeItem("debug")}catch{}}function a(){let _;try{_=t.storage.getItem("debug")||t.storage.getItem("DEBUG")}catch{}return!_&&typeof process<"u"&&"env"in process&&(_=define_process_env_default.DEBUG),_}function f(){try{return localStorage}catch{}}n.exports=require_common()(t);var{formatters:g}=n.exports;g.j=function(_){try{return JSON.stringify(_)}catch(P){return"[UnexpectedJSONParseError]: "+P.message}}}}),require_has_flag=__commonJS({"../node_modules/has-flag/index.js"(t,n){n.exports=(r,s=process.argv)=>{const o=r.startsWith("-")?"":r.length===1?"-":"--",a=s.indexOf(o+r),f=s.indexOf("--");return a!==-1&&(f===-1||a<f)}}}),require_supports_color=__commonJS({"../node_modules/supports-color/index.js"(t,n){var r=__require("os"),s=__require("tty"),o=require_has_flag(),{env:a}=process,f;o("no-color")||o("no-colors")||o("color=false")||o("color=never")?f=0:(o("color")||o("colors")||o("color=true")||o("color=always"))&&(f=1),"FORCE_COLOR"in a&&(a.FORCE_COLOR==="true"?f=1:a.FORCE_COLOR==="false"?f=0:f=a.FORCE_COLOR.length===0?1:Math.min(parseInt(a.FORCE_COLOR,10),3));function g(b){return b===0?!1:{level:b,hasBasic:!0,has256:b>=2,has16m:b>=3}}function _(b,q){if(f===0)return 0;if(o("color=16m")||o("color=full")||o("color=truecolor"))return 3;if(o("color=256"))return 2;if(b&&!q&&f===void 0)return 0;const k=f||0;if(a.TERM==="dumb")return k;if(process.platform==="win32"){const B=r.release().split(".");return Number(B[0])>=10&&Number(B[2])>=10586?Number(B[2])>=14931?3:2:1}if("CI"in a)return["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE"].some(B=>B in a)||a.CI_NAME==="codeship"?1:k;if("TEAMCITY_VERSION"in a)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(a.TEAMCITY_VERSION)?1:0;if(a.COLORTERM==="truecolor")return 3;if("TERM_PROGRAM"in a){const B=parseInt((a.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(a.TERM_PROGRAM){case"iTerm.app":return B>=3?3:2;case"Apple_Terminal":return 2}}return/-256(color)?$/i.test(a.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(a.TERM)||"COLORTERM"in a?1:k}function P(b){const q=_(b,b&&b.isTTY);return g(q)}n.exports={supportsColor:P,stdout:g(_(!0,s.isatty(1))),stderr:g(_(!0,s.isatty(2)))}}}),require_node=__commonJS({"../node_modules/debug/src/node.js"(t,n){var r=__require("tty"),s=__require("util");t.init=b,t.log=g,t.formatArgs=a,t.save=_,t.load=P,t.useColors=o,t.destroy=s.deprecate(()=>{},"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."),t.colors=[6,2,3,4,5,1];try{const k=require_supports_color();k&&(k.stderr||k).level>=2&&(t.colors=[20,21,26,27,32,33,38,39,40,41,42,43,44,45,56,57,62,63,68,69,74,75,76,77,78,79,80,81,92,93,98,99,112,113,128,129,134,135,148,149,160,161,162,163,164,165,166,167,168,169,170,171,172,173,178,179,184,185,196,197,198,199,200,201,202,203,204,205,206,207,208,209,214,215,220,221])}catch{}t.inspectOpts=Object.keys(define_process_env_default).filter(k=>/^debug_/i.test(k)).reduce((k,B)=>{const Y=B.substring(6).toLowerCase().replace(/_([a-z])/g,(ve,je)=>je.toUpperCase());let te=define_process_env_default[B];return/^(yes|on|true|enabled)$/i.test(te)?te=!0:/^(no|off|false|disabled)$/i.test(te)?te=!1:te==="null"?te=null:te=Number(te),k[Y]=te,k},{});function o(){return"colors"in t.inspectOpts?!!t.inspectOpts.colors:r.isatty(process.stderr.fd)}function a(k){const{namespace:B,useColors:Y}=this;if(Y){const te=this.color,ve="\x1B[3"+(te<8?te:"8;5;"+te),je=`  ${ve};1m${B} \x1B[0m`;k[0]=je+k[0].split(`
`).join(`
`+je),k.push(ve+"m+"+n.exports.humanize(this.diff)+"\x1B[0m")}else k[0]=f()+B+" "+k[0]}function f(){return t.inspectOpts.hideDate?"":new Date().toISOString()+" "}function g(...k){return process.stderr.write(s.formatWithOptions(t.inspectOpts,...k)+`
`)}function _(k){k?define_process_env_default.DEBUG=k:delete define_process_env_default.DEBUG}function P(){return define_process_env_default.DEBUG}function b(k){k.inspectOpts={};const B=Object.keys(t.inspectOpts);for(let Y=0;Y<B.length;Y++)k.inspectOpts[B[Y]]=t.inspectOpts[B[Y]]}n.exports=require_common()(t);var{formatters:q}=n.exports;q.o=function(k){return this.inspectOpts.colors=this.useColors,s.inspect(k,this.inspectOpts).split(`
`).map(B=>B.trim()).join(" ")},q.O=function(k){return this.inspectOpts.colors=this.useColors,s.inspect(k,this.inspectOpts)}}}),require_src=__commonJS({"../node_modules/debug/src/index.js"(t,n){typeof process>"u"||process.type==="renderer"||process.browser===!0||process.__nwjs?n.exports=require_browser():n.exports=require_node()}}),require_lib2=__commonJS({"../node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js"(t){Object.defineProperty(t,"__esModule",{value:!0}),t.bytes=t.stringToBytes=t.str=t.bytesToString=t.hex=t.utf8=t.bech32m=t.bech32=t.base58check=t.base58xmr=t.base58xrp=t.base58flickr=t.base58=t.base64url=t.base64=t.base32crockford=t.base32hex=t.base32=t.base16=t.utils=t.assertNumber=void 0;function n(re){if(!Number.isSafeInteger(re))throw new Error(`Wrong integer: ${re}`)}t.assertNumber=n;function r(...re){const X=(ne,Le)=>We=>ne(Le(We)),L=Array.from(re).reverse().reduce((ne,Le)=>ne?X(ne,Le.encode):Le.encode,void 0),Z=re.reduce((ne,Le)=>ne?X(ne,Le.decode):Le.decode,void 0);return{encode:L,decode:Z}}function s(re){return{encode:X=>{if(!Array.isArray(X)||X.length&&typeof X[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return X.map(L=>{if(n(L),L<0||L>=re.length)throw new Error(`Digit index outside alphabet: ${L} (alphabet: ${re.length})`);return re[L]})},decode:X=>{if(!Array.isArray(X)||X.length&&typeof X[0]!="string")throw new Error("alphabet.decode input should be array of strings");return X.map(L=>{if(typeof L!="string")throw new Error(`alphabet.decode: not string element=${L}`);const Z=re.indexOf(L);if(Z===-1)throw new Error(`Unknown letter: "${L}". Allowed: ${re}`);return Z})}}}function o(re=""){if(typeof re!="string")throw new Error("join separator should be string");return{encode:X=>{if(!Array.isArray(X)||X.length&&typeof X[0]!="string")throw new Error("join.encode input should be array of strings");for(let L of X)if(typeof L!="string")throw new Error(`join.encode: non-string input=${L}`);return X.join(re)},decode:X=>{if(typeof X!="string")throw new Error("join.decode input should be string");return X.split(re)}}}function a(re,X="="){if(n(re),typeof X!="string")throw new Error("padding chr should be string");return{encode(L){if(!Array.isArray(L)||L.length&&typeof L[0]!="string")throw new Error("padding.encode input should be array of strings");for(let Z of L)if(typeof Z!="string")throw new Error(`padding.encode: non-string input=${Z}`);for(;L.length*re%8;)L.push(X);return L},decode(L){if(!Array.isArray(L)||L.length&&typeof L[0]!="string")throw new Error("padding.encode input should be array of strings");for(let ne of L)if(typeof ne!="string")throw new Error(`padding.decode: non-string input=${ne}`);let Z=L.length;if(Z*re%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;Z>0&&L[Z-1]===X;Z--)if(!((Z-1)*re%8))throw new Error("Invalid padding: string has too much padding");return L.slice(0,Z)}}}function f(re){if(typeof re!="function")throw new Error("normalize fn should be function");return{encode:X=>X,decode:X=>re(X)}}function g(re,X,L){if(X<2)throw new Error(`convertRadix: wrong from=${X}, base cannot be less than 2`);if(L<2)throw new Error(`convertRadix: wrong to=${L}, base cannot be less than 2`);if(!Array.isArray(re))throw new Error("convertRadix: data should be array");if(!re.length)return[];let Z=0;const ne=[],Le=Array.from(re);for(Le.forEach(We=>{if(n(We),We<0||We>=X)throw new Error(`Wrong integer: ${We}`)});;){let We=0,nt=!0;for(let Je=Z;Je<Le.length;Je++){const rt=Le[Je],Qe=X*We+rt;if(!Number.isSafeInteger(Qe)||X*We/X!==We||Qe-rt!==X*We)throw new Error("convertRadix: carry overflow");if(We=Qe%L,Le[Je]=Math.floor(Qe/L),!Number.isSafeInteger(Le[Je])||Le[Je]*L+We!==Qe)throw new Error("convertRadix: carry overflow");if(nt)Le[Je]?nt=!1:Z=Je;else continue}if(ne.push(We),nt)break}for(let We=0;We<re.length-1&&re[We]===0;We++)ne.push(0);return ne.reverse()}var _=(re,X)=>X?_(X,re%X):re,P=(re,X)=>re+(X-_(re,X));function b(re,X,L,Z){if(!Array.isArray(re))throw new Error("convertRadix2: data should be array");if(X<=0||X>32)throw new Error(`convertRadix2: wrong from=${X}`);if(L<=0||L>32)throw new Error(`convertRadix2: wrong to=${L}`);if(P(X,L)>32)throw new Error(`convertRadix2: carry overflow from=${X} to=${L} carryBits=${P(X,L)}`);let ne=0,Le=0;const We=2**L-1,nt=[];for(const Je of re){if(n(Je),Je>=2**X)throw new Error(`convertRadix2: invalid data word=${Je} from=${X}`);if(ne=ne<<X|Je,Le+X>32)throw new Error(`convertRadix2: carry overflow pos=${Le} from=${X}`);for(Le+=X;Le>=L;Le-=L)nt.push((ne>>Le-L&We)>>>0);ne&=2**Le-1}if(ne=ne<<L-Le&We,!Z&&Le>=X)throw new Error("Excess padding");if(!Z&&ne)throw new Error(`Non-zero padding: ${ne}`);return Z&&Le>0&&nt.push(ne>>>0),nt}function q(re){return n(re),{encode:X=>{if(!(X instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return g(Array.from(X),2**8,re)},decode:X=>{if(!Array.isArray(X)||X.length&&typeof X[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(g(X,re,2**8))}}}function k(re,X=!1){if(n(re),re<=0||re>32)throw new Error("radix2: bits should be in (0..32]");if(P(8,re)>32||P(re,8)>32)throw new Error("radix2: carry overflow");return{encode:L=>{if(!(L instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return b(Array.from(L),8,re,!X)},decode:L=>{if(!Array.isArray(L)||L.length&&typeof L[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(b(L,re,8,X))}}}function B(re){if(typeof re!="function")throw new Error("unsafeWrapper fn should be function");return function(...X){try{return re.apply(null,X)}catch{}}}function Y(re,X){if(n(re),typeof X!="function")throw new Error("checksum fn should be function");return{encode(L){if(!(L instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const Z=X(L).slice(0,re),ne=new Uint8Array(L.length+re);return ne.set(L),ne.set(Z,L.length),ne},decode(L){if(!(L instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const Z=L.slice(0,-re),ne=X(Z).slice(0,re),Le=L.slice(-re);for(let We=0;We<re;We++)if(ne[We]!==Le[We])throw new Error("Invalid checksum");return Z}}}t.utils={alphabet:s,chain:r,checksum:Y,radix:q,radix2:k,join:o,padding:a},t.base16=r(k(4),s("0123456789ABCDEF"),o("")),t.base32=r(k(5),s("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),a(5),o("")),t.base32hex=r(k(5),s("0123456789ABCDEFGHIJKLMNOPQRSTUV"),a(5),o("")),t.base32crockford=r(k(5),s("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),o(""),f(re=>re.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))),t.base64=r(k(6),s("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),a(6),o("")),t.base64url=r(k(6),s("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),a(6),o(""));var te=re=>r(q(58),s(re),o(""));t.base58=te("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),t.base58flickr=te("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),t.base58xrp=te("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");var ve=[0,2,3,5,6,7,9,10,11];t.base58xmr={encode(re){let X="";for(let L=0;L<re.length;L+=8){const Z=re.subarray(L,L+8);X+=t.base58.encode(Z).padStart(ve[Z.length],"1")}return X},decode(re){let X=[];for(let L=0;L<re.length;L+=11){const Z=re.slice(L,L+11),ne=ve.indexOf(Z.length),Le=t.base58.decode(Z);for(let We=0;We<Le.length-ne;We++)if(Le[We]!==0)throw new Error("base58xmr: wrong padding");X=X.concat(Array.from(Le.slice(Le.length-ne)))}return Uint8Array.from(X)}};var je=re=>r(Y(4,X=>re(re(X))),t.base58);t.base58check=je;var Ve=r(s("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),o("")),$e=[996825010,642813549,513874426,1027748829,705979059];function He(re){const X=re>>25;let L=(re&33554431)<<5;for(let Z=0;Z<$e.length;Z++)(X>>Z&1)===1&&(L^=$e[Z]);return L}function Ge(re,X,L=1){const Z=re.length;let ne=1;for(let Le=0;Le<Z;Le++){const We=re.charCodeAt(Le);if(We<33||We>126)throw new Error(`Invalid prefix (${re})`);ne=He(ne)^We>>5}ne=He(ne);for(let Le=0;Le<Z;Le++)ne=He(ne)^re.charCodeAt(Le)&31;for(let Le of X)ne=He(ne)^Le;for(let Le=0;Le<6;Le++)ne=He(ne);return ne^=L,Ve.encode(b([ne%2**30],30,5,!1))}function ee(re){const X=re==="bech32"?1:734539939,L=k(5),Z=L.decode,ne=L.encode,Le=B(Z);function We(Qe,st,ht=90){if(typeof Qe!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof Qe}`);if(!Array.isArray(st)||st.length&&typeof st[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof st}`);const ot=Qe.length+7+st.length;if(ht!==!1&&ot>ht)throw new TypeError(`Length ${ot} exceeds limit ${ht}`);return Qe=Qe.toLowerCase(),`${Qe}1${Ve.encode(st)}${Ge(Qe,st,X)}`}function nt(Qe,st=90){if(typeof Qe!="string")throw new Error(`bech32.decode input should be string, not ${typeof Qe}`);if(Qe.length<8||st!==!1&&Qe.length>st)throw new TypeError(`Wrong string length: ${Qe.length} (${Qe}). Expected (8..${st})`);const ht=Qe.toLowerCase();if(Qe!==ht&&Qe!==Qe.toUpperCase())throw new Error("String must be lowercase or uppercase");Qe=ht;const ot=Qe.lastIndexOf("1");if(ot===0||ot===-1)throw new Error('Letter "1" must be present between prefix and data only');const ut=Qe.slice(0,ot),_t=Qe.slice(ot+1);if(_t.length<6)throw new Error("Data must be at least 6 characters long");const lt=Ve.decode(_t).slice(0,-6),Bt=Ge(ut,lt,X);if(!_t.endsWith(Bt))throw new Error(`Invalid checksum in ${Qe}: expected "${Bt}"`);return{prefix:ut,words:lt}}const Je=B(nt);function rt(Qe){const{prefix:st,words:ht}=nt(Qe,!1);return{prefix:st,words:ht,bytes:Z(ht)}}return{encode:We,decode:nt,decodeToBytes:rt,decodeUnsafe:Je,fromWords:Z,fromWordsUnsafe:Le,toWords:ne}}t.bech32=ee("bech32"),t.bech32m=ee("bech32m"),t.utf8={encode:re=>new TextDecoder().decode(re),decode:re=>new TextEncoder().encode(re)},t.hex=r(k(4),s("0123456789abcdef"),o(""),f(re=>{if(typeof re!="string"||re.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof re} with length ${re.length}`);return re.toLowerCase()}));var oe={utf8:t.utf8,hex:t.hex,base16:t.base16,base32:t.base32,base64:t.base64,base64url:t.base64url,base58:t.base58,base58xmr:t.base58xmr},Ue=`Invalid encoding type. Available types: ${Object.keys(oe).join(", ")}`,Ce=(re,X)=>{if(typeof re!="string"||!oe.hasOwnProperty(re))throw new TypeError(Ue);if(!(X instanceof Uint8Array))throw new TypeError("bytesToString() expects Uint8Array");return oe[re].encode(X)};t.bytesToString=Ce,t.str=t.bytesToString;var Xe=(re,X)=>{if(!oe.hasOwnProperty(re))throw new TypeError(Ue);if(typeof X!="string")throw new TypeError("stringToBytes() expects string");return oe[re].decode(X)};t.stringToBytes=Xe,t.bytes=t.stringToBytes}}),require_bolt11=__commonJS({"../node_modules/light-bolt11-decoder/bolt11.js"(t,n){var{bech32:r,hex:s,utf8:o}=require_lib2(),a={bech32:"bc",pubKeyHash:0,scriptHash:5,validWitnessVersions:[0]},f={bech32:"tb",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},g={bech32:"tbs",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},_={bech32:"bcrt",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},P={bech32:"sb",pubKeyHash:63,scriptHash:123,validWitnessVersions:[0]},b=["option_data_loss_protect","initial_routing_sync","option_upfront_shutdown_script","gossip_queries","var_onion_optin","gossip_queries_ex","option_static_remotekey","payment_secret","basic_mpp","option_support_large_channel"],q={m:BigInt(1e3),u:BigInt(1e6),n:BigInt(1e9),p:BigInt(1e12)},k=BigInt("2100000000000000000"),B=BigInt(1e11),Y={payment_hash:1,payment_secret:16,description:13,payee:19,description_hash:23,expiry:6,min_final_cltv_expiry:24,fallback_address:9,route_hint:3,feature_bits:5,metadata:27},te={};for(let oe=0,Ue=Object.keys(Y);oe<Ue.length;oe++){const Ce=Ue[oe],Xe=Y[Ue[oe]].toString();te[Xe]=Ce}var ve={1:oe=>s.encode(r.fromWordsUnsafe(oe)),16:oe=>s.encode(r.fromWordsUnsafe(oe)),13:oe=>o.encode(r.fromWordsUnsafe(oe)),19:oe=>s.encode(r.fromWordsUnsafe(oe)),23:oe=>s.encode(r.fromWordsUnsafe(oe)),27:oe=>s.encode(r.fromWordsUnsafe(oe)),6:Ve,24:Ve,3:$e,5:He};function je(oe){return Ue=>({tagCode:parseInt(oe),words:r.encode("unknown",Ue,Number.MAX_SAFE_INTEGER)})}function Ve(oe){return oe.reverse().reduce((Ue,Ce,Xe)=>Ue+Ce*Math.pow(32,Xe),0)}function $e(oe){const Ue=[];let Ce,Xe,re,X,L,Z=r.fromWordsUnsafe(oe);for(;Z.length>0;)Ce=s.encode(Z.slice(0,33)),Xe=s.encode(Z.slice(33,41)),re=parseInt(s.encode(Z.slice(41,45)),16),X=parseInt(s.encode(Z.slice(45,49)),16),L=parseInt(s.encode(Z.slice(49,51)),16),Z=Z.slice(51),Ue.push({pubkey:Ce,short_channel_id:Xe,fee_base_msat:re,fee_proportional_millionths:X,cltv_expiry_delta:L});return Ue}function He(oe){const Ue=oe.slice().reverse().map(re=>[!!(re&1),!!(re&2),!!(re&4),!!(re&8),!!(re&16)]).reduce((re,X)=>re.concat(X),[]);for(;Ue.length<b.length*2;)Ue.push(!1);const Ce={};b.forEach((re,X)=>{let L;Ue[X*2]?L="required":Ue[X*2+1]?L="supported":L="unsupported",Ce[re]=L});const Xe=Ue.slice(b.length*2);return Ce.extra_bits={start_bit:b.length*2,bits:Xe,has_required:Xe.reduce((re,X,L)=>L%2!==0?re||!1:re||X,!1)},Ce}function Ge(oe,Ue){let Ce,Xe;if(oe.slice(-1).match(/^[munp]$/))Ce=oe.slice(-1),Xe=oe.slice(0,-1);else{if(oe.slice(-1).match(/^[^munp0-9]$/))throw new Error("Not a valid multiplier for the amount");Xe=oe}if(!Xe.match(/^\d+$/))throw new Error("Not a valid human readable amount");const re=BigInt(Xe),X=Ce?re*B/q[Ce]:re*B;if(Ce==="p"&&re%BigInt(10)!==BigInt(0)||X>k)throw new Error("Amount is outside of valid range");return Ue?X.toString():X}function ee(oe,Ue){if(typeof oe!="string")throw new Error("Lightning Payment Request must be string");if(oe.slice(0,2).toLowerCase()!=="ln")throw new Error("Not a proper lightning payment request");const Ce=[],Xe=r.decode(oe,Number.MAX_SAFE_INTEGER);oe=oe.toLowerCase();const re=Xe.prefix;let X=Xe.words,L=oe.slice(re.length+1),Z=X.slice(-104);X=X.slice(0,-104);let ne=re.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);if(ne&&!ne[2]&&(ne=re.match(/^ln(\S+)$/)),!ne)throw new Error("Not a proper lightning payment request");Ce.push({name:"lightning_network",letters:"ln"});const Le=ne[1];let We;if(Ue){if(Ue.bech32===void 0||Ue.pubKeyHash===void 0||Ue.scriptHash===void 0||!Array.isArray(Ue.validWitnessVersions))throw new Error("Invalid network");We=Ue}else switch(Le){case a.bech32:We=a;break;case f.bech32:We=f;break;case g.bech32:We=g;break;case _.bech32:We=_;break;case P.bech32:We=P;break}if(!We||We.bech32!==Le)throw new Error("Unknown coin bech32 prefix");Ce.push({name:"coin_network",letters:Le,value:We});const nt=ne[2];let Je;if(nt){const lt=ne[3];Je=Ge(nt+lt,!0),Ce.push({name:"amount",letters:ne[2]+ne[3],value:Je})}else Je=null;Ce.push({name:"separator",letters:"1"});const rt=Ve(X.slice(0,7));X=X.slice(7),Ce.push({name:"timestamp",letters:L.slice(0,7),value:rt}),L=L.slice(7);let Qe,st,ht,ot;for(;X.length>0;){const lt=X[0].toString();Qe=te[lt]||"unknown_tag",st=ve[lt]||je(lt),X=X.slice(1),ht=Ve(X.slice(0,2)),X=X.slice(2),ot=X.slice(0,ht),X=X.slice(ht),Ce.push({name:Qe,tag:L[0],letters:L.slice(0,3+ht),value:st(ot)}),L=L.slice(3+ht)}Ce.push({name:"signature",letters:L.slice(0,104),value:s.encode(r.fromWordsUnsafe(Z))}),L=L.slice(104),Ce.push({name:"checksum",letters:L});let ut={paymentRequest:oe,sections:Ce,get expiry(){let lt=Ce.find(Bt=>Bt.name==="expiry");if(lt)return _t("timestamp")+lt.value},get route_hints(){return Ce.filter(lt=>lt.name==="route_hint").map(lt=>lt.value)}};for(let lt in Y)lt!=="route_hint"&&Object.defineProperty(ut,lt,{get(){return _t(lt)}});return ut;function _t(lt){let Bt=Ce.find(St=>St.name===lt);return Bt?Bt.value:void 0}}n.exports={decode:ee,hrpToMillisat:Ge}}}),require_errors=__commonJS({"../node_modules/webln/lib/errors.js"(t){var n=t&&t.__extends||(function(){var q=function(k,B){return q=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(Y,te){Y.__proto__=te}||function(Y,te){for(var ve in te)Object.prototype.hasOwnProperty.call(te,ve)&&(Y[ve]=te[ve])},q(k,B)};return function(k,B){if(typeof B!="function"&&B!==null)throw new TypeError("Class extends value "+String(B)+" is not a constructor or null");q(k,B);function Y(){this.constructor=k}k.prototype=B===null?Object.create(B):(Y.prototype=B.prototype,new Y)}})();Object.defineProperty(t,"__esModule",{value:!0}),t.InternalError=t.InvalidDataError=t.RoutingError=t.UnsupportedMethodError=t.ConnectionError=t.RejectionError=t.MissingProviderError=void 0;function r(q,k,B){if(Object.setPrototypeOf(q,B.prototype),k===B)if(q.name=k.name,Error.captureStackTrace)Error.captureStackTrace(q,B);else{var Y=new Error(q.message).stack;Y&&(q.stack=s(Y,"new ".concat(k.name)))}}function s(q,k){if(!q||!k)return q;var B=new RegExp("\\s+at\\s".concat(k,"\\s")),Y=q.split(`
`),te=Y.filter(function(ve){return!ve.match(B)});return te.join(`
`)}var o=(function(q){n(k,q);function k(B){var Y=this.constructor,te=q.call(this,B)||this;return r(te,Y,k),te}return k})(Error);t.MissingProviderError=o;var a=(function(q){n(k,q);function k(B){var Y=this.constructor,te=q.call(this,B)||this;return r(te,Y,k),te}return k})(Error);t.RejectionError=a;var f=(function(q){n(k,q);function k(B){var Y=this.constructor,te=q.call(this,B)||this;return r(te,Y,k),te}return k})(Error);t.ConnectionError=f;var g=(function(q){n(k,q);function k(B){var Y=this.constructor,te=q.call(this,B)||this;return r(te,Y,k),te}return k})(Error);t.UnsupportedMethodError=g;var _=(function(q){n(k,q);function k(B){var Y=this.constructor,te=q.call(this,B)||this;return r(te,Y,k),te}return k})(Error);t.RoutingError=_;var P=(function(q){n(k,q);function k(B){var Y=this.constructor,te=q.call(this,B)||this;return r(te,Y,k),te}return k})(Error);t.InvalidDataError=P;var b=(function(q){n(k,q);function k(B){var Y=this.constructor,te=q.call(this,B)||this;return r(te,Y,k),te}return k})(Error);t.InternalError=b}}),require_client=__commonJS({"../node_modules/webln/lib/client.js"(t){Object.defineProperty(t,"__esModule",{value:!0}),t.requestProvider=void 0;var n=require_errors();function r(s){return new Promise(function(o,a){if(typeof window>"u")return a(new Error("Must be called in a browser context"));var f=window.webln;if(!f)return a(new n.MissingProviderError("Your browser has no WebLN provider"));f.enable().then(function(){return o(f)}).catch(function(g){return a(g)})})}t.requestProvider=r}}),require_provider=__commonJS({"../node_modules/webln/lib/provider.js"(t){Object.defineProperty(t,"__esModule",{value:!0})}}),require_lib3=__commonJS({"../node_modules/webln/lib/index.js"(t){var n=t&&t.__createBinding||(Object.create?(function(s,o,a,f){f===void 0&&(f=a);var g=Object.getOwnPropertyDescriptor(o,a);(!g||("get"in g?!o.__esModule:g.writable||g.configurable))&&(g={enumerable:!0,get:function(){return o[a]}}),Object.defineProperty(s,f,g)}):(function(s,o,a,f){f===void 0&&(f=a),s[f]=o[a]})),r=t&&t.__exportStar||function(s,o){for(var a in s)a!=="default"&&!Object.prototype.hasOwnProperty.call(o,a)&&n(o,s,a)};Object.defineProperty(t,"__esModule",{value:!0}),r(require_client(),t),r(require_provider(),t),r(require_errors(),t)}}),import_tseep2=__toESM(require_lib());function isBytes(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function anumber(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function abytes(t,...n){if(!isBytes(t))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(t.length))throw new Error("Uint8Array expected of length "+n+", got length="+t.length)}function ahash(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");anumber(t.outputLen),anumber(t.blockLen)}function aexists(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function aoutput(t,n){abytes(t);const r=n.outputLen;if(t.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}function clean(...t){for(let n=0;n<t.length;n++)t[n].fill(0)}function createView(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function rotr(t,n){return t<<32-n|t>>>n}function rotl(t,n){return t<<n|t>>>32-n>>>0}var hasHexBuiltin=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",hexes=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function bytesToHex(t){if(abytes(t),hasHexBuiltin)return t.toHex();let n="";for(let r=0;r<t.length;r++)n+=hexes[t[r]];return n}var asciis={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(t){if(t>=asciis._0&&t<=asciis._9)return t-asciis._0;if(t>=asciis.A&&t<=asciis.F)return t-(asciis.A-10);if(t>=asciis.a&&t<=asciis.f)return t-(asciis.a-10)}function hexToBytes(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(hasHexBuiltin)return Uint8Array.fromHex(t);const n=t.length,r=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const s=new Uint8Array(r);for(let o=0,a=0;o<r;o++,a+=2){const f=asciiToBase16(t.charCodeAt(a)),g=asciiToBase16(t.charCodeAt(a+1));if(f===void 0||g===void 0){const _=t[a]+t[a+1];throw new Error('hex string expected, got non-hex character "'+_+'" at index '+a)}s[o]=f*16+g}return s}function utf8ToBytes(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function toBytes(t){return typeof t=="string"&&(t=utf8ToBytes(t)),abytes(t),t}function concatBytes(...t){let n=0;for(let s=0;s<t.length;s++){const o=t[s];abytes(o),n+=o.length}const r=new Uint8Array(n);for(let s=0,o=0;s<t.length;s++){const a=t[s];r.set(a,o),o+=a.length}return r}var Hash=class{};function createHasher(t){const n=s=>t().update(toBytes(s)).digest(),r=t();return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=()=>t(),n}function randomBytes(t=32){throw new Error("crypto.getRandomValues must be defined")}function setBigUint64(t,n,r,s){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,r,s);const o=BigInt(32),a=BigInt(4294967295),f=Number(r>>o&a),g=Number(r&a),_=s?4:0,P=s?0:4;t.setUint32(n+_,f,s),t.setUint32(n+P,g,s)}function Chi(t,n,r){return t&n^~t&r}function Maj(t,n,r){return t&n^t&r^n&r}var HashMD=class extends Hash{constructor(t,n,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(t),this.view=createView(this.buffer)}update(t){aexists(this),t=toBytes(t),abytes(t);const{view:n,buffer:r,blockLen:s}=this,o=t.length;for(let a=0;a<o;){const f=Math.min(s-this.pos,o-a);if(f===s){const g=createView(t);for(;s<=o-a;a+=s)this.process(g,a);continue}r.set(t.subarray(a,a+f),this.pos),this.pos+=f,a+=f,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){aexists(this),aoutput(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:o}=this;let{pos:a}=this;n[a++]=128,clean(this.buffer.subarray(a)),this.padOffset>s-a&&(this.process(r,0),a=0);for(let b=a;b<s;b++)n[b]=0;setBigUint64(r,s-8,BigInt(this.length*8),o),this.process(r,0);const f=createView(t),g=this.outputLen;if(g%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const _=g/4,P=this.get();if(_>P.length)throw new Error("_sha2: outputLen bigger than state");for(let b=0;b<_;b++)f.setUint32(4*b,P[b],o)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:o,destroyed:a,pos:f}=this;return t.destroyed=a,t.finished=o,t.length=s,t.pos=f,s%n&&t.buffer.set(r),t}clone(){return this._cloneInto()}},SHA256_IV=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA512_IV=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),U32_MASK64=BigInt(2**32-1),_32n=BigInt(32);function fromBig(t,n=!1){return n?{h:Number(t&U32_MASK64),l:Number(t>>_32n&U32_MASK64)}:{h:Number(t>>_32n&U32_MASK64)|0,l:Number(t&U32_MASK64)|0}}function split(t,n=!1){const r=t.length;let s=new Uint32Array(r),o=new Uint32Array(r);for(let a=0;a<r;a++){const{h:f,l:g}=fromBig(t[a],n);[s[a],o[a]]=[f,g]}return[s,o]}var shrSH=(t,n,r)=>t>>>r,shrSL=(t,n,r)=>t<<32-r|n>>>r,rotrSH=(t,n,r)=>t>>>r|n<<32-r,rotrSL=(t,n,r)=>t<<32-r|n>>>r,rotrBH=(t,n,r)=>t<<64-r|n>>>r-32,rotrBL=(t,n,r)=>t>>>r-32|n<<64-r;function add(t,n,r,s){const o=(n>>>0)+(s>>>0);return{h:t+r+(o/2**32|0)|0,l:o|0}}var add3L=(t,n,r)=>(t>>>0)+(n>>>0)+(r>>>0),add3H=(t,n,r,s)=>n+r+s+(t/2**32|0)|0,add4L=(t,n,r,s)=>(t>>>0)+(n>>>0)+(r>>>0)+(s>>>0),add4H=(t,n,r,s,o)=>n+r+s+o+(t/2**32|0)|0,add5L=(t,n,r,s,o)=>(t>>>0)+(n>>>0)+(r>>>0)+(s>>>0)+(o>>>0),add5H=(t,n,r,s,o,a)=>n+r+s+o+a+(t/2**32|0)|0,SHA256_K=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_W=new Uint32Array(64),SHA256=class extends HashMD{constructor(t=32){super(64,t,8,!1),this.A=SHA256_IV[0]|0,this.B=SHA256_IV[1]|0,this.C=SHA256_IV[2]|0,this.D=SHA256_IV[3]|0,this.E=SHA256_IV[4]|0,this.F=SHA256_IV[5]|0,this.G=SHA256_IV[6]|0,this.H=SHA256_IV[7]|0}get(){const{A:t,B:n,C:r,D:s,E:o,F:a,G:f,H:g}=this;return[t,n,r,s,o,a,f,g]}set(t,n,r,s,o,a,f,g){this.A=t|0,this.B=n|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=a|0,this.G=f|0,this.H=g|0}process(t,n){for(let b=0;b<16;b++,n+=4)SHA256_W[b]=t.getUint32(n,!1);for(let b=16;b<64;b++){const q=SHA256_W[b-15],k=SHA256_W[b-2],B=rotr(q,7)^rotr(q,18)^q>>>3,Y=rotr(k,17)^rotr(k,19)^k>>>10;SHA256_W[b]=Y+SHA256_W[b-7]+B+SHA256_W[b-16]|0}let{A:r,B:s,C:o,D:a,E:f,F:g,G:_,H:P}=this;for(let b=0;b<64;b++){const q=rotr(f,6)^rotr(f,11)^rotr(f,25),k=P+q+Chi(f,g,_)+SHA256_K[b]+SHA256_W[b]|0,Y=(rotr(r,2)^rotr(r,13)^rotr(r,22))+Maj(r,s,o)|0;P=_,_=g,g=f,f=a+k|0,a=o,o=s,s=r,r=k+Y|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,a=a+this.D|0,f=f+this.E|0,g=g+this.F|0,_=_+this.G|0,P=P+this.H|0,this.set(r,s,o,a,f,g,_,P)}roundClean(){clean(SHA256_W)}destroy(){this.set(0,0,0,0,0,0,0,0),clean(this.buffer)}},K512=split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))),SHA512_Kh=K512[0],SHA512_Kl=K512[1],SHA512_W_H=new Uint32Array(80),SHA512_W_L=new Uint32Array(80),SHA512=class extends HashMD{constructor(t=64){super(128,t,16,!1),this.Ah=SHA512_IV[0]|0,this.Al=SHA512_IV[1]|0,this.Bh=SHA512_IV[2]|0,this.Bl=SHA512_IV[3]|0,this.Ch=SHA512_IV[4]|0,this.Cl=SHA512_IV[5]|0,this.Dh=SHA512_IV[6]|0,this.Dl=SHA512_IV[7]|0,this.Eh=SHA512_IV[8]|0,this.El=SHA512_IV[9]|0,this.Fh=SHA512_IV[10]|0,this.Fl=SHA512_IV[11]|0,this.Gh=SHA512_IV[12]|0,this.Gl=SHA512_IV[13]|0,this.Hh=SHA512_IV[14]|0,this.Hl=SHA512_IV[15]|0}get(){const{Ah:t,Al:n,Bh:r,Bl:s,Ch:o,Cl:a,Dh:f,Dl:g,Eh:_,El:P,Fh:b,Fl:q,Gh:k,Gl:B,Hh:Y,Hl:te}=this;return[t,n,r,s,o,a,f,g,_,P,b,q,k,B,Y,te]}set(t,n,r,s,o,a,f,g,_,P,b,q,k,B,Y,te){this.Ah=t|0,this.Al=n|0,this.Bh=r|0,this.Bl=s|0,this.Ch=o|0,this.Cl=a|0,this.Dh=f|0,this.Dl=g|0,this.Eh=_|0,this.El=P|0,this.Fh=b|0,this.Fl=q|0,this.Gh=k|0,this.Gl=B|0,this.Hh=Y|0,this.Hl=te|0}process(t,n){for(let Ve=0;Ve<16;Ve++,n+=4)SHA512_W_H[Ve]=t.getUint32(n),SHA512_W_L[Ve]=t.getUint32(n+=4);for(let Ve=16;Ve<80;Ve++){const $e=SHA512_W_H[Ve-15]|0,He=SHA512_W_L[Ve-15]|0,Ge=rotrSH($e,He,1)^rotrSH($e,He,8)^shrSH($e,He,7),ee=rotrSL($e,He,1)^rotrSL($e,He,8)^shrSL($e,He,7),oe=SHA512_W_H[Ve-2]|0,Ue=SHA512_W_L[Ve-2]|0,Ce=rotrSH(oe,Ue,19)^rotrBH(oe,Ue,61)^shrSH(oe,Ue,6),Xe=rotrSL(oe,Ue,19)^rotrBL(oe,Ue,61)^shrSL(oe,Ue,6),re=add4L(ee,Xe,SHA512_W_L[Ve-7],SHA512_W_L[Ve-16]),X=add4H(re,Ge,Ce,SHA512_W_H[Ve-7],SHA512_W_H[Ve-16]);SHA512_W_H[Ve]=X|0,SHA512_W_L[Ve]=re|0}let{Ah:r,Al:s,Bh:o,Bl:a,Ch:f,Cl:g,Dh:_,Dl:P,Eh:b,El:q,Fh:k,Fl:B,Gh:Y,Gl:te,Hh:ve,Hl:je}=this;for(let Ve=0;Ve<80;Ve++){const $e=rotrSH(b,q,14)^rotrSH(b,q,18)^rotrBH(b,q,41),He=rotrSL(b,q,14)^rotrSL(b,q,18)^rotrBL(b,q,41),Ge=b&k^~b&Y,ee=q&B^~q&te,oe=add5L(je,He,ee,SHA512_Kl[Ve],SHA512_W_L[Ve]),Ue=add5H(oe,ve,$e,Ge,SHA512_Kh[Ve],SHA512_W_H[Ve]),Ce=oe|0,Xe=rotrSH(r,s,28)^rotrBH(r,s,34)^rotrBH(r,s,39),re=rotrSL(r,s,28)^rotrBL(r,s,34)^rotrBL(r,s,39),X=r&o^r&f^o&f,L=s&a^s&g^a&g;ve=Y|0,je=te|0,Y=k|0,te=B|0,k=b|0,B=q|0,{h:b,l:q}=add(_|0,P|0,Ue|0,Ce|0),_=f|0,P=g|0,f=o|0,g=a|0,o=r|0,a=s|0;const Z=add3L(Ce,re,L);r=add3H(Z,Ue,Xe,X),s=Z|0}({h:r,l:s}=add(this.Ah|0,this.Al|0,r|0,s|0)),{h:o,l:a}=add(this.Bh|0,this.Bl|0,o|0,a|0),{h:f,l:g}=add(this.Ch|0,this.Cl|0,f|0,g|0),{h:_,l:P}=add(this.Dh|0,this.Dl|0,_|0,P|0),{h:b,l:q}=add(this.Eh|0,this.El|0,b|0,q|0),{h:k,l:B}=add(this.Fh|0,this.Fl|0,k|0,B|0),{h:Y,l:te}=add(this.Gh|0,this.Gl|0,Y|0,te|0),{h:ve,l:je}=add(this.Hh|0,this.Hl|0,ve|0,je|0),this.set(r,s,o,a,f,g,_,P,b,q,k,B,Y,te,ve,je)}roundClean(){clean(SHA512_W_H,SHA512_W_L)}destroy(){clean(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}},sha256=createHasher(()=>new SHA256),sha512=createHasher(()=>new SHA512),HMAC=class extends Hash{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,ahash(t);const r=toBytes(n);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?t.create().update(r).digest():r);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=t.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),clean(o)}update(t){return aexists(this),this.iHash.update(t),this}digestInto(t){aexists(this),abytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:s,destroyed:o,blockLen:a,outputLen:f}=this;return t=t,t.finished=s,t.destroyed=o,t.blockLen=a,t.outputLen=f,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},hmac=(t,n,r)=>new HMAC(t,n).update(r).digest();hmac.create=(t,n)=>new HMAC(t,n);var _0n=BigInt(0),_1n=BigInt(1);function _abool2(t,n=""){if(typeof t!="boolean"){const r=n&&`"${n}"`;throw new Error(r+"expected boolean, got type="+typeof t)}return t}function _abytes2(t,n,r=""){const s=isBytes(t),o=t?.length,a=n!==void 0;if(!s||a&&o!==n){const f=r&&`"${r}" `,g=a?` of length ${n}`:"",_=s?`length=${o}`:`type=${typeof t}`;throw new Error(f+"expected Uint8Array"+g+", got "+_)}return t}function numberToHexUnpadded(t){const n=t.toString(16);return n.length&1?"0"+n:n}function hexToNumber(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?_0n:BigInt("0x"+t)}function bytesToNumberBE(t){return hexToNumber(bytesToHex(t))}function bytesToNumberLE(t){return abytes(t),hexToNumber(bytesToHex(Uint8Array.from(t).reverse()))}function numberToBytesBE(t,n){return hexToBytes(t.toString(16).padStart(n*2,"0"))}function numberToBytesLE(t,n){return numberToBytesBE(t,n).reverse()}function ensureBytes(t,n,r){let s;if(typeof n=="string")try{s=hexToBytes(n)}catch(a){throw new Error(t+" must be hex string or Uint8Array, cause: "+a)}else if(isBytes(n))s=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const o=s.length;if(typeof r=="number"&&o!==r)throw new Error(t+" of length "+r+" expected, got "+o);return s}var isPosBig=t=>typeof t=="bigint"&&_0n<=t;function inRange(t,n,r){return isPosBig(t)&&isPosBig(n)&&isPosBig(r)&&n<=t&&t<r}function aInRange(t,n,r,s){if(!inRange(n,r,s))throw new Error("expected valid "+t+": "+r+" <= n < "+s+", got "+n)}function bitLen(t){let n;for(n=0;t>_0n;t>>=_1n,n+=1);return n}var bitMask=t=>(_1n<<BigInt(t))-_1n;function createHmacDrbg(t,n,r){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");const s=B=>new Uint8Array(B),o=B=>Uint8Array.of(B);let a=s(t),f=s(t),g=0;const _=()=>{a.fill(1),f.fill(0),g=0},P=(...B)=>r(f,a,...B),b=(B=s(0))=>{f=P(o(0),B),a=P(),B.length!==0&&(f=P(o(1),B),a=P())},q=()=>{if(g++>=1e3)throw new Error("drbg: tried 1000 values");let B=0;const Y=[];for(;B<n;){a=P();const te=a.slice();Y.push(te),B+=a.length}return concatBytes(...Y)};return(B,Y)=>{_(),b(B);let te;for(;!(te=Y(q()));)b();return _(),te}}function _validateObject(t,n,r={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function s(o,a,f){const g=t[o];if(f&&g===void 0)return;const _=typeof g;if(_!==a||g===null)throw new Error(`param "${o}" is invalid: expected ${a}, got ${_}`)}Object.entries(n).forEach(([o,a])=>s(o,a,!1)),Object.entries(r).forEach(([o,a])=>s(o,a,!0))}function memoized(t){const n=new WeakMap;return(r,...s)=>{const o=n.get(r);if(o!==void 0)return o;const a=t(r,...s);return n.set(r,a),a}}var _0n2=BigInt(0),_1n2=BigInt(1),_2n=BigInt(2),_3n=BigInt(3),_4n=BigInt(4),_5n=BigInt(5),_7n=BigInt(7),_8n=BigInt(8),_9n=BigInt(9),_16n=BigInt(16);function mod(t,n){const r=t%n;return r>=_0n2?r:n+r}function pow2(t,n,r){let s=t;for(;n-- >_0n2;)s*=s,s%=r;return s}function invert(t,n){if(t===_0n2)throw new Error("invert: expected non-zero number");if(n<=_0n2)throw new Error("invert: expected positive modulus, got "+n);let r=mod(t,n),s=n,o=_0n2,a=_1n2;for(;r!==_0n2;){const g=s/r,_=s%r,P=o-a*g;s=r,r=_,o=a,a=P}if(s!==_1n2)throw new Error("invert: does not exist");return mod(o,n)}function assertIsSquare(t,n,r){if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root")}function sqrt3mod4(t,n){const r=(t.ORDER+_1n2)/_4n,s=t.pow(n,r);return assertIsSquare(t,s,n),s}function sqrt5mod8(t,n){const r=(t.ORDER-_5n)/_8n,s=t.mul(n,_2n),o=t.pow(s,r),a=t.mul(n,o),f=t.mul(t.mul(a,_2n),o),g=t.mul(a,t.sub(f,t.ONE));return assertIsSquare(t,g,n),g}function sqrt9mod16(t){const n=Field(t),r=tonelliShanks(t),s=r(n,n.neg(n.ONE)),o=r(n,s),a=r(n,n.neg(s)),f=(t+_7n)/_16n;return(g,_)=>{let P=g.pow(_,f),b=g.mul(P,s);const q=g.mul(P,o),k=g.mul(P,a),B=g.eql(g.sqr(b),_),Y=g.eql(g.sqr(q),_);P=g.cmov(P,b,B),b=g.cmov(k,q,Y);const te=g.eql(g.sqr(b),_),ve=g.cmov(P,b,te);return assertIsSquare(g,ve,_),ve}}function tonelliShanks(t){if(t<_3n)throw new Error("sqrt is not defined for small field");let n=t-_1n2,r=0;for(;n%_2n===_0n2;)n/=_2n,r++;let s=_2n;const o=Field(t);for(;FpLegendre(o,s)===1;)if(s++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return sqrt3mod4;let a=o.pow(s,n);const f=(n+_1n2)/_2n;return function(_,P){if(_.is0(P))return P;if(FpLegendre(_,P)!==1)throw new Error("Cannot find square root");let b=r,q=_.mul(_.ONE,a),k=_.pow(P,n),B=_.pow(P,f);for(;!_.eql(k,_.ONE);){if(_.is0(k))return _.ZERO;let Y=1,te=_.sqr(k);for(;!_.eql(te,_.ONE);)if(Y++,te=_.sqr(te),Y===b)throw new Error("Cannot find square root");const ve=_1n2<<BigInt(b-Y-1),je=_.pow(q,ve);b=Y,q=_.sqr(je),k=_.mul(k,q),B=_.mul(B,je)}return B}}function FpSqrt(t){return t%_4n===_3n?sqrt3mod4:t%_8n===_5n?sqrt5mod8:t%_16n===_9n?sqrt9mod16(t):tonelliShanks(t)}var FIELD_FIELDS=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},r=FIELD_FIELDS.reduce((s,o)=>(s[o]="function",s),n);return _validateObject(t,r),t}function FpPow(t,n,r){if(r<_0n2)throw new Error("invalid exponent, negatives unsupported");if(r===_0n2)return t.ONE;if(r===_1n2)return n;let s=t.ONE,o=n;for(;r>_0n2;)r&_1n2&&(s=t.mul(s,o)),o=t.sqr(o),r>>=_1n2;return s}function FpInvertBatch(t,n,r=!1){const s=new Array(n.length).fill(r?t.ZERO:void 0),o=n.reduce((f,g,_)=>t.is0(g)?f:(s[_]=f,t.mul(f,g)),t.ONE),a=t.inv(o);return n.reduceRight((f,g,_)=>t.is0(g)?f:(s[_]=t.mul(f,s[_]),t.mul(f,g)),a),s}function FpLegendre(t,n){const r=(t.ORDER-_1n2)/_2n,s=t.pow(n,r),o=t.eql(s,t.ONE),a=t.eql(s,t.ZERO),f=t.eql(s,t.neg(t.ONE));if(!o&&!a&&!f)throw new Error("invalid Legendre symbol result");return o?1:a?0:-1}function nLength(t,n){n!==void 0&&anumber(n);const r=n!==void 0?n:t.toString(2).length,s=Math.ceil(r/8);return{nBitLength:r,nByteLength:s}}function Field(t,n,r=!1,s={}){if(t<=_0n2)throw new Error("invalid field: expected ORDER > 0, got "+t);let o,a,f=!1,g;if(typeof n=="object"&&n!=null){if(s.sqrt||r)throw new Error("cannot specify opts in two arguments");const k=n;k.BITS&&(o=k.BITS),k.sqrt&&(a=k.sqrt),typeof k.isLE=="boolean"&&(r=k.isLE),typeof k.modFromBytes=="boolean"&&(f=k.modFromBytes),g=k.allowedLengths}else typeof n=="number"&&(o=n),s.sqrt&&(a=s.sqrt);const{nBitLength:_,nByteLength:P}=nLength(t,o);if(P>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let b;const q=Object.freeze({ORDER:t,isLE:r,BITS:_,BYTES:P,MASK:bitMask(_),ZERO:_0n2,ONE:_1n2,allowedLengths:g,create:k=>mod(k,t),isValid:k=>{if(typeof k!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof k);return _0n2<=k&&k<t},is0:k=>k===_0n2,isValidNot0:k=>!q.is0(k)&&q.isValid(k),isOdd:k=>(k&_1n2)===_1n2,neg:k=>mod(-k,t),eql:(k,B)=>k===B,sqr:k=>mod(k*k,t),add:(k,B)=>mod(k+B,t),sub:(k,B)=>mod(k-B,t),mul:(k,B)=>mod(k*B,t),pow:(k,B)=>FpPow(q,k,B),div:(k,B)=>mod(k*invert(B,t),t),sqrN:k=>k*k,addN:(k,B)=>k+B,subN:(k,B)=>k-B,mulN:(k,B)=>k*B,inv:k=>invert(k,t),sqrt:a||(k=>(b||(b=FpSqrt(t)),b(q,k))),toBytes:k=>r?numberToBytesLE(k,P):numberToBytesBE(k,P),fromBytes:(k,B=!0)=>{if(g){if(!g.includes(k.length)||k.length>P)throw new Error("Field.fromBytes: expected "+g+" bytes, got "+k.length);const te=new Uint8Array(P);te.set(k,r?0:te.length-k.length),k=te}if(k.length!==P)throw new Error("Field.fromBytes: expected "+P+" bytes, got "+k.length);let Y=r?bytesToNumberLE(k):bytesToNumberBE(k);if(f&&(Y=mod(Y,t)),!B&&!q.isValid(Y))throw new Error("invalid field element: outside of range 0..ORDER");return Y},invertBatch:k=>FpInvertBatch(q,k),cmov:(k,B,Y)=>Y?B:k});return Object.freeze(q)}function getFieldBytesLength(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function getMinHashLength(t){const n=getFieldBytesLength(t);return n+Math.ceil(n/2)}function mapHashToField(t,n,r=!1){const s=t.length,o=getFieldBytesLength(n),a=getMinHashLength(n);if(s<16||s<a||s>1024)throw new Error("expected "+a+"-1024 bytes of input, got "+s);const f=r?bytesToNumberLE(t):bytesToNumberBE(t),g=mod(f,n-_1n2)+_1n2;return r?numberToBytesLE(g,o):numberToBytesBE(g,o)}var _0n3=BigInt(0),_1n3=BigInt(1);function negateCt(t,n){const r=n.negate();return t?r:n}function normalizeZ(t,n){const r=FpInvertBatch(t.Fp,n.map(s=>s.Z));return n.map((s,o)=>t.fromAffine(s.toAffine(r[o])))}function validateW(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function calcWOpts(t,n){validateW(t,n);const r=Math.ceil(n/t)+1,s=2**(t-1),o=2**t,a=bitMask(t),f=BigInt(t);return{windows:r,windowSize:s,mask:a,maxNumber:o,shiftBy:f}}function calcOffsets(t,n,r){const{windowSize:s,mask:o,maxNumber:a,shiftBy:f}=r;let g=Number(t&o),_=t>>f;g>s&&(g-=a,_+=_1n3);const P=n*s,b=P+Math.abs(g)-1,q=g===0,k=g<0,B=n%2!==0;return{nextN:_,offset:b,isZero:q,isNeg:k,isNegF:B,offsetF:P}}function validateMSMPoints(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((r,s)=>{if(!(r instanceof n))throw new Error("invalid point at index "+s)})}function validateMSMScalars(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((r,s)=>{if(!n.isValid(r))throw new Error("invalid scalar at index "+s)})}var pointPrecomputes=new WeakMap,pointWindowSizes=new WeakMap;function getW(t){return pointWindowSizes.get(t)||1}function assert0(t){if(t!==_0n3)throw new Error("invalid wNAF")}var wNAF=class{constructor(t,n){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=n}_unsafeLadder(t,n,r=this.ZERO){let s=t;for(;n>_0n3;)n&_1n3&&(r=r.add(s)),s=s.double(),n>>=_1n3;return r}precomputeWindow(t,n){const{windows:r,windowSize:s}=calcWOpts(n,this.bits),o=[];let a=t,f=a;for(let g=0;g<r;g++){f=a,o.push(f);for(let _=1;_<s;_++)f=f.add(a),o.push(f);a=f.double()}return o}wNAF(t,n,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let s=this.ZERO,o=this.BASE;const a=calcWOpts(t,this.bits);for(let f=0;f<a.windows;f++){const{nextN:g,offset:_,isZero:P,isNeg:b,isNegF:q,offsetF:k}=calcOffsets(r,f,a);r=g,P?o=o.add(negateCt(q,n[k])):s=s.add(negateCt(b,n[_]))}return assert0(r),{p:s,f:o}}wNAFUnsafe(t,n,r,s=this.ZERO){const o=calcWOpts(t,this.bits);for(let a=0;a<o.windows&&r!==_0n3;a++){const{nextN:f,offset:g,isZero:_,isNeg:P}=calcOffsets(r,a,o);if(r=f,!_){const b=n[g];s=s.add(P?b.negate():b)}}return assert0(r),s}getPrecomputes(t,n,r){let s=pointPrecomputes.get(n);return s||(s=this.precomputeWindow(n,t),t!==1&&(typeof r=="function"&&(s=r(s)),pointPrecomputes.set(n,s))),s}cached(t,n,r){const s=getW(t);return this.wNAF(s,this.getPrecomputes(s,t,r),n)}unsafe(t,n,r,s){const o=getW(t);return o===1?this._unsafeLadder(t,n,s):this.wNAFUnsafe(o,this.getPrecomputes(o,t,r),n,s)}createCache(t,n){validateW(n,this.bits),pointWindowSizes.set(t,n),pointPrecomputes.delete(t)}hasCache(t){return getW(t)!==1}};function mulEndoUnsafe(t,n,r,s){let o=n,a=t.ZERO,f=t.ZERO;for(;r>_0n3||s>_0n3;)r&_1n3&&(a=a.add(o)),s&_1n3&&(f=f.add(o)),o=o.double(),r>>=_1n3,s>>=_1n3;return{p1:a,p2:f}}function pippenger(t,n,r,s){validateMSMPoints(r,t),validateMSMScalars(s,n);const o=r.length,a=s.length;if(o!==a)throw new Error("arrays of points and scalars must have equal length");const f=t.ZERO,g=bitLen(BigInt(o));let _=1;g>12?_=g-3:g>4?_=g-2:g>0&&(_=2);const P=bitMask(_),b=new Array(Number(P)+1).fill(f),q=Math.floor((n.BITS-1)/_)*_;let k=f;for(let B=q;B>=0;B-=_){b.fill(f);for(let te=0;te<a;te++){const ve=s[te],je=Number(ve>>BigInt(B)&P);b[je]=b[je].add(r[te])}let Y=f;for(let te=b.length-1,ve=f;te>0;te--)ve=ve.add(b[te]),Y=Y.add(ve);if(k=k.add(Y),B!==0)for(let te=0;te<_;te++)k=k.double()}return k}function createField(t,n,r){if(n){if(n.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return validateField(n),n}else return Field(t,{isLE:r})}function _createCurveFields(t,n,r={},s){if(s===void 0&&(s=t==="edwards"),!n||typeof n!="object")throw new Error(`expected valid ${t} CURVE object`);for(const _ of["p","n","h"]){const P=n[_];if(!(typeof P=="bigint"&&P>_0n3))throw new Error(`CURVE.${_} must be positive bigint`)}const o=createField(n.p,r.Fp,s),a=createField(n.n,r.Fn,s),g=["Gx","Gy","a","b"];for(const _ of g)if(!o.isValid(n[_]))throw new Error(`CURVE.${_} must be valid field element of CURVE.Fp`);return n=Object.freeze(Object.assign({},n)),{CURVE:n,Fp:o,Fn:a}}var divNearest=(t,n)=>(t+(t>=0?n:-n)/_2n2)/n;function _splitEndoScalar(t,n,r){const[[s,o],[a,f]]=n,g=divNearest(f*t,r),_=divNearest(-o*t,r);let P=t-g*s-_*a,b=-g*o-_*f;const q=P<_0n4,k=b<_0n4;q&&(P=-P),k&&(b=-b);const B=bitMask(Math.ceil(bitLen(r)/2))+_1n4;if(P<_0n4||P>=B||b<_0n4||b>=B)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:q,k1:P,k2neg:k,k2:b}}function validateSigFormat(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function validateSigOpts(t,n){const r={};for(let s of Object.keys(n))r[s]=t[s]===void 0?n[s]:t[s];return _abool2(r.lowS,"lowS"),_abool2(r.prehash,"prehash"),r.format!==void 0&&validateSigFormat(r.format),r}var DERErr=class extends Error{constructor(t=""){super(t)}},DER={Err:DERErr,_tlv:{encode:(t,n)=>{const{Err:r}=DER;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(n.length&1)throw new r("tlv.encode: unpadded data");const s=n.length/2,o=numberToHexUnpadded(s);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const a=s>127?numberToHexUnpadded(o.length/2|128):"";return numberToHexUnpadded(t)+a+o+n},decode(t,n){const{Err:r}=DER;let s=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(n.length<2||n[s++]!==t)throw new r("tlv.decode: wrong tlv");const o=n[s++],a=!!(o&128);let f=0;if(!a)f=o;else{const _=o&127;if(!_)throw new r("tlv.decode(long): indefinite length not supported");if(_>4)throw new r("tlv.decode(long): byte length is too big");const P=n.subarray(s,s+_);if(P.length!==_)throw new r("tlv.decode: length bytes not complete");if(P[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const b of P)f=f<<8|b;if(s+=_,f<128)throw new r("tlv.decode(long): not minimal encoding")}const g=n.subarray(s,s+f);if(g.length!==f)throw new r("tlv.decode: wrong value length");return{v:g,l:n.subarray(s+f)}}},_int:{encode(t){const{Err:n}=DER;if(t<_0n4)throw new n("integer: negative integers are not allowed");let r=numberToHexUnpadded(t);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:n}=DER;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return bytesToNumberBE(t)}},toSig(t){const{Err:n,_int:r,_tlv:s}=DER,o=ensureBytes("signature",t),{v:a,l:f}=s.decode(48,o);if(f.length)throw new n("invalid signature: left bytes after parsing");const{v:g,l:_}=s.decode(2,a),{v:P,l:b}=s.decode(2,_);if(b.length)throw new n("invalid signature: left bytes after parsing");return{r:r.decode(g),s:r.decode(P)}},hexFromSig(t){const{_tlv:n,_int:r}=DER,s=n.encode(2,r.encode(t.r)),o=n.encode(2,r.encode(t.s)),a=s+o;return n.encode(48,a)}},_0n4=BigInt(0),_1n4=BigInt(1),_2n2=BigInt(2),_3n2=BigInt(3),_4n2=BigInt(4);function _normFnElement(t,n){const{BYTES:r}=t;let s;if(typeof n=="bigint")s=n;else{let o=ensureBytes("private key",n);try{s=t.fromBytes(o)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof n}`)}}if(!t.isValidNot0(s))throw new Error("invalid private key: out of range [1..N-1]");return s}function weierstrassN(t,n={}){const r=_createCurveFields("weierstrass",t,n),{Fp:s,Fn:o}=r;let a=r.CURVE;const{h:f,n:g}=a;_validateObject(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:_}=n;if(_&&(!s.is0(a.a)||typeof _.beta!="bigint"||!Array.isArray(_.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const P=getWLengths(s,o);function b(){if(!s.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function q(X,L,Z){const{x:ne,y:Le}=L.toAffine(),We=s.toBytes(ne);if(_abool2(Z,"isCompressed"),Z){b();const nt=!s.isOdd(Le);return concatBytes(pprefix(nt),We)}else return concatBytes(Uint8Array.of(4),We,s.toBytes(Le))}function k(X){_abytes2(X,void 0,"Point");const{publicKey:L,publicKeyUncompressed:Z}=P,ne=X.length,Le=X[0],We=X.subarray(1);if(ne===L&&(Le===2||Le===3)){const nt=s.fromBytes(We);if(!s.isValid(nt))throw new Error("bad point: is not on curve, wrong x");const Je=te(nt);let rt;try{rt=s.sqrt(Je)}catch(ht){const ot=ht instanceof Error?": "+ht.message:"";throw new Error("bad point: is not on curve, sqrt error"+ot)}b();const Qe=s.isOdd(rt);return(Le&1)===1!==Qe&&(rt=s.neg(rt)),{x:nt,y:rt}}else if(ne===Z&&Le===4){const nt=s.BYTES,Je=s.fromBytes(We.subarray(0,nt)),rt=s.fromBytes(We.subarray(nt,nt*2));if(!ve(Je,rt))throw new Error("bad point: is not on curve");return{x:Je,y:rt}}else throw new Error(`bad point: got length ${ne}, expected compressed=${L} or uncompressed=${Z}`)}const B=n.toBytes||q,Y=n.fromBytes||k;function te(X){const L=s.sqr(X),Z=s.mul(L,X);return s.add(s.add(Z,s.mul(X,a.a)),a.b)}function ve(X,L){const Z=s.sqr(L),ne=te(X);return s.eql(Z,ne)}if(!ve(a.Gx,a.Gy))throw new Error("bad curve params: generator point");const je=s.mul(s.pow(a.a,_3n2),_4n2),Ve=s.mul(s.sqr(a.b),BigInt(27));if(s.is0(s.add(je,Ve)))throw new Error("bad curve params: a or b");function $e(X,L,Z=!1){if(!s.isValid(L)||Z&&s.is0(L))throw new Error(`bad point coordinate ${X}`);return L}function He(X){if(!(X instanceof Ce))throw new Error("ProjectivePoint expected")}function Ge(X){if(!_||!_.basises)throw new Error("no endo");return _splitEndoScalar(X,_.basises,o.ORDER)}const ee=memoized((X,L)=>{const{X:Z,Y:ne,Z:Le}=X;if(s.eql(Le,s.ONE))return{x:Z,y:ne};const We=X.is0();L==null&&(L=We?s.ONE:s.inv(Le));const nt=s.mul(Z,L),Je=s.mul(ne,L),rt=s.mul(Le,L);if(We)return{x:s.ZERO,y:s.ZERO};if(!s.eql(rt,s.ONE))throw new Error("invZ was invalid");return{x:nt,y:Je}}),oe=memoized(X=>{if(X.is0()){if(n.allowInfinityPoint&&!s.is0(X.Y))return;throw new Error("bad point: ZERO")}const{x:L,y:Z}=X.toAffine();if(!s.isValid(L)||!s.isValid(Z))throw new Error("bad point: x or y not field elements");if(!ve(L,Z))throw new Error("bad point: equation left != right");if(!X.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Ue(X,L,Z,ne,Le){return Z=new Ce(s.mul(Z.X,X),Z.Y,Z.Z),L=negateCt(ne,L),Z=negateCt(Le,Z),L.add(Z)}class Ce{constructor(L,Z,ne){this.X=$e("x",L),this.Y=$e("y",Z,!0),this.Z=$e("z",ne),Object.freeze(this)}static CURVE(){return a}static fromAffine(L){const{x:Z,y:ne}=L||{};if(!L||!s.isValid(Z)||!s.isValid(ne))throw new Error("invalid affine point");if(L instanceof Ce)throw new Error("projective point not allowed");return s.is0(Z)&&s.is0(ne)?Ce.ZERO:new Ce(Z,ne,s.ONE)}static fromBytes(L){const Z=Ce.fromAffine(Y(_abytes2(L,void 0,"point")));return Z.assertValidity(),Z}static fromHex(L){return Ce.fromBytes(ensureBytes("pointHex",L))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(L=8,Z=!0){return re.createCache(this,L),Z||this.multiply(_3n2),this}assertValidity(){oe(this)}hasEvenY(){const{y:L}=this.toAffine();if(!s.isOdd)throw new Error("Field doesn't support isOdd");return!s.isOdd(L)}equals(L){He(L);const{X:Z,Y:ne,Z:Le}=this,{X:We,Y:nt,Z:Je}=L,rt=s.eql(s.mul(Z,Je),s.mul(We,Le)),Qe=s.eql(s.mul(ne,Je),s.mul(nt,Le));return rt&&Qe}negate(){return new Ce(this.X,s.neg(this.Y),this.Z)}double(){const{a:L,b:Z}=a,ne=s.mul(Z,_3n2),{X:Le,Y:We,Z:nt}=this;let Je=s.ZERO,rt=s.ZERO,Qe=s.ZERO,st=s.mul(Le,Le),ht=s.mul(We,We),ot=s.mul(nt,nt),ut=s.mul(Le,We);return ut=s.add(ut,ut),Qe=s.mul(Le,nt),Qe=s.add(Qe,Qe),Je=s.mul(L,Qe),rt=s.mul(ne,ot),rt=s.add(Je,rt),Je=s.sub(ht,rt),rt=s.add(ht,rt),rt=s.mul(Je,rt),Je=s.mul(ut,Je),Qe=s.mul(ne,Qe),ot=s.mul(L,ot),ut=s.sub(st,ot),ut=s.mul(L,ut),ut=s.add(ut,Qe),Qe=s.add(st,st),st=s.add(Qe,st),st=s.add(st,ot),st=s.mul(st,ut),rt=s.add(rt,st),ot=s.mul(We,nt),ot=s.add(ot,ot),st=s.mul(ot,ut),Je=s.sub(Je,st),Qe=s.mul(ot,ht),Qe=s.add(Qe,Qe),Qe=s.add(Qe,Qe),new Ce(Je,rt,Qe)}add(L){He(L);const{X:Z,Y:ne,Z:Le}=this,{X:We,Y:nt,Z:Je}=L;let rt=s.ZERO,Qe=s.ZERO,st=s.ZERO;const ht=a.a,ot=s.mul(a.b,_3n2);let ut=s.mul(Z,We),_t=s.mul(ne,nt),lt=s.mul(Le,Je),Bt=s.add(Z,ne),St=s.add(We,nt);Bt=s.mul(Bt,St),St=s.add(ut,_t),Bt=s.sub(Bt,St),St=s.add(Z,Le);let qt=s.add(We,Je);return St=s.mul(St,qt),qt=s.add(ut,lt),St=s.sub(St,qt),qt=s.add(ne,Le),rt=s.add(nt,Je),qt=s.mul(qt,rt),rt=s.add(_t,lt),qt=s.sub(qt,rt),st=s.mul(ht,St),rt=s.mul(ot,lt),st=s.add(rt,st),rt=s.sub(_t,st),st=s.add(_t,st),Qe=s.mul(rt,st),_t=s.add(ut,ut),_t=s.add(_t,ut),lt=s.mul(ht,lt),St=s.mul(ot,St),_t=s.add(_t,lt),lt=s.sub(ut,lt),lt=s.mul(ht,lt),St=s.add(St,lt),ut=s.mul(_t,St),Qe=s.add(Qe,ut),ut=s.mul(qt,St),rt=s.mul(Bt,rt),rt=s.sub(rt,ut),ut=s.mul(Bt,_t),st=s.mul(qt,st),st=s.add(st,ut),new Ce(rt,Qe,st)}subtract(L){return this.add(L.negate())}is0(){return this.equals(Ce.ZERO)}multiply(L){const{endo:Z}=n;if(!o.isValidNot0(L))throw new Error("invalid scalar: out of range");let ne,Le;const We=nt=>re.cached(this,nt,Je=>normalizeZ(Ce,Je));if(Z){const{k1neg:nt,k1:Je,k2neg:rt,k2:Qe}=Ge(L),{p:st,f:ht}=We(Je),{p:ot,f:ut}=We(Qe);Le=ht.add(ut),ne=Ue(Z.beta,st,ot,nt,rt)}else{const{p:nt,f:Je}=We(L);ne=nt,Le=Je}return normalizeZ(Ce,[ne,Le])[0]}multiplyUnsafe(L){const{endo:Z}=n,ne=this;if(!o.isValid(L))throw new Error("invalid scalar: out of range");if(L===_0n4||ne.is0())return Ce.ZERO;if(L===_1n4)return ne;if(re.hasCache(this))return this.multiply(L);if(Z){const{k1neg:Le,k1:We,k2neg:nt,k2:Je}=Ge(L),{p1:rt,p2:Qe}=mulEndoUnsafe(Ce,ne,We,Je);return Ue(Z.beta,rt,Qe,Le,nt)}else return re.unsafe(ne,L)}multiplyAndAddUnsafe(L,Z,ne){const Le=this.multiplyUnsafe(Z).add(L.multiplyUnsafe(ne));return Le.is0()?void 0:Le}toAffine(L){return ee(this,L)}isTorsionFree(){const{isTorsionFree:L}=n;return f===_1n4?!0:L?L(Ce,this):re.unsafe(this,g).is0()}clearCofactor(){const{clearCofactor:L}=n;return f===_1n4?this:L?L(Ce,this):this.multiplyUnsafe(f)}isSmallOrder(){return this.multiplyUnsafe(f).is0()}toBytes(L=!0){return _abool2(L,"isCompressed"),this.assertValidity(),B(Ce,this,L)}toHex(L=!0){return bytesToHex(this.toBytes(L))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(L=!0){return this.toBytes(L)}_setWindowSize(L){this.precompute(L)}static normalizeZ(L){return normalizeZ(Ce,L)}static msm(L,Z){return pippenger(Ce,o,L,Z)}static fromPrivateKey(L){return Ce.BASE.multiply(_normFnElement(o,L))}}Ce.BASE=new Ce(a.Gx,a.Gy,s.ONE),Ce.ZERO=new Ce(s.ZERO,s.ONE,s.ZERO),Ce.Fp=s,Ce.Fn=o;const Xe=o.BITS,re=new wNAF(Ce,n.endo?Math.ceil(Xe/2):Xe);return Ce.BASE.precompute(8),Ce}function pprefix(t){return Uint8Array.of(t?2:3)}function getWLengths(t,n){return{secretKey:n.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*n.BYTES}}function ecdh(t,n={}){const{Fn:r}=t,s=n.randomBytes||randomBytes,o=Object.assign(getWLengths(t.Fp,r),{seed:getMinHashLength(r.ORDER)});function a(B){try{return!!_normFnElement(r,B)}catch{return!1}}function f(B,Y){const{publicKey:te,publicKeyUncompressed:ve}=o;try{const je=B.length;return Y===!0&&je!==te||Y===!1&&je!==ve?!1:!!t.fromBytes(B)}catch{return!1}}function g(B=s(o.seed)){return mapHashToField(_abytes2(B,o.seed,"seed"),r.ORDER)}function _(B,Y=!0){return t.BASE.multiply(_normFnElement(r,B)).toBytes(Y)}function P(B){const Y=g(B);return{secretKey:Y,publicKey:_(Y)}}function b(B){if(typeof B=="bigint")return!1;if(B instanceof t)return!0;const{secretKey:Y,publicKey:te,publicKeyUncompressed:ve}=o;if(r.allowedLengths||Y===te)return;const je=ensureBytes("key",B).length;return je===te||je===ve}function q(B,Y,te=!0){if(b(B)===!0)throw new Error("first arg must be private key");if(b(Y)===!1)throw new Error("second arg must be public key");const ve=_normFnElement(r,B);return t.fromHex(Y).multiply(ve).toBytes(te)}return Object.freeze({getPublicKey:_,getSharedSecret:q,keygen:P,Point:t,utils:{isValidSecretKey:a,isValidPublicKey:f,randomSecretKey:g,isValidPrivateKey:a,randomPrivateKey:g,normPrivateKeyToScalar:B=>_normFnElement(r,B),precompute(B=8,Y=t.BASE){return Y.precompute(B,!1)}},lengths:o})}function ecdsa(t,n,r={}){ahash(n),_validateObject(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const s=r.randomBytes||randomBytes,o=r.hmac||((Z,...ne)=>hmac(n,Z,concatBytes(...ne))),{Fp:a,Fn:f}=t,{ORDER:g,BITS:_}=f,{keygen:P,getPublicKey:b,getSharedSecret:q,utils:k,lengths:B}=ecdh(t,r),Y={prehash:!1,lowS:typeof r.lowS=="boolean"?r.lowS:!1,format:void 0,extraEntropy:!1},te="compact";function ve(Z){const ne=g>>_1n4;return Z>ne}function je(Z,ne){if(!f.isValidNot0(ne))throw new Error(`invalid signature ${Z}: out of range 1..Point.Fn.ORDER`);return ne}function Ve(Z,ne){validateSigFormat(ne);const Le=B.signature,We=ne==="compact"?Le:ne==="recovered"?Le+1:void 0;return _abytes2(Z,We,`${ne} signature`)}class $e{constructor(ne,Le,We){this.r=je("r",ne),this.s=je("s",Le),We!=null&&(this.recovery=We),Object.freeze(this)}static fromBytes(ne,Le=te){Ve(ne,Le);let We;if(Le==="der"){const{r:Qe,s:st}=DER.toSig(_abytes2(ne));return new $e(Qe,st)}Le==="recovered"&&(We=ne[0],Le="compact",ne=ne.subarray(1));const nt=f.BYTES,Je=ne.subarray(0,nt),rt=ne.subarray(nt,nt*2);return new $e(f.fromBytes(Je),f.fromBytes(rt),We)}static fromHex(ne,Le){return this.fromBytes(hexToBytes(ne),Le)}addRecoveryBit(ne){return new $e(this.r,this.s,ne)}recoverPublicKey(ne){const Le=a.ORDER,{r:We,s:nt,recovery:Je}=this;if(Je==null||![0,1,2,3].includes(Je))throw new Error("recovery id invalid");if(g*_2n2<Le&&Je>1)throw new Error("recovery id is ambiguous for h>1 curve");const Qe=Je===2||Je===3?We+g:We;if(!a.isValid(Qe))throw new Error("recovery id 2 or 3 invalid");const st=a.toBytes(Qe),ht=t.fromBytes(concatBytes(pprefix((Je&1)===0),st)),ot=f.inv(Qe),ut=Ge(ensureBytes("msgHash",ne)),_t=f.create(-ut*ot),lt=f.create(nt*ot),Bt=t.BASE.multiplyUnsafe(_t).add(ht.multiplyUnsafe(lt));if(Bt.is0())throw new Error("point at infinify");return Bt.assertValidity(),Bt}hasHighS(){return ve(this.s)}toBytes(ne=te){if(validateSigFormat(ne),ne==="der")return hexToBytes(DER.hexFromSig(this));const Le=f.toBytes(this.r),We=f.toBytes(this.s);if(ne==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return concatBytes(Uint8Array.of(this.recovery),Le,We)}return concatBytes(Le,We)}toHex(ne){return bytesToHex(this.toBytes(ne))}assertValidity(){}static fromCompact(ne){return $e.fromBytes(ensureBytes("sig",ne),"compact")}static fromDER(ne){return $e.fromBytes(ensureBytes("sig",ne),"der")}normalizeS(){return this.hasHighS()?new $e(this.r,f.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return bytesToHex(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return bytesToHex(this.toBytes("compact"))}}const He=r.bits2int||function(ne){if(ne.length>8192)throw new Error("input is too large");const Le=bytesToNumberBE(ne),We=ne.length*8-_;return We>0?Le>>BigInt(We):Le},Ge=r.bits2int_modN||function(ne){return f.create(He(ne))},ee=bitMask(_);function oe(Z){return aInRange("num < 2^"+_,Z,_0n4,ee),f.toBytes(Z)}function Ue(Z,ne){return _abytes2(Z,void 0,"message"),ne?_abytes2(n(Z),void 0,"prehashed message"):Z}function Ce(Z,ne,Le){if(["recovered","canonical"].some(_t=>_t in Le))throw new Error("sign() legacy options not supported");const{lowS:We,prehash:nt,extraEntropy:Je}=validateSigOpts(Le,Y);Z=Ue(Z,nt);const rt=Ge(Z),Qe=_normFnElement(f,ne),st=[oe(Qe),oe(rt)];if(Je!=null&&Je!==!1){const _t=Je===!0?s(B.secretKey):Je;st.push(ensureBytes("extraEntropy",_t))}const ht=concatBytes(...st),ot=rt;function ut(_t){const lt=He(_t);if(!f.isValidNot0(lt))return;const Bt=f.inv(lt),St=t.BASE.multiply(lt).toAffine(),qt=f.create(St.x);if(qt===_0n4)return;const Zt=f.create(Bt*f.create(ot+qt*Qe));if(Zt===_0n4)return;let en=(St.x===qt?0:2)|Number(St.y&_1n4),rn=Zt;return We&&ve(Zt)&&(rn=f.neg(Zt),en^=1),new $e(qt,rn,en)}return{seed:ht,k2sig:ut}}function Xe(Z,ne,Le={}){Z=ensureBytes("message",Z);const{seed:We,k2sig:nt}=Ce(Z,ne,Le);return createHmacDrbg(n.outputLen,f.BYTES,o)(We,nt)}function re(Z){let ne;const Le=typeof Z=="string"||isBytes(Z),We=!Le&&Z!==null&&typeof Z=="object"&&typeof Z.r=="bigint"&&typeof Z.s=="bigint";if(!Le&&!We)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(We)ne=new $e(Z.r,Z.s);else if(Le){try{ne=$e.fromBytes(ensureBytes("sig",Z),"der")}catch(nt){if(!(nt instanceof DER.Err))throw nt}if(!ne)try{ne=$e.fromBytes(ensureBytes("sig",Z),"compact")}catch{return!1}}return ne||!1}function X(Z,ne,Le,We={}){const{lowS:nt,prehash:Je,format:rt}=validateSigOpts(We,Y);if(Le=ensureBytes("publicKey",Le),ne=Ue(ensureBytes("message",ne),Je),"strict"in We)throw new Error("options.strict was renamed to lowS");const Qe=rt===void 0?re(Z):$e.fromBytes(ensureBytes("sig",Z),rt);if(Qe===!1)return!1;try{const st=t.fromBytes(Le);if(nt&&Qe.hasHighS())return!1;const{r:ht,s:ot}=Qe,ut=Ge(ne),_t=f.inv(ot),lt=f.create(ut*_t),Bt=f.create(ht*_t),St=t.BASE.multiplyUnsafe(lt).add(st.multiplyUnsafe(Bt));return St.is0()?!1:f.create(St.x)===ht}catch{return!1}}function L(Z,ne,Le={}){const{prehash:We}=validateSigOpts(Le,Y);return ne=Ue(ne,We),$e.fromBytes(Z,"recovered").recoverPublicKey(ne).toBytes()}return Object.freeze({keygen:P,getPublicKey:b,getSharedSecret:q,utils:k,lengths:B,Point:t,sign:Xe,verify:X,recoverPublicKey:L,Signature:$e,hash:n})}function _weierstrass_legacy_opts_to_new(t){const n={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r=t.Fp;let s=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map(f=>Math.ceil(f/2)))):void 0;const o=Field(n.n,{BITS:t.nBitLength,allowedLengths:s,modFromBytes:t.wrapPrivateKey}),a={Fp:r,Fn:o,allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes};return{CURVE:n,curveOpts:a}}function _ecdsa_legacy_opts_to_new(t){const{CURVE:n,curveOpts:r}=_weierstrass_legacy_opts_to_new(t),s={hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:n,curveOpts:r,hash:t.hash,ecdsaOpts:s}}function _ecdsa_new_output_to_legacy(t,n){const r=n.Point;return Object.assign({},n,{ProjectivePoint:r,CURVE:Object.assign({},t,nLength(r.Fn.ORDER,r.Fn.BITS))})}function weierstrass(t){const{CURVE:n,curveOpts:r,hash:s,ecdsaOpts:o}=_ecdsa_legacy_opts_to_new(t),a=weierstrassN(n,r),f=ecdsa(a,s,o);return _ecdsa_new_output_to_legacy(t,f)}function createCurve(t,n){const r=s=>weierstrass({...t,hash:s});return{...r(n),create:r}}var secp256k1_CURVE={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},secp256k1_ENDO={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},_0n5=BigInt(0),_1n5=BigInt(1),_2n3=BigInt(2);function sqrtMod(t){const n=secp256k1_CURVE.p,r=BigInt(3),s=BigInt(6),o=BigInt(11),a=BigInt(22),f=BigInt(23),g=BigInt(44),_=BigInt(88),P=t*t*t%n,b=P*P*t%n,q=pow2(b,r,n)*b%n,k=pow2(q,r,n)*b%n,B=pow2(k,_2n3,n)*P%n,Y=pow2(B,o,n)*B%n,te=pow2(Y,a,n)*Y%n,ve=pow2(te,g,n)*te%n,je=pow2(ve,_,n)*ve%n,Ve=pow2(je,g,n)*te%n,$e=pow2(Ve,r,n)*b%n,He=pow2($e,f,n)*Y%n,Ge=pow2(He,s,n)*P%n,ee=pow2(Ge,_2n3,n);if(!Fpk1.eql(Fpk1.sqr(ee),t))throw new Error("Cannot find square root");return ee}var Fpk1=Field(secp256k1_CURVE.p,{sqrt:sqrtMod}),secp256k1=createCurve({...secp256k1_CURVE,Fp:Fpk1,lowS:!0,endo:secp256k1_ENDO},sha256),TAGGED_HASH_PREFIXES={};function taggedHash(t,...n){let r=TAGGED_HASH_PREFIXES[t];if(r===void 0){const s=sha256(utf8ToBytes(t));r=concatBytes(s,s),TAGGED_HASH_PREFIXES[t]=r}return sha256(concatBytes(r,...n))}var pointToBytes=t=>t.toBytes(!0).slice(1),Pointk1=secp256k1.Point,hasEven=t=>t%_2n3===_0n5;function schnorrGetExtPubKey(t){const{Fn:n,BASE:r}=Pointk1,s=_normFnElement(n,t),o=r.multiply(s);return{scalar:hasEven(o.y)?s:n.neg(s),bytes:pointToBytes(o)}}function lift_x(t){const n=Fpk1;if(!n.isValidNot0(t))throw new Error("invalid x: Fail if x  p");const r=n.create(t*t),s=n.create(r*t+BigInt(7));let o=n.sqrt(s);hasEven(o)||(o=n.neg(o));const a=Pointk1.fromAffine({x:t,y:o});return a.assertValidity(),a}var num=bytesToNumberBE;function challenge(...t){return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge",...t)))}function schnorrGetPublicKey(t){return schnorrGetExtPubKey(t).bytes}function schnorrSign(t,n,r=randomBytes(32)){const{Fn:s}=Pointk1,o=ensureBytes("message",t),{bytes:a,scalar:f}=schnorrGetExtPubKey(n),g=ensureBytes("auxRand",r,32),_=s.toBytes(f^num(taggedHash("BIP0340/aux",g))),P=taggedHash("BIP0340/nonce",_,a,o),{bytes:b,scalar:q}=schnorrGetExtPubKey(P),k=challenge(b,a,o),B=new Uint8Array(64);if(B.set(b,0),B.set(s.toBytes(s.create(q+k*f)),32),!schnorrVerify(B,o,a))throw new Error("sign: Invalid signature produced");return B}function schnorrVerify(t,n,r){const{Fn:s,BASE:o}=Pointk1,a=ensureBytes("signature",t,64),f=ensureBytes("message",n),g=ensureBytes("publicKey",r,32);try{const _=lift_x(num(g)),P=num(a.subarray(0,32));if(!inRange(P,_1n5,secp256k1_CURVE.p))return!1;const b=num(a.subarray(32,64));if(!inRange(b,_1n5,secp256k1_CURVE.n))return!1;const q=challenge(s.toBytes(P),pointToBytes(_),f),k=o.multiplyUnsafe(b).add(_.multiplyUnsafe(s.neg(q))),{x:B,y:Y}=k.toAffine();return!(k.is0()||!hasEven(Y)||B!==P)}catch{return!1}}var schnorr=(()=>{const r=(o=randomBytes(48))=>mapHashToField(o,secp256k1_CURVE.n);secp256k1.utils.randomSecretKey;function s(o){const a=r(o);return{secretKey:a,publicKey:schnorrGetPublicKey(a)}}return{keygen:s,getPublicKey:schnorrGetPublicKey,sign:schnorrSign,verify:schnorrVerify,Point:Pointk1,utils:{randomSecretKey:r,randomPrivateKey:r,taggedHash,lift_x,pointToBytes,numberToBytesBE,bytesToNumberBE,mod},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),sha2562=sha256,bytesToHex2=bytesToHex,hexToBytes2=hexToBytes,fr={},G={};G.byteLength=Dr;G.toByteArray=Pr;G.fromByteArray=Wr;var S=[],R=[],br=typeof Uint8Array<"u"?Uint8Array:Array,z="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(D2=0,kr=z.length;D2<kr;++D2)S[D2]=z[D2],R[z.charCodeAt(D2)]=D2;var D2,kr;R[45]=62;R[95]=63;function pr(t){var n=t.length;if(n%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");r===-1&&(r=n);var s=r===n?0:4-r%4;return[r,s]}function Dr(t){var n=pr(t),r=n[0],s=n[1];return(r+s)*3/4-s}function $r(t,n,r){return(n+r)*3/4-r}function Pr(t){var n,r=pr(t),s=r[0],o=r[1],a=new br($r(t,s,o)),f=0,g=o>0?s-4:s,_;for(_=0;_<g;_+=4)n=R[t.charCodeAt(_)]<<18|R[t.charCodeAt(_+1)]<<12|R[t.charCodeAt(_+2)]<<6|R[t.charCodeAt(_+3)],a[f++]=n>>16&255,a[f++]=n>>8&255,a[f++]=n&255;return o===2&&(n=R[t.charCodeAt(_)]<<2|R[t.charCodeAt(_+1)]>>4,a[f++]=n&255),o===1&&(n=R[t.charCodeAt(_)]<<10|R[t.charCodeAt(_+1)]<<4|R[t.charCodeAt(_+2)]>>2,a[f++]=n>>8&255,a[f++]=n&255),a}function Or(t){return S[t>>18&63]+S[t>>12&63]+S[t>>6&63]+S[t&63]}function Gr(t,n,r){for(var s,o=[],a=n;a<r;a+=3)s=(t[a]<<16&16711680)+(t[a+1]<<8&65280)+(t[a+2]&255),o.push(Or(s));return o.join("")}function Wr(t){for(var n,r=t.length,s=r%3,o=[],a=16383,f=0,g=r-s;f<g;f+=a)o.push(Gr(t,f,f+a>g?g:f+a));return s===1?(n=t[r-1],o.push(S[n>>2]+S[n<<4&63]+"==")):s===2&&(n=(t[r-2]<<8)+t[r-1],o.push(S[n>>10]+S[n>>4&63]+S[n<<2&63]+"=")),o.join("")}var J={};J.read=function(t,n,r,s,o){var a,f,g=o*8-s-1,_=(1<<g)-1,P=_>>1,b=-7,q=r?o-1:0,k=r?-1:1,B=t[n+q];for(q+=k,a=B&(1<<-b)-1,B>>=-b,b+=g;b>0;a=a*256+t[n+q],q+=k,b-=8);for(f=a&(1<<-b)-1,a>>=-b,b+=s;b>0;f=f*256+t[n+q],q+=k,b-=8);if(a===0)a=1-P;else{if(a===_)return f?NaN:(B?-1:1)*(1/0);f=f+Math.pow(2,s),a=a-P}return(B?-1:1)*f*Math.pow(2,a-s)};J.write=function(t,n,r,s,o,a){var f,g,_,P=a*8-o-1,b=(1<<P)-1,q=b>>1,k=o===23?Math.pow(2,-24)-Math.pow(2,-77):0,B=s?0:a-1,Y=s?1:-1,te=n<0||n===0&&1/n<0?1:0;for(n=Math.abs(n),isNaN(n)||n===1/0?(g=isNaN(n)?1:0,f=b):(f=Math.floor(Math.log(n)/Math.LN2),n*(_=Math.pow(2,-f))<1&&(f--,_*=2),f+q>=1?n+=k/_:n+=k*Math.pow(2,1-q),n*_>=2&&(f++,_/=2),f+q>=b?(g=0,f=b):f+q>=1?(g=(n*_-1)*Math.pow(2,o),f=f+q):(g=n*Math.pow(2,q-1)*Math.pow(2,o),f=0));o>=8;t[r+B]=g&255,B+=Y,g/=256,o-=8);for(f=f<<o|g,P+=o;P>0;t[r+B]=f&255,B+=Y,f/=256,P-=8);t[r+B-Y]|=te*128};(function(t){const n=G,r=J,s=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;t.Buffer=b,t.SlowBuffer=Ge,t.INSPECT_MAX_BYTES=50;const o=2147483647;t.kMaxLength=o;const{Uint8Array:a,ArrayBuffer:f,SharedArrayBuffer:g}=globalThis;b.TYPED_ARRAY_SUPPORT=_(),!b.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function _(){try{const c=new a(1),m={foo:function(){return 42}};return Object.setPrototypeOf(m,a.prototype),Object.setPrototypeOf(c,m),c.foo()===42}catch{return!1}}Object.defineProperty(b.prototype,"parent",{enumerable:!0,get:function(){if(b.isBuffer(this))return this.buffer}}),Object.defineProperty(b.prototype,"offset",{enumerable:!0,get:function(){if(b.isBuffer(this))return this.byteOffset}});function P(c){if(c>o)throw new RangeError('The value "'+c+'" is invalid for option "size"');const m=new a(c);return Object.setPrototypeOf(m,b.prototype),m}function b(c,m,A){if(typeof c=="number"){if(typeof m=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return Y(c)}return q(c,m,A)}b.poolSize=8192;function q(c,m,A){if(typeof c=="string")return te(c,m);if(f.isView(c))return je(c);if(c==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof c);if(Jt(c,f)||c&&Jt(c.buffer,f)||typeof g<"u"&&(Jt(c,g)||c&&Jt(c.buffer,g)))return Ve(c,m,A);if(typeof c=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const Q=c.valueOf&&c.valueOf();if(Q!=null&&Q!==c)return b.from(Q,m,A);const se=$e(c);if(se)return se;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof c[Symbol.toPrimitive]=="function")return b.from(c[Symbol.toPrimitive]("string"),m,A);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof c)}b.from=function(c,m,A){return q(c,m,A)},Object.setPrototypeOf(b.prototype,a.prototype),Object.setPrototypeOf(b,a);function k(c){if(typeof c!="number")throw new TypeError('"size" argument must be of type number');if(c<0)throw new RangeError('The value "'+c+'" is invalid for option "size"')}function B(c,m,A){return k(c),c<=0?P(c):m!==void 0?typeof A=="string"?P(c).fill(m,A):P(c).fill(m):P(c)}b.alloc=function(c,m,A){return B(c,m,A)};function Y(c){return k(c),P(c<0?0:He(c)|0)}b.allocUnsafe=function(c){return Y(c)},b.allocUnsafeSlow=function(c){return Y(c)};function te(c,m){if((typeof m!="string"||m==="")&&(m="utf8"),!b.isEncoding(m))throw new TypeError("Unknown encoding: "+m);const A=ee(c,m)|0;let Q=P(A);const se=Q.write(c,m);return se!==A&&(Q=Q.slice(0,se)),Q}function ve(c){const m=c.length<0?0:He(c.length)|0,A=P(m);for(let Q=0;Q<m;Q+=1)A[Q]=c[Q]&255;return A}function je(c){if(Jt(c,a)){const m=new a(c);return Ve(m.buffer,m.byteOffset,m.byteLength)}return ve(c)}function Ve(c,m,A){if(m<0||c.byteLength<m)throw new RangeError('"offset" is outside of buffer bounds');if(c.byteLength<m+(A||0))throw new RangeError('"length" is outside of buffer bounds');let Q;return m===void 0&&A===void 0?Q=new a(c):A===void 0?Q=new a(c,m):Q=new a(c,m,A),Object.setPrototypeOf(Q,b.prototype),Q}function $e(c){if(b.isBuffer(c)){const m=He(c.length)|0,A=P(m);return A.length===0||c.copy(A,0,0,m),A}if(c.length!==void 0)return typeof c.length!="number"||ln(c.length)?P(0):ve(c);if(c.type==="Buffer"&&Array.isArray(c.data))return ve(c.data)}function He(c){if(c>=o)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o.toString(16)+" bytes");return c|0}function Ge(c){return+c!=c&&(c=0),b.alloc(+c)}b.isBuffer=function(c){return c!=null&&c._isBuffer===!0&&c!==b.prototype},b.compare=function(c,m){if(Jt(c,a)&&(c=b.from(c,c.offset,c.byteLength)),Jt(m,a)&&(m=b.from(m,m.offset,m.byteLength)),!b.isBuffer(c)||!b.isBuffer(m))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(c===m)return 0;let A=c.length,Q=m.length;for(let se=0,ze=Math.min(A,Q);se<ze;++se)if(c[se]!==m[se]){A=c[se],Q=m[se];break}return A<Q?-1:Q<A?1:0},b.isEncoding=function(c){switch(String(c).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},b.concat=function(c,m){if(!Array.isArray(c))throw new TypeError('"list" argument must be an Array of Buffers');if(c.length===0)return b.alloc(0);let A;if(m===void 0)for(m=0,A=0;A<c.length;++A)m+=c[A].length;const Q=b.allocUnsafe(m);let se=0;for(A=0;A<c.length;++A){let ze=c[A];if(Jt(ze,a))se+ze.length>Q.length?(b.isBuffer(ze)||(ze=b.from(ze)),ze.copy(Q,se)):a.prototype.set.call(Q,ze,se);else if(b.isBuffer(ze))ze.copy(Q,se);else throw new TypeError('"list" argument must be an Array of Buffers');se+=ze.length}return Q};function ee(c,m){if(b.isBuffer(c))return c.length;if(f.isView(c)||Jt(c,f))return c.byteLength;if(typeof c!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof c);const A=c.length,Q=arguments.length>2&&arguments[2]===!0;if(!Q&&A===0)return 0;let se=!1;for(;;)switch(m){case"ascii":case"latin1":case"binary":return A;case"utf8":case"utf-8":return un(c).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return A*2;case"hex":return A>>>1;case"base64":return dn(c).length;default:if(se)return Q?-1:un(c).length;m=(""+m).toLowerCase(),se=!0}}b.byteLength=ee;function oe(c,m,A){let Q=!1;if((m===void 0||m<0)&&(m=0),m>this.length||((A===void 0||A>this.length)&&(A=this.length),A<=0)||(A>>>=0,m>>>=0,A<=m))return"";for(c||(c="utf8");;)switch(c){case"hex":return st(this,m,A);case"utf8":case"utf-8":return We(this,m,A);case"ascii":return rt(this,m,A);case"latin1":case"binary":return Qe(this,m,A);case"base64":return Le(this,m,A);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ht(this,m,A);default:if(Q)throw new TypeError("Unknown encoding: "+c);c=(c+"").toLowerCase(),Q=!0}}b.prototype._isBuffer=!0;function Ue(c,m,A){const Q=c[m];c[m]=c[A],c[A]=Q}b.prototype.swap16=function(){const c=this.length;if(c%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let m=0;m<c;m+=2)Ue(this,m,m+1);return this},b.prototype.swap32=function(){const c=this.length;if(c%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let m=0;m<c;m+=4)Ue(this,m,m+3),Ue(this,m+1,m+2);return this},b.prototype.swap64=function(){const c=this.length;if(c%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let m=0;m<c;m+=8)Ue(this,m,m+7),Ue(this,m+1,m+6),Ue(this,m+2,m+5),Ue(this,m+3,m+4);return this},b.prototype.toString=function(){const c=this.length;return c===0?"":arguments.length===0?We(this,0,c):oe.apply(this,arguments)},b.prototype.toLocaleString=b.prototype.toString,b.prototype.equals=function(c){if(!b.isBuffer(c))throw new TypeError("Argument must be a Buffer");return this===c?!0:b.compare(this,c)===0},b.prototype.inspect=function(){let c="";const m=t.INSPECT_MAX_BYTES;return c=this.toString("hex",0,m).replace(/(.{2})/g,"$1 ").trim(),this.length>m&&(c+=" ... "),"<Buffer "+c+">"},s&&(b.prototype[s]=b.prototype.inspect),b.prototype.compare=function(c,m,A,Q,se){if(Jt(c,a)&&(c=b.from(c,c.offset,c.byteLength)),!b.isBuffer(c))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof c);if(m===void 0&&(m=0),A===void 0&&(A=c?c.length:0),Q===void 0&&(Q=0),se===void 0&&(se=this.length),m<0||A>c.length||Q<0||se>this.length)throw new RangeError("out of range index");if(Q>=se&&m>=A)return 0;if(Q>=se)return-1;if(m>=A)return 1;if(m>>>=0,A>>>=0,Q>>>=0,se>>>=0,this===c)return 0;let ze=se-Q,Ze=A-m;const Mt=Math.min(ze,Ze),Yt=this.slice(Q,se),xt=c.slice(m,A);for(let It=0;It<Mt;++It)if(Yt[It]!==xt[It]){ze=Yt[It],Ze=xt[It];break}return ze<Ze?-1:Ze<ze?1:0};function Ce(c,m,A,Q,se){if(c.length===0)return-1;if(typeof A=="string"?(Q=A,A=0):A>2147483647?A=2147483647:A<-2147483648&&(A=-2147483648),A=+A,ln(A)&&(A=se?0:c.length-1),A<0&&(A=c.length+A),A>=c.length){if(se)return-1;A=c.length-1}else if(A<0)if(se)A=0;else return-1;if(typeof m=="string"&&(m=b.from(m,Q)),b.isBuffer(m))return m.length===0?-1:Xe(c,m,A,Q,se);if(typeof m=="number")return m=m&255,typeof a.prototype.indexOf=="function"?se?a.prototype.indexOf.call(c,m,A):a.prototype.lastIndexOf.call(c,m,A):Xe(c,[m],A,Q,se);throw new TypeError("val must be string, number or Buffer")}function Xe(c,m,A,Q,se){let ze=1,Ze=c.length,Mt=m.length;if(Q!==void 0&&(Q=String(Q).toLowerCase(),Q==="ucs2"||Q==="ucs-2"||Q==="utf16le"||Q==="utf-16le")){if(c.length<2||m.length<2)return-1;ze=2,Ze/=2,Mt/=2,A/=2}function Yt(It,Ut){return ze===1?It[Ut]:It.readUInt16BE(Ut*ze)}let xt;if(se){let It=-1;for(xt=A;xt<Ze;xt++)if(Yt(c,xt)===Yt(m,It===-1?0:xt-It)){if(It===-1&&(It=xt),xt-It+1===Mt)return It*ze}else It!==-1&&(xt-=xt-It),It=-1}else for(A+Mt>Ze&&(A=Ze-Mt),xt=A;xt>=0;xt--){let It=!0;for(let Ut=0;Ut<Mt;Ut++)if(Yt(c,xt+Ut)!==Yt(m,Ut)){It=!1;break}if(It)return xt}return-1}b.prototype.includes=function(c,m,A){return this.indexOf(c,m,A)!==-1},b.prototype.indexOf=function(c,m,A){return Ce(this,c,m,A,!0)},b.prototype.lastIndexOf=function(c,m,A){return Ce(this,c,m,A,!1)};function re(c,m,A,Q){A=Number(A)||0;const se=c.length-A;Q?(Q=Number(Q),Q>se&&(Q=se)):Q=se;const ze=m.length;Q>ze/2&&(Q=ze/2);let Ze;for(Ze=0;Ze<Q;++Ze){const Mt=parseInt(m.substr(Ze*2,2),16);if(ln(Mt))return Ze;c[A+Ze]=Mt}return Ze}function X(c,m,A,Q){return an(un(m,c.length-A),c,A,Q)}function L(c,m,A,Q){return an(Sn(m),c,A,Q)}function Z(c,m,A,Q){return an(dn(m),c,A,Q)}function ne(c,m,A,Q){return an(An(m,c.length-A),c,A,Q)}b.prototype.write=function(c,m,A,Q){if(m===void 0)Q="utf8",A=this.length,m=0;else if(A===void 0&&typeof m=="string")Q=m,A=this.length,m=0;else if(isFinite(m))m=m>>>0,isFinite(A)?(A=A>>>0,Q===void 0&&(Q="utf8")):(Q=A,A=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const se=this.length-m;if((A===void 0||A>se)&&(A=se),c.length>0&&(A<0||m<0)||m>this.length)throw new RangeError("Attempt to write outside buffer bounds");Q||(Q="utf8");let ze=!1;for(;;)switch(Q){case"hex":return re(this,c,m,A);case"utf8":case"utf-8":return X(this,c,m,A);case"ascii":case"latin1":case"binary":return L(this,c,m,A);case"base64":return Z(this,c,m,A);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ne(this,c,m,A);default:if(ze)throw new TypeError("Unknown encoding: "+Q);Q=(""+Q).toLowerCase(),ze=!0}},b.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function Le(c,m,A){return m===0&&A===c.length?n.fromByteArray(c):n.fromByteArray(c.slice(m,A))}function We(c,m,A){A=Math.min(c.length,A);const Q=[];let se=m;for(;se<A;){const ze=c[se];let Ze=null,Mt=ze>239?4:ze>223?3:ze>191?2:1;if(se+Mt<=A){let Yt,xt,It,Ut;switch(Mt){case 1:ze<128&&(Ze=ze);break;case 2:Yt=c[se+1],(Yt&192)===128&&(Ut=(ze&31)<<6|Yt&63,Ut>127&&(Ze=Ut));break;case 3:Yt=c[se+1],xt=c[se+2],(Yt&192)===128&&(xt&192)===128&&(Ut=(ze&15)<<12|(Yt&63)<<6|xt&63,Ut>2047&&(Ut<55296||Ut>57343)&&(Ze=Ut));break;case 4:Yt=c[se+1],xt=c[se+2],It=c[se+3],(Yt&192)===128&&(xt&192)===128&&(It&192)===128&&(Ut=(ze&15)<<18|(Yt&63)<<12|(xt&63)<<6|It&63,Ut>65535&&Ut<1114112&&(Ze=Ut))}}Ze===null?(Ze=65533,Mt=1):Ze>65535&&(Ze-=65536,Q.push(Ze>>>10&1023|55296),Ze=56320|Ze&1023),Q.push(Ze),se+=Mt}return Je(Q)}const nt=4096;function Je(c){const m=c.length;if(m<=nt)return String.fromCharCode.apply(String,c);let A="",Q=0;for(;Q<m;)A+=String.fromCharCode.apply(String,c.slice(Q,Q+=nt));return A}function rt(c,m,A){let Q="";A=Math.min(c.length,A);for(let se=m;se<A;++se)Q+=String.fromCharCode(c[se]&127);return Q}function Qe(c,m,A){let Q="";A=Math.min(c.length,A);for(let se=m;se<A;++se)Q+=String.fromCharCode(c[se]);return Q}function st(c,m,A){const Q=c.length;(!m||m<0)&&(m=0),(!A||A<0||A>Q)&&(A=Q);let se="";for(let ze=m;ze<A;++ze)se+=In[c[ze]];return se}function ht(c,m,A){const Q=c.slice(m,A);let se="";for(let ze=0;ze<Q.length-1;ze+=2)se+=String.fromCharCode(Q[ze]+Q[ze+1]*256);return se}b.prototype.slice=function(c,m){const A=this.length;c=~~c,m=m===void 0?A:~~m,c<0?(c+=A,c<0&&(c=0)):c>A&&(c=A),m<0?(m+=A,m<0&&(m=0)):m>A&&(m=A),m<c&&(m=c);const Q=this.subarray(c,m);return Object.setPrototypeOf(Q,b.prototype),Q};function ot(c,m,A){if(c%1!==0||c<0)throw new RangeError("offset is not uint");if(c+m>A)throw new RangeError("Trying to access beyond buffer length")}b.prototype.readUintLE=b.prototype.readUIntLE=function(c,m,A){c=c>>>0,m=m>>>0,A||ot(c,m,this.length);let Q=this[c],se=1,ze=0;for(;++ze<m&&(se*=256);)Q+=this[c+ze]*se;return Q},b.prototype.readUintBE=b.prototype.readUIntBE=function(c,m,A){c=c>>>0,m=m>>>0,A||ot(c,m,this.length);let Q=this[c+--m],se=1;for(;m>0&&(se*=256);)Q+=this[c+--m]*se;return Q},b.prototype.readUint8=b.prototype.readUInt8=function(c,m){return c=c>>>0,m||ot(c,1,this.length),this[c]},b.prototype.readUint16LE=b.prototype.readUInt16LE=function(c,m){return c=c>>>0,m||ot(c,2,this.length),this[c]|this[c+1]<<8},b.prototype.readUint16BE=b.prototype.readUInt16BE=function(c,m){return c=c>>>0,m||ot(c,2,this.length),this[c]<<8|this[c+1]},b.prototype.readUint32LE=b.prototype.readUInt32LE=function(c,m){return c=c>>>0,m||ot(c,4,this.length),(this[c]|this[c+1]<<8|this[c+2]<<16)+this[c+3]*16777216},b.prototype.readUint32BE=b.prototype.readUInt32BE=function(c,m){return c=c>>>0,m||ot(c,4,this.length),this[c]*16777216+(this[c+1]<<16|this[c+2]<<8|this[c+3])},b.prototype.readBigUInt64LE=Xt(function(c){c=c>>>0,tn(c,"offset");const m=this[c],A=this[c+7];(m===void 0||A===void 0)&&sn(c,this.length-8);const Q=m+this[++c]*2**8+this[++c]*2**16+this[++c]*2**24,se=this[++c]+this[++c]*2**8+this[++c]*2**16+A*2**24;return BigInt(Q)+(BigInt(se)<<BigInt(32))}),b.prototype.readBigUInt64BE=Xt(function(c){c=c>>>0,tn(c,"offset");const m=this[c],A=this[c+7];(m===void 0||A===void 0)&&sn(c,this.length-8);const Q=m*2**24+this[++c]*2**16+this[++c]*2**8+this[++c],se=this[++c]*2**24+this[++c]*2**16+this[++c]*2**8+A;return(BigInt(Q)<<BigInt(32))+BigInt(se)}),b.prototype.readIntLE=function(c,m,A){c=c>>>0,m=m>>>0,A||ot(c,m,this.length);let Q=this[c],se=1,ze=0;for(;++ze<m&&(se*=256);)Q+=this[c+ze]*se;return se*=128,Q>=se&&(Q-=Math.pow(2,8*m)),Q},b.prototype.readIntBE=function(c,m,A){c=c>>>0,m=m>>>0,A||ot(c,m,this.length);let Q=m,se=1,ze=this[c+--Q];for(;Q>0&&(se*=256);)ze+=this[c+--Q]*se;return se*=128,ze>=se&&(ze-=Math.pow(2,8*m)),ze},b.prototype.readInt8=function(c,m){return c=c>>>0,m||ot(c,1,this.length),this[c]&128?(255-this[c]+1)*-1:this[c]},b.prototype.readInt16LE=function(c,m){c=c>>>0,m||ot(c,2,this.length);const A=this[c]|this[c+1]<<8;return A&32768?A|4294901760:A},b.prototype.readInt16BE=function(c,m){c=c>>>0,m||ot(c,2,this.length);const A=this[c+1]|this[c]<<8;return A&32768?A|4294901760:A},b.prototype.readInt32LE=function(c,m){return c=c>>>0,m||ot(c,4,this.length),this[c]|this[c+1]<<8|this[c+2]<<16|this[c+3]<<24},b.prototype.readInt32BE=function(c,m){return c=c>>>0,m||ot(c,4,this.length),this[c]<<24|this[c+1]<<16|this[c+2]<<8|this[c+3]},b.prototype.readBigInt64LE=Xt(function(c){c=c>>>0,tn(c,"offset");const m=this[c],A=this[c+7];(m===void 0||A===void 0)&&sn(c,this.length-8);const Q=this[c+4]+this[c+5]*2**8+this[c+6]*2**16+(A<<24);return(BigInt(Q)<<BigInt(32))+BigInt(m+this[++c]*2**8+this[++c]*2**16+this[++c]*2**24)}),b.prototype.readBigInt64BE=Xt(function(c){c=c>>>0,tn(c,"offset");const m=this[c],A=this[c+7];(m===void 0||A===void 0)&&sn(c,this.length-8);const Q=(m<<24)+this[++c]*2**16+this[++c]*2**8+this[++c];return(BigInt(Q)<<BigInt(32))+BigInt(this[++c]*2**24+this[++c]*2**16+this[++c]*2**8+A)}),b.prototype.readFloatLE=function(c,m){return c=c>>>0,m||ot(c,4,this.length),r.read(this,c,!0,23,4)},b.prototype.readFloatBE=function(c,m){return c=c>>>0,m||ot(c,4,this.length),r.read(this,c,!1,23,4)},b.prototype.readDoubleLE=function(c,m){return c=c>>>0,m||ot(c,8,this.length),r.read(this,c,!0,52,8)},b.prototype.readDoubleBE=function(c,m){return c=c>>>0,m||ot(c,8,this.length),r.read(this,c,!1,52,8)};function ut(c,m,A,Q,se,ze){if(!b.isBuffer(c))throw new TypeError('"buffer" argument must be a Buffer instance');if(m>se||m<ze)throw new RangeError('"value" argument is out of bounds');if(A+Q>c.length)throw new RangeError("Index out of range")}b.prototype.writeUintLE=b.prototype.writeUIntLE=function(c,m,A,Q){if(c=+c,m=m>>>0,A=A>>>0,!Q){const Ze=Math.pow(2,8*A)-1;ut(this,c,m,A,Ze,0)}let se=1,ze=0;for(this[m]=c&255;++ze<A&&(se*=256);)this[m+ze]=c/se&255;return m+A},b.prototype.writeUintBE=b.prototype.writeUIntBE=function(c,m,A,Q){if(c=+c,m=m>>>0,A=A>>>0,!Q){const Ze=Math.pow(2,8*A)-1;ut(this,c,m,A,Ze,0)}let se=A-1,ze=1;for(this[m+se]=c&255;--se>=0&&(ze*=256);)this[m+se]=c/ze&255;return m+A},b.prototype.writeUint8=b.prototype.writeUInt8=function(c,m,A){return c=+c,m=m>>>0,A||ut(this,c,m,1,255,0),this[m]=c&255,m+1},b.prototype.writeUint16LE=b.prototype.writeUInt16LE=function(c,m,A){return c=+c,m=m>>>0,A||ut(this,c,m,2,65535,0),this[m]=c&255,this[m+1]=c>>>8,m+2},b.prototype.writeUint16BE=b.prototype.writeUInt16BE=function(c,m,A){return c=+c,m=m>>>0,A||ut(this,c,m,2,65535,0),this[m]=c>>>8,this[m+1]=c&255,m+2},b.prototype.writeUint32LE=b.prototype.writeUInt32LE=function(c,m,A){return c=+c,m=m>>>0,A||ut(this,c,m,4,4294967295,0),this[m+3]=c>>>24,this[m+2]=c>>>16,this[m+1]=c>>>8,this[m]=c&255,m+4},b.prototype.writeUint32BE=b.prototype.writeUInt32BE=function(c,m,A){return c=+c,m=m>>>0,A||ut(this,c,m,4,4294967295,0),this[m]=c>>>24,this[m+1]=c>>>16,this[m+2]=c>>>8,this[m+3]=c&255,m+4};function _t(c,m,A,Q,se){fn(m,Q,se,c,A,7);let ze=Number(m&BigInt(4294967295));c[A++]=ze,ze=ze>>8,c[A++]=ze,ze=ze>>8,c[A++]=ze,ze=ze>>8,c[A++]=ze;let Ze=Number(m>>BigInt(32)&BigInt(4294967295));return c[A++]=Ze,Ze=Ze>>8,c[A++]=Ze,Ze=Ze>>8,c[A++]=Ze,Ze=Ze>>8,c[A++]=Ze,A}function lt(c,m,A,Q,se){fn(m,Q,se,c,A,7);let ze=Number(m&BigInt(4294967295));c[A+7]=ze,ze=ze>>8,c[A+6]=ze,ze=ze>>8,c[A+5]=ze,ze=ze>>8,c[A+4]=ze;let Ze=Number(m>>BigInt(32)&BigInt(4294967295));return c[A+3]=Ze,Ze=Ze>>8,c[A+2]=Ze,Ze=Ze>>8,c[A+1]=Ze,Ze=Ze>>8,c[A]=Ze,A+8}b.prototype.writeBigUInt64LE=Xt(function(c,m=0){return _t(this,c,m,BigInt(0),BigInt("0xffffffffffffffff"))}),b.prototype.writeBigUInt64BE=Xt(function(c,m=0){return lt(this,c,m,BigInt(0),BigInt("0xffffffffffffffff"))}),b.prototype.writeIntLE=function(c,m,A,Q){if(c=+c,m=m>>>0,!Q){const Mt=Math.pow(2,8*A-1);ut(this,c,m,A,Mt-1,-Mt)}let se=0,ze=1,Ze=0;for(this[m]=c&255;++se<A&&(ze*=256);)c<0&&Ze===0&&this[m+se-1]!==0&&(Ze=1),this[m+se]=(c/ze>>0)-Ze&255;return m+A},b.prototype.writeIntBE=function(c,m,A,Q){if(c=+c,m=m>>>0,!Q){const Mt=Math.pow(2,8*A-1);ut(this,c,m,A,Mt-1,-Mt)}let se=A-1,ze=1,Ze=0;for(this[m+se]=c&255;--se>=0&&(ze*=256);)c<0&&Ze===0&&this[m+se+1]!==0&&(Ze=1),this[m+se]=(c/ze>>0)-Ze&255;return m+A},b.prototype.writeInt8=function(c,m,A){return c=+c,m=m>>>0,A||ut(this,c,m,1,127,-128),c<0&&(c=255+c+1),this[m]=c&255,m+1},b.prototype.writeInt16LE=function(c,m,A){return c=+c,m=m>>>0,A||ut(this,c,m,2,32767,-32768),this[m]=c&255,this[m+1]=c>>>8,m+2},b.prototype.writeInt16BE=function(c,m,A){return c=+c,m=m>>>0,A||ut(this,c,m,2,32767,-32768),this[m]=c>>>8,this[m+1]=c&255,m+2},b.prototype.writeInt32LE=function(c,m,A){return c=+c,m=m>>>0,A||ut(this,c,m,4,2147483647,-2147483648),this[m]=c&255,this[m+1]=c>>>8,this[m+2]=c>>>16,this[m+3]=c>>>24,m+4},b.prototype.writeInt32BE=function(c,m,A){return c=+c,m=m>>>0,A||ut(this,c,m,4,2147483647,-2147483648),c<0&&(c=4294967295+c+1),this[m]=c>>>24,this[m+1]=c>>>16,this[m+2]=c>>>8,this[m+3]=c&255,m+4},b.prototype.writeBigInt64LE=Xt(function(c,m=0){return _t(this,c,m,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),b.prototype.writeBigInt64BE=Xt(function(c,m=0){return lt(this,c,m,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Bt(c,m,A,Q,se,ze){if(A+Q>c.length)throw new RangeError("Index out of range");if(A<0)throw new RangeError("Index out of range")}function St(c,m,A,Q,se){return m=+m,A=A>>>0,se||Bt(c,m,A,4),r.write(c,m,A,Q,23,4),A+4}b.prototype.writeFloatLE=function(c,m,A){return St(this,c,m,!0,A)},b.prototype.writeFloatBE=function(c,m,A){return St(this,c,m,!1,A)};function qt(c,m,A,Q,se){return m=+m,A=A>>>0,se||Bt(c,m,A,8),r.write(c,m,A,Q,52,8),A+8}b.prototype.writeDoubleLE=function(c,m,A){return qt(this,c,m,!0,A)},b.prototype.writeDoubleBE=function(c,m,A){return qt(this,c,m,!1,A)},b.prototype.copy=function(c,m,A,Q){if(!b.isBuffer(c))throw new TypeError("argument should be a Buffer");if(A||(A=0),!Q&&Q!==0&&(Q=this.length),m>=c.length&&(m=c.length),m||(m=0),Q>0&&Q<A&&(Q=A),Q===A||c.length===0||this.length===0)return 0;if(m<0)throw new RangeError("targetStart out of bounds");if(A<0||A>=this.length)throw new RangeError("Index out of range");if(Q<0)throw new RangeError("sourceEnd out of bounds");Q>this.length&&(Q=this.length),c.length-m<Q-A&&(Q=c.length-m+A);const se=Q-A;return this===c&&typeof a.prototype.copyWithin=="function"?this.copyWithin(m,A,Q):a.prototype.set.call(c,this.subarray(A,Q),m),se},b.prototype.fill=function(c,m,A,Q){if(typeof c=="string"){if(typeof m=="string"?(Q=m,m=0,A=this.length):typeof A=="string"&&(Q=A,A=this.length),Q!==void 0&&typeof Q!="string")throw new TypeError("encoding must be a string");if(typeof Q=="string"&&!b.isEncoding(Q))throw new TypeError("Unknown encoding: "+Q);if(c.length===1){const ze=c.charCodeAt(0);(Q==="utf8"&&ze<128||Q==="latin1")&&(c=ze)}}else typeof c=="number"?c=c&255:typeof c=="boolean"&&(c=Number(c));if(m<0||this.length<m||this.length<A)throw new RangeError("Out of range index");if(A<=m)return this;m=m>>>0,A=A===void 0?this.length:A>>>0,c||(c=0);let se;if(typeof c=="number")for(se=m;se<A;++se)this[se]=c;else{const ze=b.isBuffer(c)?c:b.from(c,Q),Ze=ze.length;if(Ze===0)throw new TypeError('The value "'+c+'" is invalid for argument "value"');for(se=0;se<A-m;++se)this[se+m]=ze[se%Ze]}return this};const Zt={};function en(c,m,A){Zt[c]=class extends A{constructor(){super(),Object.defineProperty(this,"message",{value:m.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${c}]`,this.stack,delete this.name}get code(){return c}set code(Q){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:Q,writable:!0})}toString(){return`${this.name} [${c}]: ${this.message}`}}}en("ERR_BUFFER_OUT_OF_BOUNDS",function(c){return c?`${c} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),en("ERR_INVALID_ARG_TYPE",function(c,m){return`The "${c}" argument must be of type number. Received type ${typeof m}`},TypeError),en("ERR_OUT_OF_RANGE",function(c,m,A){let Q=`The value of "${c}" is out of range.`,se=A;return Number.isInteger(A)&&Math.abs(A)>2**32?se=rn(String(A)):typeof A=="bigint"&&(se=String(A),(A>BigInt(2)**BigInt(32)||A<-(BigInt(2)**BigInt(32)))&&(se=rn(se)),se+="n"),Q+=` It must be ${m}. Received ${se}`,Q},RangeError);function rn(c){let m="",A=c.length;const Q=c[0]==="-"?1:0;for(;A>=Q+4;A-=3)m=`_${c.slice(A-3,A)}${m}`;return`${c.slice(0,A)}${m}`}function _n(c,m,A){tn(m,"offset"),(c[m]===void 0||c[m+A]===void 0)&&sn(m,c.length-(A+1))}function fn(c,m,A,Q,se,ze){if(c>A||c<m){const Ze=typeof m=="bigint"?"n":"";let Mt;throw m===0||m===BigInt(0)?Mt=`>= 0${Ze} and < 2${Ze} ** ${(ze+1)*8}${Ze}`:Mt=`>= -(2${Ze} ** ${(ze+1)*8-1}${Ze}) and < 2 ** ${(ze+1)*8-1}${Ze}`,new Zt.ERR_OUT_OF_RANGE("value",Mt,c)}_n(Q,se,ze)}function tn(c,m){if(typeof c!="number")throw new Zt.ERR_INVALID_ARG_TYPE(m,"number",c)}function sn(c,m,A){throw Math.floor(c)!==c?(tn(c,A),new Zt.ERR_OUT_OF_RANGE("offset","an integer",c)):m<0?new Zt.ERR_BUFFER_OUT_OF_BOUNDS:new Zt.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${m}`,c)}const En=/[^+/0-9A-Za-z-_]/g;function kn(c){if(c=c.split("=")[0],c=c.trim().replace(En,""),c.length<2)return"";for(;c.length%4!==0;)c=c+"=";return c}function un(c,m){m=m||1/0;let A;const Q=c.length;let se=null;const ze=[];for(let Ze=0;Ze<Q;++Ze){if(A=c.charCodeAt(Ze),A>55295&&A<57344){if(!se){if(A>56319){(m-=3)>-1&&ze.push(239,191,189);continue}else if(Ze+1===Q){(m-=3)>-1&&ze.push(239,191,189);continue}se=A;continue}if(A<56320){(m-=3)>-1&&ze.push(239,191,189),se=A;continue}A=(se-55296<<10|A-56320)+65536}else se&&(m-=3)>-1&&ze.push(239,191,189);if(se=null,A<128){if((m-=1)<0)break;ze.push(A)}else if(A<2048){if((m-=2)<0)break;ze.push(A>>6|192,A&63|128)}else if(A<65536){if((m-=3)<0)break;ze.push(A>>12|224,A>>6&63|128,A&63|128)}else if(A<1114112){if((m-=4)<0)break;ze.push(A>>18|240,A>>12&63|128,A>>6&63|128,A&63|128)}else throw new Error("Invalid code point")}return ze}function Sn(c){const m=[];for(let A=0;A<c.length;++A)m.push(c.charCodeAt(A)&255);return m}function An(c,m){let A,Q,se;const ze=[];for(let Ze=0;Ze<c.length&&!((m-=2)<0);++Ze)A=c.charCodeAt(Ze),Q=A>>8,se=A%256,ze.push(se),ze.push(Q);return ze}function dn(c){return n.toByteArray(kn(c))}function an(c,m,A,Q){let se;for(se=0;se<Q&&!(se+A>=m.length||se>=c.length);++se)m[se+A]=c[se];return se}function Jt(c,m){return c instanceof m||c!=null&&c.constructor!=null&&c.constructor.name!=null&&c.constructor.name===m.name}function ln(c){return c!==c}const In=(function(){const c="0123456789abcdef",m=new Array(256);for(let A=0;A<16;++A){const Q=A*16;for(let se=0;se<16;++se)m[Q+se]=c[A]+c[se]}return m})();function Xt(c){return typeof BigInt>"u"?Bn:c}function Bn(){throw new Error("BigInt not supported")}})(fr);var O=fr.Buffer,Yr=class{static fromHex(t){if(t=t.trim(),t.length===0)return new Uint8Array(0);if(t.length<2||t.length&1)throw new Error("Invalid hex string: odd length.");if((t.startsWith("0x")||t.startsWith("0X"))&&(t=t.slice(2)),!t.match(/^[0-9a-fA-F]*$/))throw new Error("Invalid hex string: contains non-hex characters");const n=t.match(/.{1,2}/g);if(!n)throw new Error("Invalid hex string");return new Uint8Array(n.map(r=>parseInt(r,16)))}static toHex(t){return Array.from(t,n=>n.toString(16).padStart(2,"0")).join("")}static fromString(t){return t=t.trim(),new TextEncoder().encode(t)}static toString(t){return new TextDecoder("utf-8").decode(t)}static concat(...t){const n=t.reduce((o,a)=>o+a.length,0),r=new Uint8Array(n);let s=0;for(const o of t)r.set(o,s),s+=o.length;return r}static alloc(t){return new Uint8Array(t)}static writeBigUint64BE(t){const n=new ArrayBuffer(8);return new DataView(n).setBigUint64(0,t,!1),new Uint8Array(n)}static toBase64(t){if(typeof O<"u")return O.from(t).toString("base64");if(t.length>32768){let n="";for(let r=0;r<t.length;r+=32768){const s=t.slice(r,r+32768);n+=btoa(String.fromCharCode(...s))}return n}return btoa(String.fromCharCode(...t))}static fromBase64(t){if(t=t.trim(),typeof O<"u")return new Uint8Array(O.from(t,"base64"));let n=t.replace(/-/g,"+").replace(/_/g,"/");for(;n.length%4;)n+="=";return new Uint8Array([...atob(n)].map(r=>r.charCodeAt(0)))}static equals(t,n){if(t.length!==n.length)return!1;let r=0;for(let s=0;s<t.length;s++)r|=t[s]^n[s];return r===0}static compare(t,n){const r=Math.min(t.length,n.length);for(let s=0;s<r;s++){if(t[s]<n[s])return-1;if(t[s]>n[s])return 1}return t.length-n.length}};function Vr(t){return Hr(bytesToHex2(t))}function Hr(t){return BigInt(`0x${t}`)}function Xr(t){return Yr.fromBase64(t)}var d=hexToBytes2("536563703235366b315f48617368546f43757276655f43617368755f");function T(t){const n=sha2562(Yr.concat(d,t)),r=new Uint32Array(1),s=2**16;for(let o=0;o<s;o++){const a=new Uint8Array(r.buffer),f=sha2562(Yr.concat(n,a));try{return l(bytesToHex2(Yr.concat(new Uint8Array([2]),f)))}catch{r[0]++}}throw new Error("No valid point found")}function H(t){const n=t.map(r=>r.toHex(!1)).join("");return sha2562(new TextEncoder().encode(n))}function l(t){return secp256k1.ProjectivePoint.fromHex(t)}var K=t=>{let n;return/^[a-fA-F0-9]+$/.test(t)?n=Hr(t)%BigInt(2**31-1):n=Vr(Xr(t))%BigInt(2**31-1),n};function p(t,n){if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++)if(t[r]!==n[r])return!1;return!0}var v=(t,n,r,s)=>{const o=secp256k1.ProjectivePoint.fromPrivateKey(bytesToHex2(t.s)),a=s.multiply(Vr(t.e)),f=n.multiply(Vr(t.s)),g=r.multiply(Vr(t.e)),_=o.subtract(a),P=f.subtract(g),b=H([_,P,s,r]);return p(b,t.e)},d2=(t,n,r,s)=>{if(n.r===void 0)throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");const o=T(t),a=r.add(s.multiply(n.r)),f=secp256k1.ProjectivePoint.fromPrivateKey(n.r),g=o.add(f);return v(n,g,a,s)},Rho160=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Id160=Uint8Array.from(new Array(16).fill(0).map((t,n)=>n)),Pi160=Id160.map(t=>(9*t+5)%16),idxLR=(()=>{const r=[[Id160],[Pi160]];for(let s=0;s<4;s++)for(let o of r)o.push(o[s].map(a=>Rho160[a]));return r})(),idxL=idxLR[0],idxR=idxLR[1],shifts160=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>Uint8Array.from(t)),shiftsL160=idxL.map((t,n)=>t.map(r=>shifts160[n][r])),shiftsR160=idxR.map((t,n)=>t.map(r=>shifts160[n][r])),Kl160=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),Kr160=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function ripemd_f(t,n,r,s){return t===0?n^r^s:t===1?n&r|~n&s:t===2?(n|~r)^s:t===3?n&s|r&~s:n^(r|~s)}var BUF_160=new Uint32Array(16),RIPEMD160=class extends HashMD{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:n,h2:r,h3:s,h4:o}=this;return[t,n,r,s,o]}set(t,n,r,s,o){this.h0=t|0,this.h1=n|0,this.h2=r|0,this.h3=s|0,this.h4=o|0}process(t,n){for(let k=0;k<16;k++,n+=4)BUF_160[k]=t.getUint32(n,!0);let r=this.h0|0,s=r,o=this.h1|0,a=o,f=this.h2|0,g=f,_=this.h3|0,P=_,b=this.h4|0,q=b;for(let k=0;k<5;k++){const B=4-k,Y=Kl160[k],te=Kr160[k],ve=idxL[k],je=idxR[k],Ve=shiftsL160[k],$e=shiftsR160[k];for(let He=0;He<16;He++){const Ge=rotl(r+ripemd_f(k,o,f,_)+BUF_160[ve[He]]+Y,Ve[He])+b|0;r=b,b=_,_=rotl(f,10)|0,f=o,o=Ge}for(let He=0;He<16;He++){const Ge=rotl(s+ripemd_f(B,a,g,P)+BUF_160[je[He]]+te,$e[He])+q|0;s=q,q=P,P=rotl(g,10)|0,g=a,a=Ge}}this.set(this.h1+f+P|0,this.h2+_+q|0,this.h3+b+s|0,this.h4+r+a|0,this.h0+o+g|0)}roundClean(){clean(BUF_160)}destroy(){this.destroyed=!0,clean(this.buffer),this.set(0,0,0,0,0)}},ripemd160=createHasher(()=>new RIPEMD160);function isBytes2(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function isArrayOf(t,n){return Array.isArray(n)?n.length===0?!0:t?n.every(r=>typeof r=="string"):n.every(r=>Number.isSafeInteger(r)):!1}function afn(t){if(typeof t!="function")throw new Error("function expected");return!0}function astr(t,n){if(typeof n!="string")throw new Error(`${t}: string expected`);return!0}function anumber2(t){if(!Number.isSafeInteger(t))throw new Error(`invalid integer: ${t}`)}function aArr(t){if(!Array.isArray(t))throw new Error("array expected")}function astrArr(t,n){if(!isArrayOf(!0,n))throw new Error(`${t}: array of strings expected`)}function anumArr(t,n){if(!isArrayOf(!1,n))throw new Error(`${t}: array of numbers expected`)}function chain(...t){const n=a=>a,r=(a,f)=>g=>a(f(g)),s=t.map(a=>a.encode).reduceRight(r,n),o=t.map(a=>a.decode).reduce(r,n);return{encode:s,decode:o}}function alphabet(t){const n=t.split(""),r=n.length;astrArr("alphabet",n);const s=new Map(n.map((o,a)=>[o,a]));return{encode:o=>(aArr(o),o.map(a=>{if(!Number.isSafeInteger(a)||a<0||a>=r)throw new Error(`alphabet.encode: digit index outside alphabet "${a}". Allowed: ${t}`);return n[a]})),decode:o=>(aArr(o),o.map(a=>{astr("alphabet.decode",a);const f=s.get(a);if(f===void 0)throw new Error(`Unknown letter: "${a}". Allowed: ${t}`);return f}))}}function join(t=""){return astr("join",t),{encode:n=>(astrArr("join.decode",n),n.join(t)),decode:n=>(astr("join.decode",n),n.split(t))}}function convertRadix(t,n,r){if(n<2)throw new Error(`convertRadix: invalid from=${n}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);if(aArr(t),!t.length)return[];let s=0;const o=[],a=Array.from(t,g=>{if(anumber2(g),g<0||g>=n)throw new Error(`invalid integer: ${g}`);return g}),f=a.length;for(;;){let g=0,_=!0;for(let P=s;P<f;P++){const b=a[P],q=n*g,k=q+b;if(!Number.isSafeInteger(k)||q/n!==g||k-b!==q)throw new Error("convertRadix: carry overflow");const B=k/r;g=k%r;const Y=Math.floor(B);if(a[P]=Y,!Number.isSafeInteger(Y)||Y*r+g!==k)throw new Error("convertRadix: carry overflow");if(_)Y?_=!1:s=P;else continue}if(o.push(g),_)break}for(let g=0;g<t.length-1&&t[g]===0;g++)o.push(0);return o.reverse()}function radix(t){anumber2(t);const n=2**8;return{encode:r=>{if(!isBytes2(r))throw new Error("radix.encode input should be Uint8Array");return convertRadix(Array.from(r),n,t)},decode:r=>(anumArr("radix.decode",r),Uint8Array.from(convertRadix(r,t,n)))}}function checksum(t,n){return anumber2(t),afn(n),{encode(r){if(!isBytes2(r))throw new Error("checksum.encode: input should be Uint8Array");const s=n(r).slice(0,t),o=new Uint8Array(r.length+t);return o.set(r),o.set(s,r.length),o},decode(r){if(!isBytes2(r))throw new Error("checksum.decode: input should be Uint8Array");const s=r.slice(0,-t),o=r.slice(-t),a=n(s).slice(0,t);for(let f=0;f<t;f++)if(a[f]!==o[f])throw new Error("Invalid checksum");return s}}}var genBase58=t=>chain(radix(58),alphabet(t),join("")),base58=genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),createBase58check=t=>chain(checksum(4,n=>t(t(n))),base58),Point=secp256k1.ProjectivePoint,base58check=createBase58check(sha256);function bytesToNumber(t){abytes(t);const n=t.length===0?"0":bytesToHex(t);return BigInt("0x"+n)}function numberToBytes(t){if(typeof t!="bigint")throw new Error("bigint expected");return hexToBytes(t.toString(16).padStart(64,"0"))}var MASTER_SECRET=utf8ToBytes("Bitcoin seed"),BITCOIN_VERSIONS={private:76066276,public:76067358},HARDENED_OFFSET=2147483648,hash160=t=>ripemd160(sha256(t)),fromU32=t=>createView(t).getUint32(0,!1),toU32=t=>{if(!Number.isSafeInteger(t)||t<0||t>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+t);const n=new Uint8Array(4);return createView(n).setUint32(0,t,!1),n},HDKey=class nn{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return fromU32(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const n=this.privateKey;if(!n)throw new Error("No private key");return base58check.encode(this.serialize(this.versions.private,concatBytes(new Uint8Array([0]),n)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return base58check.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(n,r=BITCOIN_VERSIONS){if(abytes(n),8*n.length<128||8*n.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+n.length);const s=hmac(sha512,MASTER_SECRET,n);return new nn({versions:r,chainCode:s.slice(32),privateKey:s.slice(0,32)})}static fromExtendedKey(n,r=BITCOIN_VERSIONS){const s=base58check.decode(n),o=createView(s),a=o.getUint32(0,!1),f={versions:r,depth:s[4],parentFingerprint:o.getUint32(5,!1),index:o.getUint32(9,!1),chainCode:s.slice(13,45)},g=s.slice(45),_=g[0]===0;if(a!==r[_?"private":"public"])throw new Error("Version mismatch");return _?new nn({...f,privateKey:g.slice(1)}):new nn({...f,publicKey:g})}static fromJSON(n){return nn.fromExtendedKey(n.xpriv)}constructor(n){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!n||typeof n!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=n.versions||BITCOIN_VERSIONS,this.depth=n.depth||0,this.chainCode=n.chainCode||null,this.index=n.index||0,this.parentFingerprint=n.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(n.publicKey&&n.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(n.privateKey){if(!secp256k1.utils.isValidPrivateKey(n.privateKey))throw new Error("Invalid private key");this.privKey=typeof n.privateKey=="bigint"?n.privateKey:bytesToNumber(n.privateKey),this.privKeyBytes=numberToBytes(this.privKey),this.pubKey=secp256k1.getPublicKey(n.privateKey,!0)}else if(n.publicKey)this.pubKey=Point.fromHex(n.publicKey).toRawBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=hash160(this.pubKey)}derive(n){if(!/^[mM]'?/.test(n))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(n))return this;const r=n.replace(/^[mM]'?\//,"").split("/");let s=this;for(const o of r){const a=/^(\d+)('?)$/.exec(o),f=a&&a[1];if(!a||a.length!==3||typeof f!="string")throw new Error("invalid child index: "+o);let g=+f;if(!Number.isSafeInteger(g)||g>=HARDENED_OFFSET)throw new Error("Invalid index");a[2]==="'"&&(g+=HARDENED_OFFSET),s=s.deriveChild(g)}return s}deriveChild(n){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let r=toU32(n);if(n>=HARDENED_OFFSET){const g=this.privateKey;if(!g)throw new Error("Could not derive hardened child key");r=concatBytes(new Uint8Array([0]),g,r)}else r=concatBytes(this.pubKey,r);const s=hmac(sha512,this.chainCode,r),o=bytesToNumber(s.slice(0,32)),a=s.slice(32);if(!secp256k1.utils.isValidPrivateKey(o))throw new Error("Tweak bigger than curve order");const f={versions:this.versions,chainCode:a,depth:this.depth+1,parentFingerprint:this.fingerprint,index:n};try{if(this.privateKey){const g=mod(this.privKey+o,secp256k1.CURVE.n);if(!secp256k1.utils.isValidPrivateKey(g))throw new Error("The tweak was out of range or the resulted private key is invalid");f.privateKey=g}else{const g=Point.fromHex(this.pubKey).add(Point.fromPrivateKey(o));if(g.equals(Point.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");f.publicKey=g.toRawBytes(!0)}return new nn(f)}catch{return this.deriveChild(n+1)}}sign(n){if(!this.privateKey)throw new Error("No privateKey set!");return abytes(n,32),secp256k1.sign(n,this.privKey).toCompactRawBytes()}verify(n,r){if(abytes(n,32),abytes(r,64),!this.publicKey)throw new Error("No publicKey set!");let s;try{s=secp256k1.Signature.fromCompact(r)}catch{return!1}return secp256k1.verify(s,n,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(n,r){if(!this.chainCode)throw new Error("No chainCode set");return abytes(r,33),concatBytes(toU32(n),new Uint8Array([this.depth]),toU32(this.parentFingerprint),toU32(this.index),this.chainCode,r)}};function D(t){return Yr.toBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function U(t){return Yr.fromBase64(t)}function j(t){const n=JSON.stringify(t);return v2(Yr.toBase64(Yr.fromString(n)))}function x(t){const n=Yr.toString(Yr.fromBase64($(t)));return JSON.parse(n)}function $(t){return t.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function v2(t){return t.replace(/\+/g,"-").replace(/\//g,"_").split("=")[0]}function u(t){if(typeof t!="string"||t.length===0)return!1;const n=/^[A-Za-z0-9\-_]+={0,2}$/,r=/^[A-Za-z0-9+/]+={0,2}$/;if(!n.test(t)&&!r.test(t))return!1;const s=t.replace(/-/g,"+").replace(/_/g,"/"),o=(4-s.length%4)%4;if(o>2)return!1;const a=s+"=".repeat(o);try{const f=Yr.fromBase64(a),g=Yr.toBase64(f),_=g.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),P=s.replace(/=+$/,"");return g.replace(/=+$/,"")===P||_===P}catch{return!1}}var S2="m/129372'/0'",T2=(t,n,r)=>{const s=/^[a-fA-F0-9]+$/.test(n);if(!s&&u(n)||s&&n.startsWith("00"))return i(t,n,r,0);if(s&&n.startsWith("01"))return p2(t,n,r,0);throw new Error(`Unrecognized keyset ID version ${n.slice(0,2)}`)},z2=(t,n,r)=>{const s=/^[a-fA-F0-9]+$/.test(n);if(!s&&u(n)||s&&n.startsWith("00"))return i(t,n,r,1);if(s&&n.startsWith("01"))return p2(t,n,r,1);throw new Error(`Unrecognized keyset ID version ${n.slice(0,2)}`)},p2=(t,n,r,s)=>{let o=Yr.concat(Yr.fromString("Cashu_KDF_HMAC_SHA256"),Yr.fromHex(n),Yr.writeBigUint64BE(BigInt(r)));switch(s){case 0:o=Yr.concat(o,Yr.fromHex("00"));break;case 1:o=Yr.concat(o,Yr.fromHex("01"))}return hmac(sha256,t,o)},i=(t,n,r,s)=>{const o=HDKey.fromMasterSeed(t),a=K(n),f=`${S2}/${a}'/${r}'/${s}`,g=o.derive(f);if(g.privateKey===null)throw new Error("Could not derive private key");return g.privateKey},e=t=>{try{return t instanceof Uint8Array&&(t=new TextDecoder().decode(t)),JSON.parse(t)}catch{throw new Error("can't parse secret")}},p3=(t,n)=>{const r=sha2562(t),s=schnorr.sign(r,n);return bytesToHex2(s)},h=(t,n,r)=>{try{const s=sha2562(n),o=r.length===66?r.slice(2):r;if(schnorr.verify(t,s,hexToBytes2(o)))return!0}catch(s){console.error("verifyP2PKsecret error:",s)}return!1};function d3(t){try{const n=typeof t=="string"?e(t):t;if(n[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const r=Math.floor(Date.now()/1e3);return w(n)>r?E(n):I(n)}catch{}return[]}function E(t){const n=typeof t=="string"?e(t):t;if(n[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{data:r,tags:s}=n[1],o=s&&s.find(f=>f[0]==="pubkeys"),a=o&&o.length>1?o.slice(1):[];return[r,...a].filter(Boolean)}function I(t){const n=typeof t=="string"?e(t):t;if(n[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{tags:r}=n[1],s=r&&r.find(o=>o[0]==="refund");return s&&s.length>1?s.slice(1).filter(Boolean):[]}function w(t){const n=typeof t=="string"?e(t):t;if(n[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{tags:r}=n[1],s=r&&r.find(o=>o[0]==="locktime");return s&&s.length>1?parseInt(s[1],10):1/0}var K2=t=>{if(!t)return[];if(typeof t=="string")try{return JSON.parse(t).signatures||[]}catch(n){return console.error("Failed to parse witness string:",n),[]}return t.signatures||[]},W=(t,n,r=!1)=>{const s=Array.isArray(n)?n:[n];return t.map((o,a)=>{let f=o;for(const g of s)try{f=T3(f,g)}catch(_){const P=_ instanceof Error?_.message:"Unknown error";if(r)throw new Error(`Failed signing proof #${a+1}: ${P}`);console.warn(`Proof #${a+1}: ${P}`)}return f})},T3=(t,n)=>{const r=e(t.secret);if(r[0]!=="P2PK")throw new Error("not a P2PK secret");const s=bytesToHex2(schnorr.getPublicKey(n)),o=d3(r);if(!o.length||!o.some(g=>g.includes(s)))throw new Error(`Signature not required from [02|03]${s}`);const a=K2(t.witness);if(a.some(g=>{try{return h(g,t.secret,s)}catch{return!1}}))throw new Error(`Proof already signed by [02|03]${s}`);const f=p3(t.secret,n);return a.push(f),{...t,witness:{signatures:a}}};function u2(t,n){let r=t;for(const o of n)r+=o.B_;const s=new TextEncoder().encode(r);return sha2562(s)}function p4(t,n,r){const s=u2(n,r),o=hexToBytes(t),a=schnorr.sign(s,o);return bytesToHex(a)}function l2(t,n,r){const s=T(t);n||(n=Vr(secp256k1.utils.randomPrivateKey()));const o=secp256k1.ProjectivePoint.BASE.multiply(n);return{B_:s.add(o),r:n,secret:t}}function C(t,n,r){return t.subtract(r.multiply(n))}function y(t,n,r,s){const o=s,a=C(t.C_,n,o);return{id:t.id,amount:t.amount,secret:r,C:a}}var v3=t=>({amount:t.amount,C:t.C.toHex(!0),id:t.id,secret:new TextDecoder().decode(t.secret),witness:JSON.stringify(t.witness)});function ie(t){return typeof t=="number"||typeof t=="string"}function wt(t){const n=[];return kt(t,n),new Uint8Array(n)}function kt(t,n){if(t===null)n.push(246);else if(t===void 0)n.push(247);else if(typeof t=="boolean")n.push(t?245:244);else if(typeof t=="number")Ot(t,n);else if(typeof t=="string")Nt(t,n);else if(Array.isArray(t))ce(t,n);else if(t instanceof Uint8Array)ae(t,n);else if(typeof t=="object"&&t!==null&&!Array.isArray(t))ue(t,n);else throw new Error("Unsupported type")}function Ot(t,n){if(t<24)n.push(t);else if(t<256)n.push(24,t);else if(t<65536)n.push(25,t>>8,t&255);else if(t<4294967296)n.push(26,t>>24,t>>16&255,t>>8&255,t&255);else throw new Error("Unsupported integer size")}function ae(t,n){const r=t.length;if(r<24)n.push(64+r);else if(r<256)n.push(88,r);else if(r<65536)n.push(89,r>>8&255,r&255);else if(r<4294967296)n.push(90,r>>24&255,r>>16&255,r>>8&255,r&255);else throw new Error("Byte string too long to encode");for(let s=0;s<t.length;s++)n.push(t[s])}function Nt(t,n){const r=new TextEncoder().encode(t),s=r.length;if(s<24)n.push(96+s);else if(s<256)n.push(120,s);else if(s<65536)n.push(121,s>>8&255,s&255);else if(s<4294967296)n.push(122,s>>24&255,s>>16&255,s>>8&255,s&255);else throw new Error("String too long to encode");for(let o=0;o<r.length;o++)n.push(r[o])}function ce(t,n){const r=t.length;if(r<24)n.push(128|r);else if(r<256)n.push(152,r);else if(r<65536)n.push(153,r>>8,r&255);else throw new Error("Unsupported array length");for(const s of t)kt(s,n)}function ue(t,n){const r=Object.keys(t);Ot(r.length,n),n[n.length-1]|=160;for(const s of r)Nt(s,n),kt(t[s],n)}function bt(t){const n=new DataView(t.buffer,t.byteOffset,t.byteLength);return it(n,0).value}function it(t,n){if(n>=t.byteLength)throw new Error("Unexpected end of data");const r=t.getUint8(n++),s=r>>5,o=r&31;switch(s){case 0:return he(t,n,o);case 1:return le(t,n,o);case 2:return de(t,n,o);case 3:return fe(t,n,o);case 4:return me(t,n,o);case 5:return pe(t,n,o);case 7:return ge(t,n,o);default:throw new Error(`Unsupported major type: ${s}`)}}function V(t,n,r){if(r<24)return{value:r,offset:n};if(r===24)return{value:t.getUint8(n++),offset:n};if(r===25){const s=t.getUint16(n,!1);return n+=2,{value:s,offset:n}}if(r===26){const s=t.getUint32(n,!1);return n+=4,{value:s,offset:n}}if(r===27){const s=t.getUint32(n,!1),o=t.getUint32(n+4,!1);return n+=8,{value:s*2**32+o,offset:n}}throw new Error(`Unsupported length: ${r}`)}function he(t,n,r){const{value:s,offset:o}=V(t,n,r);return{value:s,offset:o}}function le(t,n,r){const{value:s,offset:o}=V(t,n,r);return{value:-1-s,offset:o}}function de(t,n,r){const{value:s,offset:o}=V(t,n,r);if(o+s>t.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(t.buffer,t.byteOffset+o,s),offset:o+s}}function fe(t,n,r){const{value:s,offset:o}=V(t,n,r);if(o+s>t.byteLength)throw new Error("String length exceeds data length");const a=new Uint8Array(t.buffer,t.byteOffset+o,s);return{value:new TextDecoder().decode(a),offset:o+s}}function me(t,n,r){const{value:s,offset:o}=V(t,n,r),a=[];let f=o;for(let g=0;g<s;g++){const _=it(t,f);a.push(_.value),f=_.offset}return{value:a,offset:f}}function pe(t,n,r){const{value:s,offset:o}=V(t,n,r),a={};let f=o;for(let g=0;g<s;g++){const _=it(t,f);if(!ie(_.value))throw new Error("Invalid key type");const P=it(t,_.offset);a[_.value]=P.value,f=P.offset}return{value:a,offset:f}}function ye(t){const n=(t&31744)>>10,r=t&1023,s=t&32768?-1:1;return n===0?s*2**-14*(r/1024):n===31?r?NaN:s*(1/0):s*2**(n-15)*(1+r/1024)}function ge(t,n,r){if(r<24)switch(r){case 20:return{value:!1,offset:n};case 21:return{value:!0,offset:n};case 22:return{value:null,offset:n};case 23:return{value:void 0,offset:n};default:throw new Error(`Unknown simple value: ${r}`)}if(r===24)return{value:t.getUint8(n++),offset:n};if(r===25){const s=ye(t.getUint16(n,!1));return n+=2,{value:s,offset:n}}if(r===26){const s=t.getFloat32(n,!1);return n+=4,{value:s,offset:n}}if(r===27){const s=t.getFloat64(n,!1);return n+=8,{value:s,offset:n}}throw new Error(`Unknown simple or float value: ${r}`)}var we="A",ke="cashu";function R2(t,n,r,s){if(r){const a=Rt(r);if(t===0&&a===0)return r;const f=r.filter(_=>_>0),g=Rt(f);if(g>t)throw new Error(`Split is greater than total amount: ${g} > ${t}`);if(f.some(_=>!Lt(_,n)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");if(g===t)return f;r=f,t-=g}else r=[];const o=Qt(n,"desc");if(!o||o.length===0)throw new Error("Cannot split amount, keyset is inactive or contains no keys");if(o.forEach(a=>{if(t<=0||a<=0)return;const f=Math.floor(t/a);for(let g=0;g<f;++g)r.push(a);t%=a}),t!==0)throw new Error(`Unable to split remaining amount: ${t}`);return r.sort((a,f)=>a-f)}function vt(t,n,r,s){const o=[],a=t.map(g=>g.amount);Qt(r,"asc").forEach(g=>{const _=a.filter(b=>b===g).length,P=Math.max(s-_,0);for(let b=0;b<P&&!(o.reduce((q,k)=>q+k,0)+g>n);++b)o.push(g)});const f=n-o.reduce((g,_)=>g+_,0);return f&&R2(f,r).forEach(g=>{o.push(g)}),o.sort((g,_)=>g-_)}function Qt(t,n="desc"){return n=="desc"?Object.keys(t).map(r=>parseInt(r)).sort((r,s)=>s-r):Object.keys(t).map(r=>parseInt(r)).sort((r,s)=>r-s)}function Lt(t,n){return t in n}function be(t){return Ct(bytesToHex2(t))}function Ct(t){return BigInt(`0x${t}`)}function _e(t){return t.toString(16).padStart(64,"0")}function Tt(t){return/^[a-f0-9]*$/i.test(t)}function Et(t){return Array.isArray(t)?t.some(n=>!Tt(n.id)):!Tt(t.id)}function Ee(t,n){Et(t.proofs)||(t.proofs=Wt(t.proofs));const r={token:[{mint:t.mint,proofs:t.proofs}]};return t.unit&&(r.unit=t.unit),t.memo&&(r.memo=t.memo),ke+we+j(r)}function Wt(t){return t.map(n=>{const r={...n};return r.id=r.id.slice(0,16),r})}function Ye(t,n){return Et(t.proofs)||n?.version===3?Ee(t):Ae(t)}function Ae(t,n){if(t.proofs.forEach(g=>{if(g.dleq&&g.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),Et(t.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");t.proofs=Wt(t.proofs);const r=jt(t),s=wt(r),o="cashu",a="B",f=D(s);return o+a+f}function jt(t){const n={},r=t.mint;for(let o=0;o<t.proofs.length;o++){const a=t.proofs[o];n[a.id]?n[a.id].push(a):n[a.id]=[a]}const s={m:r,u:t.unit||"sat",t:Object.keys(n).map(o=>({i:hexToBytes2(o),p:n[o].map(a=>({a:a.amount,s:a.secret,c:hexToBytes2(a.C),...a.dleq&&{d:{e:hexToBytes2(a.dleq.e),s:hexToBytes2(a.dleq.s),r:hexToBytes2(a.dleq.r??"00")}},...a.witness&&{w:JSON.stringify(a.witness)}}))}))};return t.memo&&(s.d=t.memo),s}function $t(t){const n=[];t.t.forEach(s=>s.p.forEach(o=>{n.push({secret:o.s,C:bytesToHex2(o.c),amount:o.a,id:bytesToHex2(s.i),...o.d&&{dleq:{r:bytesToHex2(o.d.r),s:bytesToHex2(o.d.s),e:bytesToHex2(o.d.e)}},...o.w&&{witness:o.w}})}));const r={mint:t.m,proofs:n,unit:t.u||"sat"};return t.d&&(r.memo=t.d),r}function Pe(t,n){["web+cashu://","cashu://","cashu:","cashu"].forEach(s=>{t.startsWith(s)&&(t=t.slice(s.length))});const r=Se(t);return r.proofs=Be(r.proofs,n),r}function Se(t){const n=t.slice(0,1),r=t.slice(1);if(n==="A"){const s=x(r);if(s.token.length>1)throw new Error("Multi entry token are not supported");const o=s.token[0],a={mint:o.mint,proofs:o.proofs,unit:s.unit||"sat"};return s.memo&&(a.memo=s.memo),a}else if(n==="B"){const s=U(r),o=bt(s);return $t(o)}throw new Error("Token version is not supported")}function Ie(t,n,r,s=0,o=!1){let a=Object.entries(t).sort((_,P)=>+_[0]-+P[0]).map(([,_])=>hexToBytes2(_)).reduce((_,P)=>dt(_,P),new Uint8Array);if(o){const _=sha256(a);return Yr.toBase64(_).slice(0,12)}let f,g;switch(s){case 0:return f=sha256(a),g=Yr.toHex(f).slice(0,14),"00"+g;case 1:if(!n)throw new Error("Cannot compute keyset ID version 01: unit is required.");return a=dt(a,Yr.fromString("unit:"+n)),r&&(a=dt(a,Yr.fromString("final_expiry:"+r.toString()))),f=sha256(a),g=Yr.toHex(f),"01"+g;default:throw new Error(`Unrecognized keyset ID version: ${s}`)}}function dt(t,n){const r=new Uint8Array(t.length+n.length);return r.set(t),r.set(n,t.length),r}function x2(t){return typeof t=="object"}function S3(...t){return t.map(n=>n.replace(/(^\/+|\/+$)/g,"")).join("/")}function zt(t){return t.replace(/\/$/,"")}function W2(t){return t.reduce((n,r)=>n+r.amount,0)}var Me=class{get value(){return this._value}set value(t){this._value=t}get next(){return this._next}set next(t){this._next=t}constructor(t){this._value=t,this._next=null}},qe=class{get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}set size(t){this._size=t}constructor(){this._first=null,this._last=null,this._size=0}enqueue(t){const n=new Me(t);return this._size===0||!this._last?(this._first=n,this._last=n):(this._last.next=n,this._last=n),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const t=this._first;return this._first=t.next,t.next=null,this._size--,t.value}};function at(t){return t.map(n=>{const r={...n};return delete r.dleq,r})}function Dt(t){const n=u(t.id),r=/^[a-fA-F0-9]+$/.test(t.id),s=r?hexToBytes2(t.id)[0]:0;return Ie(t.keys,t.unit,t.final_expiry,s,n&&!r)===t.id}function Be(t,n){const r=[];for(const s of t){let o;try{o=hexToBytes2(s.id)}catch{r.push(s);continue}if(o[0]===0)r.push(s);else if(o[0]===1){if(!n)throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");let a=!1;for(const f of n)if(s.id===f.id.slice(0,s.id.length)){s.id=f.id,r.push(s),a=!0;break}if(!a)throw new Error(`Couldn't map short keyset ID ${s.id} to any known keysets of the current Mint`)}else throw new Error(`Unknown keyset ID version: ${o[0]}`)}return r}function Ht(t,n){if(t.dleq==null)return!1;const r={e:hexToBytes2(t.dleq.e),s:hexToBytes2(t.dleq.s),r:Ct(t.dleq.r??"00")};if(!Lt(t.amount,n.keys))throw new Error(`undefined key for amount ${t.amount}`);const s=n.keys[t.amount];return d2(new TextEncoder().encode(t.secret),r,l(t.C),l(s))}function Rt(t){return t.reduce((n,r)=>n+r,0)}var ct;typeof WebSocket<"u"&&(ct=WebSocket);function Te(){if(ct===void 0)throw new Error("WebSocket implementation not initialized");return ct}var F={fatal(){},error(){},warn(){},info(){},debug(){},trace(){},log(){}};function De(){const t=Date.now();return{elapsed:()=>Date.now()-t}}var G2=class on{constructor(){this.connectionMap=new Map}static getInstance(){return on.instance||(on.instance=new on),on.instance}getConnection(n,r){if(this.connectionMap.has(n))return this.connectionMap.get(n);const s=new Re(n,r);return this.connectionMap.set(n,s),s}},Re=class{constructor(t,n){this.subListeners={},this.rpcListeners={},this.rpcId=0,this.onCloseCallbacks=[],this._WS=Te(),this.url=new URL(t),this.messageQueue=new qe,this._logger=n??F}connect(){return this.connectionPromise||(this.connectionPromise=new Promise((t,n)=>{try{this.ws=new this._WS(this.url.toString()),this.onCloseCallbacks=[]}catch(r){n(r instanceof Error?r:new Error(String(r)));return}this.ws.onopen=()=>{t()},this.ws.onerror=()=>{n(new Error("Failed to open WebSocket"))},this.ws.onmessage=r=>{this.messageQueue.enqueue(r.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMessage.bind(this),0))},this.ws.onclose=r=>{this.connectionPromise=void 0,this.onCloseCallbacks.forEach(s=>s(r))}})),this.connectionPromise}sendRequest(t,n){if(this.ws?.readyState!==1){if(t==="unsubscribe")return;throw this._logger.error("Attempted sendRequest, but socket was not open"),new Error("Socket not open")}const r=this.rpcId;this.rpcId++;const s=JSON.stringify({jsonrpc:"2.0",method:t,params:n,id:r});this.ws?.send(s)}closeSubscription(t){this.ws?.send(JSON.stringify(["CLOSE",t]))}addSubListener(t,n){(this.subListeners[t]=this.subListeners[t]||[]).push(n)}addRpcListener(t,n,r){this.rpcListeners[r]={callback:t,errorCallback:n}}removeRpcListener(t){delete this.rpcListeners[t]}removeListener(t,n){if(this.subListeners[t]){if(this.subListeners[t].length===1){delete this.subListeners[t];return}this.subListeners[t]=this.subListeners[t].filter(r=>r!==n)}}async ensureConnection(){this.ws?.readyState!==1&&await this.connect()}handleNextMessage(){if(this.messageQueue.size===0){clearInterval(this.handlingInterval),this.handlingInterval=void 0;return}const t=this.messageQueue.dequeue();let n;try{if(n=JSON.parse(t),"result"in n&&n.id!=null)this.rpcListeners[n.id]&&(this.rpcListeners[n.id].callback(),this.removeRpcListener(n.id));else if("error"in n&&n.id!=null)this.rpcListeners[n.id]&&(this.rpcListeners[n.id].errorCallback(new Error(n.error.message)),this.removeRpcListener(n.id));else if("method"in n&&!("id"in n)){const r=n.params?.subId;if(!r)return;if(this.subListeners[r]?.length>0){const s=n;this.subListeners[r].forEach(o=>o(s.params?.payload))}}}catch(r){this._logger.error("Error doing handleNextMessage",{e:r});return}}createSubscription(t,n,r){if(this.ws?.readyState!==1)throw this._logger.error("Attempted createSubscription, but socket was not open"),new Error("Socket is not open");const s=(Math.random()+1).toString(36).substring(7);return this.addRpcListener(()=>{this.addSubListener(s,n)},r,this.rpcId),this.sendRequest("subscribe",{...t,subId:s}),this.rpcId++,s}cancelSubscription(t,n,r){this.removeListener(t,n),this.addRpcListener(()=>{this._logger.info("Unsubscribed {subId}",{subId:t})},r||(s=>this._logger.error("Unsubscribe failed",{e:s})),this.rpcId),this.sendRequest("unsubscribe",{subId:t})}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){this.ws&&this.ws?.close()}onClose(t){this.onCloseCallbacks.push(t)}},ns={UNSPENT:"UNSPENT",SPENT:"SPENT"},tt={UNPAID:"UNPAID",PENDING:"PENDING",PAID:"PAID"},yt={UNPAID:"UNPAID",PAID:"PAID"},et=class pn extends Error{constructor(n,r){super(n),this.status=r,this.name="HttpResponseError",Object.setPrototypeOf(this,pn.prototype)}},At=class yn extends Error{constructor(n){super(n),this.name="NetworkError",Object.setPrototypeOf(this,yn.prototype)}},Pt=class gn extends et{constructor(n,r){super(r||"Unknown mint operation error",400),this.code=n,this.name="MintOperationError",Object.setPrototypeOf(this,gn.prototype)}},Gt={},Vt=F;function Ke(t){Vt=t}async function xe({endpoint:t,requestBody:n,headers:r,...s}){const o=n?JSON.stringify(n):void 0,a={Accept:"application/json, text/plain, */*",...o?{"Content-Type":"application/json"}:void 0,...r};let f;try{f=await fetch(t,{body:o,headers:a,...s})}catch(g){throw new At(g instanceof Error?g.message:"Network request failed")}if(!f.ok){let g;try{g=await f.json()}catch{g={error:"bad response"}}if(f.status===400&&"code"in g&&typeof g.code=="number"&&"detail"in g&&typeof g.detail=="string")throw new Pt(g.code,g.detail);let _="HTTP request failed";throw"error"in g&&typeof g.error=="string"?_=g.error:"detail"in g&&typeof g.detail=="string"&&(_=g.detail),new et(_,f.status)}try{return await f.json()}catch(g){throw Vt.error("Failed to parse HTTP response",{err:g}),new et("bad response",f.status)}}async function I2(t){return await xe({...t,...Gt})}function ft(t,n){return t.state||(n.warn("Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof t.paid=="boolean"&&(t.state=t.paid?tt.PAID:tt.UNPAID)),t}function Kt(t,n){return t.state||(n.warn("Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof t.paid=="boolean"&&(t.state=t.paid?yt.PAID:yt.UNPAID)),t}function Fe(t,n){return Array.isArray(t?.contact)&&t?.contact.length>0&&(t.contact=t.contact.map(r=>Array.isArray(r)&&r.length===2&&typeof r[0]=="string"&&typeof r[1]=="string"?(n.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:r[0],info:r[1]}):r)),t}var gt=class{constructor(t){this._mintInfo=t,t.nuts[22]&&(this._protectedEnpoints={cache:{},apiReturn:t.nuts[22].protected_endpoints.map(n=>({method:n.method,regex:new RegExp(n.path)}))})}isSupported(t){switch(t){case 4:case 5:return this.checkMintMelt(t);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(t);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}requiresBlindAuthToken(t){if(!this._protectedEnpoints)return!1;if(typeof this._protectedEnpoints.cache[t]=="boolean")return this._protectedEnpoints.cache[t];const n=this._protectedEnpoints.apiReturn.some(r=>r.regex.test(t));return this._protectedEnpoints.cache[t]=n,n}checkGenericNut(t){return this._mintInfo.nuts[t]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(t){const n=this._mintInfo.nuts[t];return n&&n.methods.length>0&&!n.disabled?{disabled:!1,params:n.methods}:{disabled:!0,params:n.methods}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}get supportsBolt12Description(){return this._mintInfo.nuts[4]?.methods.some(t=>t.method==="bolt12"&&t.options?.description===!0)}},M=class Ft{constructor(n,r,s,o){this._mintUrl=n,this._customRequest=r,this._checkNut22=!1,this._mintUrl=zt(n),this._customRequest=r,s&&(this._checkNut22=!0,this._authTokenGetter=s),this._logger=o?.logger??F,Ke(this._logger)}get mintUrl(){return this._mintUrl}static async getInfo(n,r,s){const o=s??F,a=await(r||I2)({endpoint:S3(n,"/v1/info")});return Fe(a,o)}async getInfo(){return Ft.getInfo(this._mintUrl,this._customRequest,this._logger)}async getLazyMintInfo(){if(this._mintInfo)return this._mintInfo;const n=await Ft.getInfo(this._mintUrl,this._customRequest);return this._mintInfo=new gt(n),this._mintInfo}static async swap(n,r,s,o){const a=s||I2,f=o?{"Blind-auth":o}:{},g=await a({endpoint:S3(n,"/v1/swap"),method:"POST",requestBody:r,headers:f});if(!x2(g)||!Array.isArray(g?.signatures))throw new Error(g.detail??"bad response");return g}async swap(n){const r=await this.handleBlindAuth("/v1/swap");return Ft.swap(this._mintUrl,n,this._customRequest,r)}static async createMintQuote(n,r,s,o,a){const f=a??F,g=s||I2,_=o?{"Blind-auth":o}:{},P=await g({endpoint:S3(n,"/v1/mint/quote/bolt11"),method:"POST",requestBody:r,headers:_});return Kt(P,f)}async createMintQuote(n){const r=await this.handleBlindAuth("/v1/mint/quote/bolt11");return Ft.createMintQuote(this._mintUrl,n,this._customRequest,r)}static async createMintQuoteBolt12(n,r,s,o){const a=s||I2,f=o?{"Blind-auth":o}:{};return await a({endpoint:S3(n,"/v1/mint/quote/bolt12"),method:"POST",requestBody:r,headers:f})}async createMintQuoteBolt12(n){const r=await this.handleBlindAuth("/v1/mint/quote/bolt12");return Ft.createMintQuoteBolt12(this._mintUrl,n,this._customRequest,r)}static async checkMintQuote(n,r,s,o,a){const f=a??F,g=s||I2,_=o?{"Blind-auth":o}:{},P=await g({endpoint:S3(n,"/v1/mint/quote/bolt11",r),method:"GET",headers:_});return Kt(P,f)}async checkMintQuote(n){const r=await this.handleBlindAuth(`/v1/mint/quote/bolt11/${n}`);return Ft.checkMintQuote(this._mintUrl,n,this._customRequest,r)}static async checkMintQuoteBolt12(n,r,s,o){const a=s||I2,f=o?{"Blind-auth":o}:{};return await a({endpoint:S3(n,"/v1/mint/quote/bolt12",r),method:"GET",headers:f})}async checkMintQuoteBolt12(n){const r=await this.handleBlindAuth(`/v1/mint/quote/bolt12/${n}`);return Ft.checkMintQuoteBolt12(this._mintUrl,n,this._customRequest,r)}static async mint(n,r,s,o){const a=s||I2,f=o?{"Blind-auth":o}:{},g=await a({endpoint:S3(n,"/v1/mint/bolt11"),method:"POST",requestBody:r,headers:f});if(!x2(g)||!Array.isArray(g?.signatures))throw new Error("bad response");return g}async mint(n){const r=await this.handleBlindAuth("/v1/mint/bolt11");return Ft.mint(this._mintUrl,n,this._customRequest,r)}static async mintBolt12(n,r,s,o){const a=s||I2,f=o?{"Blind-auth":o}:{},g=await a({endpoint:S3(n,"/v1/mint/bolt12"),method:"POST",requestBody:r,headers:f});if(!x2(g)||!Array.isArray(g?.signatures))throw new Error("bad response");return g}async mintBolt12(n){const r=await this.handleBlindAuth("/v1/mint/bolt12");return Ft.mintBolt12(this._mintUrl,n,this._customRequest,r)}static async createMeltQuote(n,r,s,o,a){const f=a??F,g=s||I2,_=o?{"Blind-auth":o}:{},P=await g({endpoint:S3(n,"/v1/melt/quote/bolt11"),method:"POST",requestBody:r,headers:_}),b=ft(P,f);if(!x2(b)||typeof b?.amount!="number"||typeof b?.fee_reserve!="number"||typeof b?.quote!="string")throw new Error("bad response");return b}async createMeltQuote(n){const r=await this.handleBlindAuth("/v1/melt/quote/bolt11");return Ft.createMeltQuote(this._mintUrl,n,this._customRequest,r)}static async createMeltQuoteBolt12(n,r,s,o){const a=s||I2,f=o?{"Blind-auth":o}:{};return await a({endpoint:S3(n,"/v1/melt/quote/bolt12"),method:"POST",requestBody:r,headers:f})}async createMeltQuoteBolt12(n){const r=await this.handleBlindAuth("/v1/melt/quote/bolt12");return Ft.createMeltQuoteBolt12(this._mintUrl,n,this._customRequest,r)}static async checkMeltQuote(n,r,s,o,a){const f=a??F,g=s||I2,_=o?{"Blind-auth":o}:{},P=await g({endpoint:S3(n,"/v1/melt/quote/bolt11",r),method:"GET",headers:_}),b=ft(P,f);if(!x2(b)||typeof b?.amount!="number"||typeof b?.fee_reserve!="number"||typeof b?.quote!="string"||typeof b?.state!="string"||!Object.values(tt).includes(b.state))throw new Error("bad response");return b}async checkMeltQuote(n){const r=await this.handleBlindAuth(`/v1/melt/quote/bolt11/${n}`);return Ft.checkMeltQuote(this._mintUrl,n,this._customRequest,r)}static async checkMeltQuoteBolt12(n,r,s,o){const a=s||I2,f=o?{"Blind-auth":o}:{};return await a({endpoint:S3(n,"/v1/melt/quote/bolt12",r),method:"GET",headers:f})}async checkMeltQuoteBolt12(n){const r=await this.handleBlindAuth(`/v1/melt/quote/bolt12/${n}`);return Ft.checkMeltQuoteBolt12(this._mintUrl,n,this._customRequest,r)}static async melt(n,r,s,o,a){const f=a??F,g=s||I2,_=o?{"Blind-auth":o}:{},P=await g({endpoint:S3(n,"/v1/melt/bolt11"),method:"POST",requestBody:r,headers:_}),b=ft(P,f);if(!x2(b)||typeof b?.state!="string"||!Object.values(tt).includes(b.state))throw new Error("bad response");return b}async melt(n){const r=await this.handleBlindAuth("/v1/melt/bolt11");return Ft.melt(this._mintUrl,n,this._customRequest,r)}static async meltBolt12(n,r,s,o){const a=s||I2,f=o?{"Blind-auth":o}:{};return await a({endpoint:S3(n,"/v1/melt/bolt12"),method:"POST",requestBody:r,headers:f})}async meltBolt12(n){const r=await this.handleBlindAuth("/v1/melt/bolt12");return Ft.meltBolt12(this._mintUrl,n,this._customRequest,r)}static async check(n,r,s){const o=await(s||I2)({endpoint:S3(n,"/v1/checkstate"),method:"POST",requestBody:r});if(!x2(o)||!Array.isArray(o?.states))throw new Error("bad response");return o}static async getKeys(n,r,s){r&&(r=r.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(s||I2)({endpoint:r?S3(n,"/v1/keys",r):S3(n,"/v1/keys")});if(!x2(o)||!Array.isArray(o.keysets))throw new Error("bad response");return o}async getKeys(n,r){return await Ft.getKeys(r||this._mintUrl,n,this._customRequest)}static async getKeySets(n,r){return(r||I2)({endpoint:S3(n,"/v1/keysets")})}async getKeySets(){return Ft.getKeySets(this._mintUrl,this._customRequest)}async check(n){return Ft.check(this._mintUrl,n,this._customRequest)}static async restore(n,r,s){const o=await(s||I2)({endpoint:S3(n,"/v1/restore"),method:"POST",requestBody:r});if(!x2(o)||!Array.isArray(o?.outputs)||!Array.isArray(o?.signatures))throw new Error("bad response");return o}async restore(n){return Ft.restore(this._mintUrl,n,this._customRequest)}async connectWebSocket(){if(this.ws)await this.ws.ensureConnection();else{const n=new URL(this._mintUrl),r="v1/ws";n.pathname&&(n.pathname.endsWith("/")?n.pathname+=r:n.pathname+="/"+r),this.ws=G2.getInstance().getConnection(`${n.protocol==="https:"?"wss":"ws"}://${n.host}${n.pathname}`);try{await this.ws.connect()}catch(s){throw this._logger.error("Failed to connect to WebSocket...",{e:s}),new Error("Failed to connect to WebSocket...")}}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}async handleBlindAuth(n){if(this._checkNut22&&(await this.getLazyMintInfo()).requiresBlindAuthToken(n)){if(!this._authTokenGetter)throw new Error("Can not call a protected endpoint without authProofGetter");return this._authTokenGetter()}}},mt=class{constructor(t,n,r){this.amount=t,this.B_=n,this.id=r}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}};function pt(t){return typeof t=="function"}var N=class cn{constructor(n,r,s){this.secret=s,this.blindingFactor=r,this.blindedMessage=n}toProof(n,r){let s;n.dleq&&(s={s:hexToBytes(n.dleq.s),e:hexToBytes(n.dleq.e),r:this.blindingFactor});const o={id:n.id,amount:n.amount,C_:l(n.C_)},a=l(r.keys[n.amount]),f=y(o,this.blindingFactor,this.secret,a);return{...v3(f),...s&&{dleq:{s:bytesToHex(s.s),e:bytesToHex(s.e),r:_e(s.r??BigInt(0))}}}}static createP2PKData(n,r,s,o){return R2(r,s.keys,o).map(a=>this.createSingleP2PKData(n,a,s.id))}static createSingleP2PKData(n,r,s){const o=Array.isArray(n.pubkey)?n.pubkey:[n.pubkey],a=Math.max(1,Math.min(n.requiredSignatures||1,o.length)),f=Math.max(1,Math.min(n.requiredRefundSignatures||1,n.refundKeys?n.refundKeys.length:1)),g=["P2PK",{nonce:bytesToHex(randomBytes(32)),data:o[0],tags:[]}];n.locktime&&g[1].tags.push(["locktime",String(n.locktime)]),o.length>1&&(g[1].tags.push(["pubkeys",...o.slice(1)]),a>1&&g[1].tags.push(["n_sigs",String(a)])),n.refundKeys&&(g[1].tags.push(["refund",...n.refundKeys]),f>1&&g[1].tags.push(["n_sigs_refund",String(f)]));const _=JSON.stringify(g),P=new TextEncoder().encode(_),{r:b,B_:q}=l2(P);return new cn(new mt(r,q,s).getSerializedBlindedMessage(),b,P)}static createRandomData(n,r,s){return R2(n,r.keys,s).map(o=>this.createSingleRandomData(o,r.id))}static createSingleRandomData(n,r){const s=bytesToHex(randomBytes(32)),o=new TextEncoder().encode(s),{r:a,B_:f}=l2(o);return new cn(new mt(n,f,r).getSerializedBlindedMessage(),a,o)}static createDeterministicData(n,r,s,o,a){return R2(n,o.keys,a).map((f,g)=>this.createSingleDeterministicData(f,r,s+g,o.id))}static createSingleDeterministicData(n,r,s,o){const a=T2(r,o,s),f=bytesToHex(a),g=new TextEncoder().encode(f),_=be(z2(r,o,s)),{r:P,B_:b}=l2(g,_);return new cn(new mt(n,b,o).getSerializedBlindedMessage(),P,g)}},Oe=3,Ne="sat",rs=class{constructor(t,n){this._keys=new Map,this._keysets=[],this._seed=void 0,this._unit=Ne,this._mintInfo=void 0,this._denominationTarget=Oe,this.mint=t,this._logger=n?.logger??F;let r=[];if(n?.keys&&!Array.isArray(n.keys)?r=[n.keys]:n?.keys&&Array.isArray(n?.keys)&&(r=n?.keys),r&&r.forEach(s=>this._keys.set(s.id,s)),n?.unit&&(this._unit=n?.unit),n?.keysets&&(this._keysets=n.keysets),n?.mintInfo&&(this._mintInfo=new gt(n.mintInfo)),n?.denominationTarget&&(this._denominationTarget=n.denominationTarget),n?.bip39seed){if(n.bip39seed instanceof Uint8Array){this._seed=n.bip39seed;return}throw new Error("bip39seed must be a valid UInt8Array")}n?.keepFactory&&(this._keepFactory=n.keepFactory)}get unit(){return this._unit}get keys(){return this._keys}get keysetId(){if(!this._keysetId)throw new Error("No keysetId set");return this._keysetId}set keysetId(t){this._keysetId=t}get keysets(){return this._keysets}get mintInfo(){if(!this._mintInfo)throw new Error("Mint info not loaded");return this._mintInfo}async getMintInfo(){const t=await this.mint.getInfo();return this._mintInfo=new gt(t),this._mintInfo}async lazyGetMintInfo(){return this._mintInfo?this._mintInfo:await this.getMintInfo()}async loadMint(){await Promise.all([this.getMintInfo(),this.getKeys()])}getActiveKeyset(t){let n=t.filter(s=>s.active&&s.unit===this._unit);n=n.filter(s=>s.id.startsWith("00"));const r=n.sort((s,o)=>(s.input_fee_ppk??0)-(o.input_fee_ppk??0))[0];if(!r)throw new Error("No active keyset found");return r}async getKeySets(){const t=(await this.mint.getKeySets()).keysets.filter(n=>n.unit===this._unit);return this._keysets=t,this._keysets}async getAllKeys(){const t=await this.mint.getKeys();return t.keysets.forEach(n=>{if(!Dt(n))throw new Error(`Couldn't verify keyset ID ${n.id}`)}),this._keys=new Map(t.keysets.map(n=>[n.id,n])),this.keysetId=this.getActiveKeyset(this._keysets).id,t.keysets}async getKeys(t,n){if((!(this._keysets.length>0)||n)&&await this.getKeySets(),t||(t=this.getActiveKeyset(this._keysets).id),!this._keysets.find(r=>r.id===t)&&(await this.getKeySets(),!this._keysets.find(r=>r.id===t)))throw new Error(`could not initialize keys. No keyset with id '${t}' found`);if(!this._keys.get(t)){const r=await this.mint.getKeys(t);if(!Dt(r.keysets[0]))throw new Error(`Couldn't verify keyset ID ${r.keysets[0].id}`);this._keys.set(t,r.keysets[0])}return this.keysetId=t,this._keys.get(t)}async receive(t,n){const{requireDleq:r,keysetId:s,outputAmounts:o,counter:a,pubkey:f,privkey:g,outputData:_,p2pk:P}=n||{};this._keysets.length===0&&await this.getKeySets(),typeof t=="string"&&(t=Pe(t,this._keysets));const b=await this.getKeys(s);if(r&&t.proofs.some(je=>!Ht(je,b)))throw new Error("Token contains proofs with invalid DLEQ");const q=W2(t.proofs)-this.getFeesForProofs(t.proofs);let k;_?k={send:_}:this._keepFactory&&(k={send:this._keepFactory});const B=this.createSwapPayload(q,t.proofs,b,o,a,f,g,k,P),{signatures:Y}=await this.mint.swap(B.payload),te=B.outputData.map((je,Ve)=>je.toProof(Y[Ve],b)),ve=[];return B.sortedIndices.forEach((je,Ve)=>{ve[je]=te[Ve]}),ve}async send(t,n,r){const{offline:s,includeFees:o,includeDleq:a,keysetId:f,outputAmounts:g,pubkey:_,privkey:P,outputData:b}=r||{};if(a&&(n=n.filter(Y=>Y.dleq!=null)),W2(n)<t)throw new Error("Not enough funds available to send");const{keep:q,send:k}=this.selectProofsToSend(n,t,r?.includeFees),B=o?this.getFeesForProofs(k):0;if(!s&&(W2(k)!=t+B||g||_||P||f||b)){const Y=await this.swap(t,n,r),{keep:te,send:ve}=Y,je=Y.serialized;return{keep:te,send:ve,serialized:je}}if(W2(k)<t+B)throw new Error("Not enough funds available to send");return{keep:q,send:k}}selectProofsToSend(t,n,r=!1){const s=De();let o=null,a=1/0,f=0,g=0;const _=($e,He)=>$e-(r?Math.ceil(He/1e3):0),P=$e=>{const He=[...$e];for(let Ge=He.length-1;Ge>0;Ge--){const ee=Math.floor(Math.random()*(Ge+1));[He[Ge],He[ee]]=[He[ee],He[Ge]]}return He},b=($e,He,Ge)=>{let ee=0,oe=$e.length-1,Ue=null;for(;ee<=oe;){const Ce=Math.floor((ee+oe)/2),Xe=$e[Ce].exFee;(Ge?Xe<=He:Xe>=He)?(Ue=Ce,Ge?ee=Ce+1:oe=Ce-1):Ge?oe=Ce-1:ee=Ce+1}return Ge?Ue:ee<$e.length?ee:null},q=($e,He)=>{const Ge=He.exFee;let ee=0,oe=$e.length;for(;ee<oe;){const Ue=Math.floor((ee+oe)/2);$e[Ue].exFee<Ge?ee=Ue+1:oe=Ue}$e.splice(ee,0,He)},k=($e,He)=>_($e,He)<n?1/0:$e+He/1e3-n;let B=0,Y=0;const te=t.map($e=>{const He=this.getProofFeePPK($e),Ge=r?$e.amount-He/1e3:$e.amount,ee={proof:$e,exFee:Ge,ppkfee:He};return(!r||Ge>0)&&(B+=$e.amount,Y+=He),ee});let ve=r?te.filter($e=>$e.exFee>0):te;if(ve.sort(($e,He)=>$e.exFee-He.exFee),ve.length>0){let $e;{const He=b(ve,n,!1);if(He!==null){const Ge=ve[He].exFee,ee=b(ve,Ge,!0);if(ee===null)throw new Error("Unexpected null rightIndex in binary search");$e=ee+1}else $e=ve.length}for(let He=$e;He<ve.length;He++)B-=ve[He].proof.amount,Y-=ve[He].ppkfee;ve=ve.slice(0,$e)}const je=_(B,Y);if(n<=0||n>je)return{keep:t,send:[]};const Ve=Math.min(Math.ceil(n*(1+0/100)),n+0,je);for(let $e=0;$e<60;$e++){const He=[];let Ge=0,ee=0;for(const re of P(ve)){const X=Ge+re.proof.amount,L=ee+re.ppkfee,Z=_(X,L);if(He.push(re),Ge=X,ee=L,Z>=n)break}const oe=new Set(He),Ue=ve.filter(re=>!oe.has(re)),Ce=P(Array.from({length:He.length},(re,X)=>X)).slice(0,5e3);for(const re of Ce){const X=_(Ge,ee);if(X===n||X>=n&&X<=Ve)break;const L=He[re],Z=Ge-L.proof.amount,ne=ee-L.ppkfee,Le=_(Z,ne),We=n-Le,nt=b(Ue,We,!1);if(nt!==null){const Je=Ue[nt];(We>=0||Je.exFee<=L.exFee)&&(He[re]=Je,Ge=Z+Je.proof.amount,ee=ne+Je.ppkfee,Ue.splice(nt,1),q(Ue,L))}}const Xe=k(Ge,ee);if(Xe<a){this._logger.debug("selectProofsToSend: best solution found in trial #{trial} - amount: {amount}, delta: {delta}",{trial:$e,amount:Ge,delta:Xe}),o=[...He].sort((X,L)=>L.exFee-X.exFee),a=Xe,f=Ge,g=ee;const re=[...o];for(;re.length>1&&a>0;){const X=re.pop(),L=Ge-X.proof.amount,Z=ee-X.ppkfee,ne=k(L,Z);if(ne==1/0)break;ne<a&&(o=[...re],a=ne,f=L,g=Z,Ge=L,ee=Z)}}if(o&&a<1/0){const re=_(f,g);if(re===n||re>=n&&re<=Ve)break}if(s.elapsed()>1e3){this._logger.warn("Proof selection took too long. Returning best selection so far.");break}}if(o&&a<1/0){const $e=o.map(ee=>ee.proof),He=new Set($e),Ge=t.filter(ee=>!He.has(ee));return this._logger.info("Proof selection took {time}ms",{time:s.elapsed()}),{keep:Ge,send:$e}}return{keep:t,send:[]}}getFeesForProofs(t){const n=t.reduce((r,s)=>r+this.getProofFeePPK(s),0);return Math.ceil(n/1e3)}getProofFeePPK(t){const n=this._keysets.find(r=>r.id===t.id);if(!n)throw new Error(`Could not get fee. No keyset found for keyset id: ${t.id}`);return n?.input_fee_ppk||0}getFeesForKeyset(t,n){return Math.floor(Math.max((t*(this._keysets.find(r=>r.id===n)?.input_fee_ppk||0)+999)/1e3,0))}async swap(t,n,r){let{outputAmounts:s}=r||{};const{includeFees:o,keysetId:a,counter:f,pubkey:g,privkey:_,proofsWeHave:P,outputData:b,p2pk:q}=r||{},k=await this.getKeys(a);let B=t;const Y=W2(n);let te=s?.sendAmounts||R2(B,k.keys);if(o){let L=this.getFeesForKeyset(te.length,k.id),Z=R2(L,k.keys);for(;this.getFeesForKeyset(te.concat(Z).length,k.id)>L;)L++,Z=R2(L,k.keys);te=te.concat(Z),B+=L}const{keep:ve,send:je}=this.selectProofsToSend(n,B,!0),Ve=W2(je)-this.getFeesForProofs(je)-B;if(Ve<0)throw new Error("Not enough balance to send");let $e;if(!s?.keepAmounts&&!P)$e=R2(Ve,k.keys);else if(!s?.keepAmounts&&P)$e=vt(P,Ve,k.keys,this._denominationTarget);else if(s){if(s.keepAmounts?.reduce((L,Z)=>L+Z,0)!=Ve)throw new Error("Keep amounts do not match amount to keep");$e=s.keepAmounts}if(B+this.getFeesForProofs(je)>Y)throw this._logger.error(`Not enough funds available (${Y}) for swap amountToSend: ${B} + fee: ${this.getFeesForProofs(je)} | length: ${je.length}`),new Error("Not enough funds available for swap");s={keepAmounts:$e,sendAmounts:te};const He=b?.keep||this._keepFactory,Ge=b?.send,ee=this.createSwapPayload(B,je,k,s,f,g,_,{keep:He,send:Ge},q),{signatures:oe}=await this.mint.swap(ee.payload),Ue=ee.outputData.map((L,Z)=>L.toProof(oe[Z],k)),Ce=[],Xe=[],re=Array(ee.keepVector.length),X=Array(Ue.length);return ee.sortedIndices.forEach((L,Z)=>{re[L]=ee.keepVector[Z],X[L]=Ue[Z]}),X.forEach((L,Z)=>{re[Z]?Ce.push(L):Xe.push(L)}),{keep:[...Ce,...ve],send:Xe}}async batchRestore(t=300,n=100,r=0,s){const o=Math.ceil(t/n),a=[];let f,g=0;for(;g<o;){const _=await this.restore(r,n,{keysetId:s});_.proofs.length>0?(g=0,a.push(..._.proofs),f=_.lastCounterWithSignature):g++,r+=n}return{proofs:a,lastCounterWithSignature:f}}async restore(t,n,r){const{keysetId:s}=r||{},o=await this.getKeys(s);if(!this._seed)throw new Error("CashuWallet must be initialized with a seed to use restore");const a=Array(n).fill(0),f=N.createDeterministicData(0,this._seed,t,o,a),{outputs:g,signatures:_}=await this.mint.restore({outputs:f.map(k=>k.blindedMessage)}),P={};g.forEach((k,B)=>P[k.B_]=_[B]);const b=[];let q;for(let k=0;k<f.length;k++){const B=P[f[k].blindedMessage.B_];B&&(q=t+k,f[k].blindedMessage.amount=B.amount,b.push(f[k].toProof(B,o)))}return{proofs:b,lastCounterWithSignature:q}}async createMintQuote(t,n){const r={unit:this._unit,amount:t,description:n},s=await this.mint.createMintQuote(r);return{...s,amount:s.amount||t,unit:s.unit||this.unit}}async createLockedMintQuote(t,n,r){const{supported:s}=(await this.lazyGetMintInfo()).isSupported(20);if(!s)throw new Error("Mint does not support NUT-20");const o={unit:this._unit,amount:t,description:r,pubkey:n},a=await this.mint.createMintQuote(o);if(typeof a.pubkey!="string")throw new Error("Mint returned unlocked mint quote");{const f=a.pubkey;return{...a,pubkey:f,amount:a.amount||t,unit:a.unit||this.unit}}}async createMintQuoteBolt12(t,n){const r=await this.lazyGetMintInfo();if(n?.description&&!r.supportsBolt12Description)throw new Error("Mint does not support description for bolt12");const s={pubkey:t,unit:this._unit,amount:n?.amount,description:n?.description};return this.mint.createMintQuoteBolt12(s)}async checkMintQuote(t){const n=typeof t=="string"?t:t.quote,r=await this.mint.checkMintQuote(n);return typeof t=="string"?r:{...r,amount:r.amount||t.amount,unit:r.unit||t.unit}}async checkMintQuoteBolt12(t){return this.mint.checkMintQuoteBolt12(t)}async mintProofs(t,n,r){return this._mintProofs("bolt11",t,n,r)}async mintProofsBolt12(t,n,r,s){return this._mintProofs("bolt12",t,n,{...s,privateKey:r})}async createMeltQuote(t){const n={unit:this._unit,request:t},r=await this.mint.createMeltQuote(n);return{...r,unit:r.unit||this.unit,request:r.request||t}}async createMeltQuoteBolt12(t,n){return this.mint.createMeltQuoteBolt12({unit:this._unit,request:t,options:n?{amountless:{amount_msat:n}}:void 0})}async createMultiPathMeltQuote(t,n){const{supported:r,params:s}=(await this.lazyGetMintInfo()).isSupported(15);if(!r)throw new Error("Mint does not support NUT-15");if(!s?.some(f=>f.method==="bolt11"&&f.unit===this.unit))throw new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);const o={mpp:{amount:n}},a={unit:this._unit,request:t,options:o};return{...await this.mint.createMeltQuote(a),request:t,unit:this._unit}}async checkMeltQuote(t){const n=typeof t=="string"?t:t.quote,r=await this.mint.checkMeltQuote(n);return typeof t=="string"?r:{...r,request:t.request,unit:t.unit}}async checkMeltQuoteBolt12(t){return this.mint.checkMeltQuoteBolt12(t)}async meltProofs(t,n,r){return this._meltProofs("bolt11",t,n,r)}async meltProofsBolt12(t,n,r){return this._meltProofs("bolt12",t,n,r)}createSwapPayload(t,n,r,s,o,a,f,g,_){const P=n.reduce((Ve,$e)=>Ve+$e.amount,0);s&&s.sendAmounts&&!s.keepAmounts&&(s.keepAmounts=R2(P-t-this.getFeesForProofs(n),r.keys));const b=P-t-this.getFeesForProofs(n);let q=[],k=[];if(g?.keep)if(pt(g.keep)){const Ve=g.keep;R2(b,r.keys).forEach($e=>{q.push(Ve($e,r))})}else q=g.keep;else q=this.createOutputData(b,r,o,void 0,s?.keepAmounts,void 0,this._keepFactory);if(g?.send)if(pt(g.send)){const Ve=g.send;R2(t,r.keys).forEach($e=>{k.push(Ve($e,r))})}else k=g.send;else k=this.createOutputData(t,r,o?o+q.length:void 0,a,s?.sendAmounts,_);f&&(n=W(n,f)),n=at(n),n=n.map(Ve=>{const $e=Ve.witness&&typeof Ve.witness!="string"?JSON.stringify(Ve.witness):Ve.witness;return{...Ve,witness:$e}});const B=[...q,...k],Y=B.map((Ve,$e)=>$e).sort((Ve,$e)=>B[Ve].blindedMessage.amount-B[$e].blindedMessage.amount),te=[...Array.from({length:q.length},()=>!0),...Array.from({length:k.length},()=>!1)],ve=Y.map(Ve=>B[Ve]),je=Y.map(Ve=>te[Ve]);return{payload:{inputs:n,outputs:ve.map(Ve=>Ve.blindedMessage)},outputData:ve,keepVector:je,sortedIndices:Y}}async checkProofsStates(t){const n=new TextEncoder,r=t.map(a=>T(n.encode(a.secret)).toHex(!0)),s=100,o=[];for(let a=0;a<r.length;a+=s){const f=r.slice(a,a+s),{states:g}=await this.mint.check({Ys:f}),_={};g.forEach(P=>{_[P.Y]=P});for(let P=0;P<f.length;P++){const b=_[f[P]];if(!b)throw new Error("Could not find state for proof with Y: "+f[P]);o.push(b)}}return o}async onMintQuoteUpdates(t,n,r){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const s=this.mint.webSocketConnection.createSubscription({kind:"bolt11_mint_quote",filters:t},n,r);return()=>{this.mint.webSocketConnection?.cancelSubscription(s,n)}}async onMeltQuotePaid(t,n,r){return this.onMeltQuoteUpdates([t],s=>{s.state===tt.PAID&&n(s)},r)}async onMintQuotePaid(t,n,r){return this.onMintQuoteUpdates([t],s=>{s.state===yt.PAID&&n(s)},r)}async onMeltQuoteUpdates(t,n,r){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const s=this.mint.webSocketConnection.createSubscription({kind:"bolt11_melt_quote",filters:t},n,r);return()=>{this.mint.webSocketConnection?.cancelSubscription(s,n)}}async onProofStateUpdates(t,n,r){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const s=new TextEncoder,o={};for(let g=0;g<t.length;g++){const _=T(s.encode(t[g].secret)).toHex(!0);o[_]=t[g]}const a=Object.keys(o),f=this.mint.webSocketConnection.createSubscription({kind:"proof_state",filters:a},g=>{n({...g,proof:o[g.Y]})},r);return()=>{this.mint.webSocketConnection?.cancelSubscription(f,n)}}createOutputData(t,n,r,s,o,a,f){let g;if(s)g=N.createP2PKData({pubkey:s},t,n,o);else if(r||r===0){if(!this._seed)throw new Error("cannot create deterministic messages without seed");g=N.createDeterministicData(t,this._seed,r,n,o)}else a?g=N.createP2PKData(a,t,n,o):f?g=R2(t,n.keys).map(_=>f(_,n)):g=N.createRandomData(t,n,o);return g}createBlankOutputs(t,n,r,s){let o=Math.ceil(Math.log2(t))||1;o<0&&(o=0);const a=o?Array(o).fill(0):[];return this.createOutputData(0,n,r,void 0,a,void 0,s)}async _mintProofs(t,n,r,s){let{outputAmounts:o}=s||{};const{counter:a,pubkey:f,p2pk:g,keysetId:_,proofsWeHave:P,outputData:b,privateKey:q}=s||{},k=await this.getKeys(_);!o&&P&&(o={keepAmounts:vt(P,n,k.keys,this._denominationTarget),sendAmounts:[]});let B=[];if(b)if(pt(b)){const ve=R2(n,k.keys,o?.keepAmounts);for(let je=0;je<ve.length;je++)B.push(b(ve[je],k))}else B=b;else if(this._keepFactory){const ve=R2(n,k.keys,o?.keepAmounts);for(let je=0;je<ve.length;je++)B.push(this._keepFactory(ve[je],k))}else B=this.createOutputData(n,k,a,f,o?.keepAmounts,g);let Y;if(typeof r!="string"){if(!q)throw new Error("Can not sign locked quote without private key");const ve=B.map(Ve=>Ve.blindedMessage),je=p4(q,r.quote,ve);Y={outputs:ve,quote:r.quote,signature:je}}else Y={outputs:B.map(ve=>ve.blindedMessage),quote:r};if(t==="bolt12"){const{signatures:ve}=await this.mint.mintBolt12(Y);return B.map((je,Ve)=>je.toProof(ve[Ve],k))}const{signatures:te}=await this.mint.mint(Y);return B.map((ve,je)=>ve.toProof(te[je],k))}async _meltProofs(t,n,r,s){const{keysetId:o,counter:a,privkey:f}=s||{},g=await this.getKeys(o),_=this.createBlankOutputs(W2(r)-n.amount,g,a,this._keepFactory);f!=null&&(r=W(r,f)),r=at(r),r=r.map(q=>{const k=q.witness&&typeof q.witness!="string"?JSON.stringify(q.witness):q.witness;return{...q,witness:k}});const P={quote:n.quote,inputs:r,outputs:_.map(q=>q.blindedMessage)};if(t==="bolt12"){const q=await this.mint.meltBolt12(P);return{quote:{...q,unit:n.unit,request:n.request},change:q.change?.map((k,B)=>_[B].toProof(k,g))??[]}}const b=await this.mint.melt(P);return{quote:{...b,unit:n.unit,request:n.request},change:b.change?.map((q,k)=>_[k].toProof(q,g))??[]}}},import_tseep=__toESM(require_lib()),FRAME_SIZE_LIMITS={MINIMUM:4096,DEFAULT:5e4},TIMEOUTS={SYNC_SESSION:5e3,CACHE_QUERY:5e3,EVENT_FETCH:1e4,RELAY_CONNECTION:3e4},RANGE_SPLITTING={BUCKET_COUNT:16,MIN_ELEMENTS_FOR_BUCKETS:32},BUFFER_SIZES={DEFAULT_WRAPPED_BUFFER_SIZE:512,FRAME_SIZE_SAFETY_MARGIN:200};function isWrappedBuffer(t){return t instanceof WrappedBuffer}function isUint8Array(t){return t instanceof Uint8Array&&!isWrappedBuffer(t)}var PROTOCOL_VERSION=97,ID_SIZE=32,FINGERPRINT_SIZE=16;function encodeVarInt(t){if(t===0)return new Uint8Array([0]);const n=[];for(;t!==0;)n.push(t&127),t>>>=7;n.reverse();for(let r=0;r<n.length-1;r++)n[r]|=128;return new Uint8Array(n)}function decodeVarInt(t){if(!isWrappedBuffer(t)&&!isUint8Array(t))throw new Error("Invalid buffer type: expected Uint8Array or WrappedBuffer");let n=0;for(;;){if(t.length===0)throw new Error("VarInt decoding: unexpected end of buffer");const r=shiftByte(t);if(n=n<<7|r&127,(r&128)===0)break}return n}function getByte(t){return getBytes(t,1)[0]}function getBytes(t,n){if(!isWrappedBuffer(t)&&!isUint8Array(t))throw new Error("Invalid buffer type: expected Uint8Array or WrappedBuffer");if(t.length<n)throw new Error("getBytes: unexpected end of buffer");return isWrappedBuffer(t)?t.shiftN(n):t.slice(0,n)}function shiftByte(t){if(!isWrappedBuffer(t)&&!isUint8Array(t))throw new Error("Invalid buffer type: expected Uint8Array or WrappedBuffer");return isWrappedBuffer(t)?t.shift():t[0]}function compareUint8Array(t,n){const r=Math.min(t.length,n.length);for(let s=0;s<r;s++){if(t[s]<n[s])return-1;if(t[s]>n[s])return 1}return t.length<n.length?-1:t.length>n.length?1:0}function hexToUint8Array(t){if(t.startsWith("0x")&&(t=t.slice(2)),t.length%2!==0)throw new Error("Hex string has odd length");const n=new Uint8Array(t.length/2);for(let r=0;r<n.length;r++)n[r]=Number.parseInt(t.slice(r*2,r*2+2),16);return n}var hexLookupTable=new Array(256);{const t=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];for(let n=0;n<256;n++)hexLookupTable[n]=t[n>>>4&15]+t[n&15]}function uint8ArrayToHex(t){let n="";for(let r=0;r<t.length;r++)n+=hexLookupTable[t[r]];return n}var WrappedBuffer=class mn{constructor(n){typeof n=="number"?(this._raw=new Uint8Array(n),this.length=0):n?(this._raw=new Uint8Array(n),this.length=n.length):(this._raw=new Uint8Array(BUFFER_SIZES.DEFAULT_WRAPPED_BUFFER_SIZE),this.length=0)}unwrap(){return this._raw.subarray(0,this.length)}get capacity(){return this._raw.byteLength}append(n){const r=n instanceof mn?n.unwrap():n,s=r.length+this.length;if(this.capacity<s){const o=this._raw,a=Math.max(this.capacity*2,s);this._raw=new Uint8Array(a),this._raw.set(o)}this._raw.set(r,this.length),this.length+=r.length}set(n){const r=n instanceof Uint8Array?n:new Uint8Array(n);this.capacity<r.length&&(this._raw=new Uint8Array(Math.max(this.capacity*2,r.length))),this._raw.set(r),this.length=r.length}shift(){if(this.length===0)throw new Error("Cannot shift from empty buffer");const n=this._raw[0];return this._raw=this._raw.subarray(1),this.length--,n}shiftN(n){if(this.length<n)throw new Error("Cannot shift more bytes than available");const r=this._raw.subarray(0,n);return this._raw=this._raw.subarray(n),this.length-=n,r}clear(){this.length=0}},Accumulator=class{constructor(){this.buf=new Uint8Array(ID_SIZE),this.setToZero()}setToZero(){this.buf=new Uint8Array(ID_SIZE)}add(t){let n=0,r=0;const s=new DataView(this.buf.buffer),o=new DataView(t.buffer);for(let a=0;a<8;a++){const f=a*4,g=s.getUint32(f,!0),_=o.getUint32(f,!0);let P=g;P+=n,P+=_,P>4294967295&&(r=1),s.setUint32(f,P&4294967295,!0),n=r,r=0}}negate(){const t=new DataView(this.buf.buffer);for(let r=0;r<8;r++){const s=r*4;t.setUint32(s,~t.getUint32(s,!0),!0)}const n=new Uint8Array(ID_SIZE);n[0]=1,this.add(n)}async getFingerprint(t){const n=new Uint8Array(this.buf.length+encodeVarInt(t).length);return n.set(this.buf),n.set(encodeVarInt(t),this.buf.length),(await this.sha256(n)).subarray(0,FINGERPRINT_SIZE)}async sha256(t){if(crypto?.subtle){const n=await crypto.subtle.digest("SHA-256",t.buffer);return new Uint8Array(n)}try{const n=await __vitePreload(()=>import("./BIHI7g3E.js"),[],import.meta.url);return new Uint8Array(n.createHash("sha256").update(t).digest())}catch{throw new Error("No SHA256 implementation available")}}};function itemCompare(t,n){return t.timestamp!==n.timestamp?t.timestamp-n.timestamp:compareUint8Array(t.id,n.id)}var NegentropyStorage=class wn{constructor(){this.items=[],this.sealed=!1}static fromEvents(n){const r=new wn;for(const s of n)r.insert(s.created_at||0,s.id);return r.seal(),r}insert(n,r){if(this.sealed)throw new Error("Storage is sealed, cannot insert");const s=typeof r=="string"?hexToUint8Array(r):r;if(s.length!==ID_SIZE)throw new Error(`Invalid ID size: expected ${ID_SIZE}, got ${s.length}`);this.items.push({timestamp:n,id:s})}seal(){if(this.sealed)throw new Error("Storage is already sealed");this.sealed=!0,this.items.sort(itemCompare);for(let n=1;n<this.items.length;n++)if(itemCompare(this.items[n-1],this.items[n])===0)throw new Error("Duplicate item in storage")}unseal(){this.sealed=!1}size(){return this.checkSealed(),this.items.length}getItem(n){if(this.checkSealed(),n>=this.items.length)throw new Error("Index out of range");return this.items[n]}iterate(n,r,s){this.checkSealed(),this.checkBounds(n,r);for(let o=n;o<r&&s(this.items[o],o);o++);}findLowerBound(n,r,s){return this.checkSealed(),this.checkBounds(n,r),this.binarySearch(this.items,n,r,o=>itemCompare(o,s)<0)}async fingerprint(n,r){const s=new Accumulator;return s.setToZero(),this.iterate(n,r,o=>(s.add(o.id),!0)),await s.getFingerprint(r-n)}checkSealed(){if(!this.sealed)throw new Error("Storage is not sealed")}checkBounds(n,r){if(n>r||r>this.items.length)throw new Error("Invalid range")}binarySearch(n,r,s,o){let a=s-r;for(;a>0;){let f=r;const g=Math.floor(a/2);f+=g,o(n[f])?(r=++f,a-=g+1):a=g}return r}},Negentropy=class{constructor(t,n=0){if(this.lastTimestampIn=0,this.lastTimestampOut=0,this.isInitiator=!1,n!==0&&n<FRAME_SIZE_LIMITS.MINIMUM)throw new Error(`frameSizeLimit too small (minimum ${FRAME_SIZE_LIMITS.MINIMUM} bytes)`);this.storage=t,this.frameSizeLimit=n}bound(t,n){return{timestamp:t,id:n||new Uint8Array(0)}}async initiate(){if(this.isInitiator)throw new Error("Already initiated");this.isInitiator=!0;const t=new WrappedBuffer;return t.set([PROTOCOL_VERSION]),await this.splitRange(0,this.storage.size(),this.bound(Number.MAX_VALUE),t),t.unwrap()}setInitiator(){this.isInitiator=!0}async reconcile(t){const n=[],r=[],s=new WrappedBuffer(t);this.lastTimestampIn=this.lastTimestampOut=0;const o=new WrappedBuffer;o.set([PROTOCOL_VERSION]);const a=this.validateProtocolVersion(s);if(!a.isValid)return{nextMessage:a.output.unwrap(),have:n,need:r};const f=this.storage.size();let g=this.bound(0),_=0,P=!1;for(;s.length!==0;){const b=new WrappedBuffer,q=()=>{P&&(P=!1,b.append(this.encodeBound(g)),b.append(encodeVarInt(0)))},k=this.decodeBound(s),B=s.length===0?0:decodeVarInt(s),Y=_,te=this.storage.findLowerBound(_,f,k),ve=await this.processByMode(B,Y,te,k,s,b,o,q,n,r);if(ve.shouldSkip&&(P=!0),this.exceededFrameSizeLimit(o.length+b.length)){const je=await this.storage.fingerprint(te,f);o.append(this.encodeBound(this.bound(Number.MAX_VALUE))),o.append(encodeVarInt(1)),o.append(je);break}ve.outputAlreadyAppended||o.append(b.unwrap()),_=te,g=k}return{nextMessage:o.length===1&&this.isInitiator?void 0:o.unwrap(),have:n,need:r}}validateProtocolVersion(t){const n=new WrappedBuffer;n.set([PROTOCOL_VERSION]);const r=getByte(t);if(r<96||r>111)throw new Error("Invalid negentropy protocol version byte");if(r!==PROTOCOL_VERSION){if(this.isInitiator)throw new Error(`Unsupported negentropy protocol version requested: ${r-96}`);return{isValid:!1,output:n}}return{isValid:!0,output:n}}async processByMode(t,n,r,s,o,a,f,g,_,P){if(t===0)return this.handleModeSkip();if(t===1)return await this.handleModeFingerprint(n,r,s,o,a,g);if(t===2)return await this.handleModeIdList(n,r,s,o,a,f,g,_,P);throw new Error("Unexpected mode")}handleModeSkip(){return{shouldSkip:!0,outputAlreadyAppended:!1}}async handleModeFingerprint(t,n,r,s,o,a){const f=getBytes(s,FINGERPRINT_SIZE),g=await this.storage.fingerprint(t,n);return compareUint8Array(f,g)!==0?(a(),await this.splitRange(t,n,r,o),{shouldSkip:!1,outputAlreadyAppended:!1}):{shouldSkip:!0,outputAlreadyAppended:!1}}async handleModeIdList(t,n,r,s,o,a,f,g,_){const P=decodeVarInt(s),b=new Map;for(let q=0;q<P;q++){const k=getBytes(s,ID_SIZE),B=Array.from(k).join(",");b.set(B,k)}return this.isInitiator?this.handleIdListAsInitiator(t,n,b,g,_):await this.handleIdListAsResponder(t,n,r,o,a,f)}handleIdListAsInitiator(t,n,r,s,o){this.storage.iterate(t,n,a=>{const f=Array.from(a.id).join(",");return r.has(f)?r.delete(f):s.push(a.id),!0});for(const a of r.values())o.push(a);return{shouldSkip:!0,outputAlreadyAppended:!1}}async handleIdListAsResponder(t,n,r,s,o,a){a();const f=new WrappedBuffer;let g=0,_=r;return this.storage.iterate(t,n,(P,b)=>this.exceededFrameSizeLimit(o.length+f.length)?(_=P,!1):(f.append(P.id),g++,!0)),s.append(this.encodeBound(_)),s.append(encodeVarInt(2)),s.append(encodeVarInt(g)),s.append(f.unwrap()),o.append(s.unwrap()),s.clear(),{shouldSkip:!1,outputAlreadyAppended:!0}}async splitRange(t,n,r,s){const o=n-t,a=RANGE_SPLITTING.BUCKET_COUNT;if(o<RANGE_SPLITTING.MIN_ELEMENTS_FOR_BUCKETS)s.append(this.encodeBound(r)),s.append(encodeVarInt(2)),s.append(encodeVarInt(o)),this.storage.iterate(t,n,f=>(s.append(f.id),!0));else{const f=Math.floor(o/a),g=o%a;let _=t;for(let P=0;P<a;P++){const b=f+(P<g?1:0),q=await this.storage.fingerprint(_,_+b);_+=b;let k;if(_===n)k=r;else{let B,Y;if(this.storage.iterate(_-1,_+1,(te,ve)=>(ve===_-1?B=te:Y=te,!0)),!B||!Y)throw new Error(`Failed to get items at index ${_-1} and ${_} for bound calculation`);k=this.getMinimalBound(B,Y)}s.append(this.encodeBound(k)),s.append(encodeVarInt(1)),s.append(q)}}}exceededFrameSizeLimit(t){return this.frameSizeLimit>0&&t>this.frameSizeLimit-BUFFER_SIZES.FRAME_SIZE_SAFETY_MARGIN}decodeTimestampIn(t){let n=decodeVarInt(t);return n=n===0?Number.MAX_VALUE:n-1,this.lastTimestampIn===Number.MAX_VALUE||n===Number.MAX_VALUE?(this.lastTimestampIn=Number.MAX_VALUE,Number.MAX_VALUE):(n+=this.lastTimestampIn,this.lastTimestampIn=n,n)}decodeBound(t){const n=this.decodeTimestampIn(t),r=decodeVarInt(t);if(r>ID_SIZE)throw new Error("Bound key too long");const s=new Uint8Array(ID_SIZE),o=getBytes(t,Math.min(r,t.length));return s.set(o),{timestamp:n,id:s}}encodeTimestampOut(t){if(t===Number.MAX_VALUE)return this.lastTimestampOut=Number.MAX_VALUE,encodeVarInt(0);const n=t;return t-=this.lastTimestampOut,this.lastTimestampOut=n,encodeVarInt(t+1)}encodeBound(t){const n=this.encodeTimestampOut(t.timestamp),r=encodeVarInt(t.id.length),s=new Uint8Array(n.length+r.length+t.id.length);return s.set(n),s.set(r,n.length),s.set(t.id,n.length+r.length),s}getMinimalBound(t,n){if(n.timestamp!==t.timestamp)return this.bound(n.timestamp);let r=0;for(let s=0;s<ID_SIZE&&n.id[s]===t.id[s];s++)r++;return this.bound(n.timestamp,n.id.subarray(0,r+1))}};function isNegMessage(t){return Array.isArray(t)&&t.length>=2&&typeof t[0]=="string"&&typeof t[1]=="string"}function isNegMsgWithPayload(t){return isNegMessage(t)&&t.length===3&&typeof t[2]=="string"}function hasWebSocketConnectivity(t){return"connectivity"in t&&t.connectivity&&typeof t.connectivity.send=="function"}var SyncSession=class extends import_tseep.EventEmitter{constructor(t,n,r,s){super(),this.need=new Set,this.have=new Set,this.active=!1,this.relay=t,this.filters=n,this.sessionId=this.generateSessionId(),this.opts=s,this.negentropy=new Negentropy(r,s.frameSizeLimit||FRAME_SIZE_LIMITS.DEFAULT),this.setupRelayMonitoring()}async start(){if(this.active)throw new Error("Sync session already active");this.active=!0,this.relay.registerProtocolHandler("NEG-MSG",this.handleNegMsg.bind(this)),this.relay.registerProtocolHandler("NEG-ERR",this.handleNegErr.bind(this)),this.relay.registerProtocolHandler("NEG-CLOSE",this.handleNegClose.bind(this)),this.relay.on("notice",this.handleNotice.bind(this));try{const t=await this.negentropy.initiate(),n=JSON.stringify(["NEG-OPEN",this.sessionId,this.filters,uint8ArrayToHex(t)]);return await this.sendRaw(n),await new Promise((r,s)=>{this.once("complete",r),this.once("error",s),setTimeout(()=>{this.active&&(this.cleanup(),s(new Error("Sync session timeout")))},this.opts.timeout||TIMEOUTS.SYNC_SESSION)})}catch(t){throw this.cleanup(),t}}async handleNegMsg(t,n){try{if(!isNegMsgWithPayload(n))throw new Error("Invalid NEG-MSG format: expected [string, string, string]");const[,r,s]=n;if(r!==this.sessionId)return;const o=hexToUint8Array(s),a=await this.negentropy.reconcile(o);for(const f of a.need)this.need.add(uint8ArrayToHex(f));for(const f of a.have)this.have.add(uint8ArrayToHex(f));if(a.nextMessage){const f=JSON.stringify(["NEG-MSG",this.sessionId,uint8ArrayToHex(a.nextMessage)]);await this.sendRaw(f)}else{const f=JSON.stringify(["NEG-CLOSE",this.sessionId]);await this.sendRaw(f),this.complete()}}catch(r){this.error(r instanceof Error?r:new Error(String(r)))}}handleNegErr(t,n){if(!isNegMsgWithPayload(n)){this.error(new Error("Invalid NEG-ERR format: expected [string, string, string]"));return}const[,r,s]=n;r===this.sessionId&&this.error(new Error(`Relay sync error: ${s}`))}handleNegClose(t,n){if(!isNegMessage(n)){this.error(new Error("Invalid NEG-CLOSE format: expected [string, string]"));return}const[,r]=n;r===this.sessionId&&this.complete()}handleNotice(t){if(typeof t!="string")return;const n=t.toLowerCase();(n.includes("negentropy")||n.includes("bad msg")||n.includes("bad message")||n.includes("unknown")&&n.includes("msg")||n.includes("unsupported")&&n.includes("protocol"))&&this.error(new Error(`Relay does not support negentropy: ${t}`))}complete(){this.active&&(this.cleanup(),this.emit("complete",{need:this.need,have:this.have}))}error(t){this.active&&(this.cleanup(),this.emit("error",t))}cleanup(){this.active=!1,this.relay.unregisterProtocolHandler("NEG-MSG"),this.relay.unregisterProtocolHandler("NEG-ERR"),this.relay.unregisterProtocolHandler("NEG-CLOSE"),this.relay.off("notice",this.handleNotice),this.relay.off("disconnect",this.handleRelayDisconnect)}setupRelayMonitoring(){this.relay.once("disconnect",this.handleRelayDisconnect.bind(this))}handleRelayDisconnect(){this.active&&this.error(new Error("Relay disconnected during sync session"))}async sendRaw(t){const n=this.relay.url;if(!this.relay.connected)throw new Error(`Relay ${n} is not connected`);if(!hasWebSocketConnectivity(this.relay))throw new Error(`Relay ${n} does not support direct message sending`);try{await this.relay.connectivity.send(t)}catch(r){throw new Error(`Failed to send message to relay ${n}: ${r instanceof Error?r.message:String(r)}`)}}generateSessionId(){return`neg-${Math.random().toString(36).substring(2,15)}`}};async function ndkSync(t,n={}){if(!this.cacheAdapter)throw new Error("NDK sync requires a cache adapter. Configure NDK with cacheAdapter option.");const r=Array.isArray(t)?t:[t],s=getRelaySet.call(this,n),o=Array.from(s.relays),a={events:[],need:new Set,have:new Set},f=o.map(async g=>{if(g.connected||await new Promise(_=>{const P=()=>{g.off("ready",P),_()};g.once("ready",P),setTimeout(()=>{g.off("ready",P),_()},TIMEOUTS.RELAY_CONNECTION)}),!g.connected){console.warn(`[NDK Sync] Relay ${g.url} did not connect in time, skipping`);return}try{await syncWithRelay.call(this,g,r,n,a)}catch(_){const P=_ instanceof Error?_.message:String(_);console.error(`[NDK Sync] Failed to sync with relay ${g.url}: ${P}`),n.onRelayError&&await n.onRelayError(g,_ instanceof Error?_:new Error(String(_)))}});return await Promise.all(f),a}function getRelaySet(t){if(t.relaySet)return t.relaySet;if(t.relayUrls)return NDKRelaySet.fromRelayUrls(t.relayUrls,this);const n=this.pool?.relays;if(!n||n.size===0)throw new Error("No relays available for sync");const r=new Set(n.values());return new NDKRelaySet(r,this)}async function syncWithRelay(t,n,r,s){try{const o=await queryCache.call(this,n),a=NegentropyStorage.fromEvents(o),f=new SyncSession(t,n,a,r),{need:g,have:_}=await f.start();for(const P of g)s.need.add(P);for(const P of _)s.have.add(P);if(r.autoFetch!==!1&&g.size>0){const P=await fetchNeededEvents.call(this,t,g);s.events.push(...P),this.cacheAdapter&&await saveFetchedEventsToCache.call(this,P,n,t)}}catch(o){const a=o instanceof Error?o.message:String(o);throw new Error(`Sync failed with relay ${t.url}: ${a}`)}}async function saveFetchedEventsToCache(t,n,r){if(this.cacheAdapter)for(const s of t)await this.cacheAdapter.setEvent(s,n,r)}async function queryCache(t){if(!this.cacheAdapter)return[];const n=[];return new Promise(r=>{const s=this.subscribe(t,{cacheUsage:NDKSubscriptionCacheUsage.ONLY_CACHE,closeOnEose:!0,onEvent:o=>{n.push(o)},onEose:()=>{r(n)}});setTimeout(()=>{s.stop(),r(n)},TIMEOUTS.CACHE_QUERY)})}async function fetchNeededEvents(t,n){const r=[],s=new NDKRelaySet(new Set([t]),this);return new Promise(o=>{const a=this.subscribe({ids:Array.from(n)},{closeOnEose:!0,relaySet:s,exclusiveRelay:!0,groupable:!1,onEvent:f=>{r.push(f)},onEose:()=>{o(r)}});setTimeout(()=>{a.stop(),o(r)},TIMEOUTS.EVENT_FETCH)})}async function supportsNegentropy(t){try{return(typeof t=="string"?await fetchRelayInformation(t):await t.fetchInfo()).supported_nips?.includes(77)??!1}catch{return!1}}var NDKSync=class hn{constructor(n){this.CAPABILITY_CACHE_TTL=36e5,this.ndk=n}async checkRelaySupport(n){const s=(await this.ndk.cacheAdapter?.getRelayStatus?.(n.url))?.metadata?.sync,o=Date.now();if(s?.lastChecked&&o-s.lastChecked<this.CAPABILITY_CACHE_TTL)return s.supportsNegentropy??!1;try{const a=await supportsNegentropy(n);return await this.ndk.cacheAdapter?.updateRelayStatus?.(n.url,{metadata:{sync:{supportsNegentropy:a,lastChecked:o}}}),a}catch(a){return await this.ndk.cacheAdapter?.updateRelayStatus?.(n.url,{metadata:{sync:{supportsNegentropy:!1,lastChecked:o,lastError:a instanceof Error?a.message:"Unknown error"}}}),!1}}async getNegentropyRelays(n){const r=n||Array.from(this.ndk.pool?.relays?.values()||[]);return(await Promise.all(r.map(async o=>({relay:o,supports:await this.checkRelaySupport(o)})))).filter(o=>o.supports).map(o=>o.relay)}async getRelayCapability(n){return(await this.ndk.cacheAdapter?.getRelayStatus?.(n))?.metadata?.sync}async clearCapabilityCache(n){n?await this.ndk.cacheAdapter?.updateRelayStatus?.(n,{metadata:{sync:void 0}}):console.warn("clearCapabilityCache() without relayUrl is not supported with persistent cache")}async markRelayAsNotSupporting(n,r){await this.ndk.cacheAdapter?.updateRelayStatus?.(n,{metadata:{sync:{supportsNegentropy:!1,lastChecked:Date.now(),lastError:r.message}}})}createErrorHandler(n){return async(r,s)=>{await n?.(r,s),await this.markRelayAsNotSupporting(r.url,s)}}async syncSingleRelay(n,r,s={}){if(await this.checkRelaySupport(n))return await ndkSync.call(this.ndk,r,{...s,relaySet:new NDKRelaySet(new Set([n]),this.ndk)});const a=await this.ndk.guardrailOff("fetch-events-usage").fetchEvents(r,{relaySet:new NDKRelaySet(new Set([n]),this.ndk),subId:"sync-fetch-fallback",groupable:!1});return{events:Array.from(a),need:new Set,have:new Set}}async sync(n,r){const s=Array.isArray(n)?n:[n],o=r?.relaySet||(r?.relayUrls?NDKRelaySet.fromRelayUrls(r.relayUrls,this.ndk):void 0),a=o?Array.from(o.relays):Array.from(this.ndk.pool?.relays?.values()||[]);if(a.length===0)return console.warn("[NDK Sync] No relays available for sync"),{events:[],need:new Set,have:new Set};const f={events:[],need:new Set,have:new Set},g={...r,onRelayError:this.createErrorHandler(r?.onRelayError)};return await Promise.all(a.map(async _=>{try{const P=await this.syncSingleRelay(_,s,g);f.events.push(...P.events);for(const b of P.need)f.need.add(b);for(const b of P.have)f.have.add(b)}catch(P){console.error(`[NDK Sync] Failed to sync with relay ${_.url}:`,P)}})),f}async syncAndSubscribe(n,r={}){this.ndk.cacheAdapter||console.warn("[NDKSync] No cache adapter - sync will not work, using subscription only");const s=Array.isArray(n)?n:[n],o=r.relaySet||(r.relayUrls?NDKRelaySet.fromRelayUrls(r.relayUrls,this.ndk):void 0),a=o?Array.from(o.relays):Array.from(this.ndk.pool?.relays?.values()||[]);if(a.length===0)throw new Error("No relays available for syncAndSubscribe");const f=s.map(_=>({..._,limit:0})),g=this.ndk.subscribe(f,{...r,relaySet:o,closeOnEose:!1});if(this.ndk.cacheAdapter){let _=0;const P=a.length,b=async q=>{try{const k=await this.syncSingleRelay(q,s,{autoFetch:!0,onRelayError:this.createErrorHandler(r.onRelayError)});r.onRelaySynced?.(q,k.events.length)}catch(k){console.error(`[NDKSync] Failed to sync from ${q.url}:`,k)}finally{_++,_===P&&r.onSyncComplete?.()}};for(const q of a)if(q.connected)b(q);else{let k=!1;const B=()=>{k||(k=!0,q.off("ready",B),b(q))};q.once("ready",B),setTimeout(()=>{k||(k=!0,q.off("ready",B),_++,_===P&&r.onSyncComplete?.())},TIMEOUTS.RELAY_CONNECTION)}}else setTimeout(()=>r.onSyncComplete?.(),0);return g}static sync(n,r,s){return new hn(n).sync(r,s)}static syncAndSubscribe(n,r,s){return new hn(n).syncAndSubscribe(r,s)}},import_debug=__toESM(require_src()),import_light_bolt11_decoder=__toESM(require_bolt11());__toESM(require_lib3());var mintWallets=new Map,mintWalletPromises=new Map;function mintKey(t,n,r){if(r){const s=new TextDecoder().decode(r);return`${t}-${n}-${s}`}return`${t}-${n}`}async function walletForMint(t,{pk:n,timeout:r=5e3,mintInfo:s,mintKeys:o,onMintInfoNeeded:a,onMintInfoLoaded:f,onMintKeysNeeded:g,onMintKeysLoaded:_}={}){const P=Date.now(),b=()=>`+${Date.now()-P}ms`;if(a){console.log(`[MINT-CACHE ${b()}] Querying cache for mint info: ${t}`);const te=Date.now();s??(s=await a(t));const ve=Date.now()-te;s?console.log(`[MINT-CACHE ${b()}]  Cache HIT for mint info: ${t} (${ve}ms)`,{name:s.name}):console.log(`[MINT-CACHE ${b()}]  Cache MISS for mint info: ${t} (${ve}ms)`)}if(g){console.log(`[MINT-CACHE ${b()}] Querying cache for mint keys: ${t}`);const te=Date.now();o??(o=await g(t));const ve=Date.now()-te;o?console.log(`[MINT-CACHE ${b()}]  Cache HIT for mint keys: ${t} (${ve}ms)`,{count:o.length}):console.log(`[MINT-CACHE ${b()}]  Cache MISS for mint keys: ${t} (${ve}ms)`)}if(!s&&f){console.log(`[MINT-CACHE ${b()}] Fetching mint info from ${t}/v1/info`);const te=Date.now();s=await M.getInfo(t);const ve=Date.now()-te;console.log(`[MINT-CACHE ${b()}] Caching mint info: ${t} (fetched in ${ve}ms)`,{name:s.name}),f?.(t,s)}const q="sat",k=mintKey(t,q,n);if(mintWallets.has(k))return console.log(`[MINT-CACHE ${b()}] Returning cached wallet instance: ${t}`),mintWallets.get(k);if(mintWalletPromises.has(k))return console.log(`[MINT-CACHE ${b()}] Wallet loading in progress, returning existing promise: ${t}`),mintWalletPromises.get(k);if(!s){if(a){console.log(`[MINT-CACHE ${b()}] Querying cache for mint info (second check): ${t}`);const te=Date.now();s=await a(t);const ve=Date.now()-te;s?console.log(`[MINT-CACHE ${b()}]  Cache HIT for mint info (second check): ${t} (${ve}ms)`,{name:s.name}):console.log(`[MINT-CACHE ${b()}]  Cache MISS for mint info (second check): ${t} (${ve}ms)`)}if(!s&&f){console.log(`[MINT-CACHE ${b()}] Fetching mint info from ${t}/v1/info (second check)`);const te=Date.now();s=await M.getInfo(t);const ve=Date.now()-te;console.log(`[MINT-CACHE ${b()}] Caching mint info (second check): ${t} (fetched in ${ve}ms)`,{name:s.name}),f(t,s)}}if(!o&&g){console.log(`[MINT-CACHE ${b()}] Querying cache for mint keys (second check): ${t}`);const te=Date.now();o=await g(t);const ve=Date.now()-te;o?console.log(`[MINT-CACHE ${b()}]  Cache HIT for mint keys (second check): ${t} (${ve}ms)`,{count:o.length}):console.log(`[MINT-CACHE ${b()}]  Cache MISS for mint keys (second check): ${t} (${ve}ms)`)}const B=new rs(new M(t),{unit:q,bip39seed:n,mintInfo:s,keys:o}),Y=new Promise(async te=>{try{console.log(`[MINT-CACHE ${b()}] Loading mint wallet: ${t}`);const ve=Date.now(),je=new Promise(($e,He)=>{setTimeout(()=>{He(new Error("timeout loading mint"))},r)});await Promise.race([B.loadMint(),je]);const Ve=Date.now()-ve;console.log(`[MINT-CACHE ${b()}] Mint wallet loaded: ${t} (${Ve}ms)`),mintWallets.set(k,B),mintWalletPromises.delete(k),B.keys&&(console.log(`[MINT-CACHE ${b()}] Caching mint keys after loadMint: ${t}`,{count:B.keys.size}),_?.(t,B.keys)),te(B)}catch(ve){console.error(`[WALLET ${b()}] error loading mint`,t,ve.message),mintWalletPromises.delete(k),te(null)}});return mintWalletPromises.set(k,Y),Y}function createMintCacheCallbacks(t){return{onMintInfoNeeded:async n=>{if(t.getCacheData)return t.getCacheData("wallet:mint:info",n)},onMintInfoLoaded:async(n,r)=>{t.setCacheData&&await t.setCacheData("wallet:mint:info",n,r)},onMintKeysNeeded:async n=>{if(t.getCacheData)return t.getCacheData("wallet:mint:keys",n)},onMintKeysLoaded:async(n,r)=>{if(!t.setCacheData)return;const s=Array.from(r.values());await t.setCacheData("wallet:mint:keys",n,s)}}}async function getCashuWallet(t){if(this.cashuWallets.has(t))return this.cashuWallets.get(t);const n=await walletForMint(t,{onMintInfoNeeded:this.onMintInfoNeeded,onMintInfoLoaded:this.onMintInfoLoaded,onMintKeysNeeded:this.onMintKeysNeeded,onMintKeysLoaded:this.onMintKeysLoaded});if(!n)throw new Error(`unable to load wallet for mint ${t}`);return this.cashuWallets.set(t,n),n}var NDKWallet=class extends import_tseep2.EventEmitter{constructor(t){super(),__publicField(this,"cashuWallets",new Map),__publicField(this,"onMintInfoNeeded"),__publicField(this,"onMintInfoLoaded"),__publicField(this,"onMintKeysNeeded"),__publicField(this,"onMintKeysLoaded"),__publicField(this,"getCashuWallet",getCashuWallet.bind(this)),__publicField(this,"ndk"),__publicField(this,"status","initial"),__publicField(this,"walletId","unknown"),this.ndk=t}get type(){throw new Error("Not implemented")}get balance(){throw new Error("Not implemented")}redeemNutzaps(t,n,r){throw new Error("Not implemented")}};function getBolt11ExpiresAt(t){const n=(0,import_light_bolt11_decoder.decode)(t),r=n.expiry,s=n.sections.find(o=>o.name==="timestamp").value;if(typeof r=="number"&&typeof s=="number")return r+s}function getBolt11Amount(t){const s=(0,import_light_bolt11_decoder.decode)(t).sections.find(o=>o.name==="amount")?.value;return Number(s)}function getBolt11Description(t){return(0,import_light_bolt11_decoder.decode)(t).sections.find(o=>o.name==="description")?.value}var _a2,NDKCashuQuote=(_a2=class extends NDKEvent{constructor(t,n){super(t,n),__publicField(this,"quoteId"),__publicField(this,"mint"),__publicField(this,"amount"),__publicField(this,"unit"),__publicField(this,"_wallet"),this.kind??(this.kind=NDKKind.CashuQuote)}static async from(t){const n=new _a2(t.ndk,t),r=t;try{await n.decrypt()}catch{n.content=r.content}try{const s=JSON.parse(n.content);n.quoteId=s.quoteId,n.mint=s.mint,n.amount=s.amount,n.unit=s.unit}catch{return}return n}set wallet(t){this._wallet=t}set invoice(t){const n=getBolt11ExpiresAt(t);n&&this.tags.push(["expiration",n.toString()])}async save(){if(!this.ndk)throw new Error("NDK is required");this.content=JSON.stringify({quoteId:this.quoteId,mint:this.mint,amount:this.amount,unit:this.unit}),await this.encrypt(this.ndk.activeUser,void 0,"nip44"),await this.sign(),await this.publish(this._wallet?.relaySet)}},__publicField(_a2,"kind",NDKKind.CashuQuote),_a2);async function createOutTxEvent(t,n,r,s,{nutzaps:o}={}){let a=n.paymentDescription,f;n.pr?(f=getBolt11Amount(n.pr),a??(a=getBolt11Description(n.pr)),f&&(f/=1e3)):f=n.amount,f||console.error("BUG: Unable to find amount for paymentRequest",n);const g=new NDKCashuWalletTx(t);if(g.direction="out",g.amount=f??0,g.mint=r.mint,g.description=a,r.fee&&(g.fee=r.fee),n.target&&(g.tags.push(n.target.tagReference()),n.target instanceof NDKUser||g.tags.push(["p",n.target.pubkey])),o){g.description??(g.description="nutzap redeem");for(const _ of o)g.addRedeemedNutzap(_)}return r.stateUpdate?.created&&(g.createdTokens=[r.stateUpdate.created]),r.stateUpdate?.deleted&&(g.destroyedTokenIds=r.stateUpdate.deleted),r.stateUpdate?.reserved&&(g.reservedTokens=[r.stateUpdate.reserved]),await g.sign(),g.publish(s),g}async function createInTxEvent(t,n,r,s,{nutzaps:o,fee:a,description:f},g){const _=new NDKCashuWalletTx(t),P=proofsTotalBalance(n);if(_.direction="in",_.amount=P,_.mint=r,_.description=f,s.created&&(_.createdTokens=[s.created]),s.deleted&&(_.destroyedTokenIds=s.deleted),s.reserved&&(_.reservedTokens=[s.reserved]),o)for(const b of o)_.addRedeemedNutzap(b);return a&&(_.fee=a),await _.sign(),_.publish(g),_}var d4=(0,import_debug.default)("ndk-wallet:cashu:deposit");function randomMint(t){const n=t.mints;return n[Math.floor(Math.random()*n.length)]}var NDKCashuDeposit=class bn extends import_tseep2.EventEmitter{constructor(n,r,s){super(),__publicField(this,"mint"),__publicField(this,"amount"),__publicField(this,"quoteId"),__publicField(this,"wallet"),__publicField(this,"checkTimeout"),__publicField(this,"checkIntervalLength",2500),__publicField(this,"finalized",!1),__publicField(this,"quoteEvent"),this.wallet=n,this.mint=s||randomMint(n),this.amount=r}static fromQuoteEvent(n,r){if(!r.amount)throw new Error("quote has no amount");if(!r.mint)throw new Error("quote has no mint");const s=new bn(n,r.amount,r.mint);return s.quoteId=r.quoteId,s}async start(n=2500){const s=await(await this.wallet.getCashuWallet(this.mint)).createMintQuote(this.amount);return d4("created quote %s for %d %s",s.quote,this.amount,this.mint),this.quoteId=s.quote,this.wallet.depositMonitor.addDeposit(this),setTimeout(this.check.bind(this,n),n),this.createQuoteEvent(s.quote,s.request).then(o=>this.quoteEvent=o),s.request}async createQuoteEvent(n,r){const{ndk:s}=this.wallet,o=new NDKCashuQuote(s);o.quoteId=n,o.mint=this.mint,o.amount=this.amount,o.wallet=this.wallet,o.invoice=r;try{await o.save(),d4("saved quote on event %s",o.rawEvent())}catch(a){d4("error saving quote on event %s",a.relayErrors)}return o}async runCheck(){this.finalized||await this.finalize(),this.finalized||this.delayCheck()}delayCheck(){setTimeout(()=>{this.runCheck(),this.checkIntervalLength+=500},this.checkIntervalLength)}async check(n){this.runCheck(),n&&setTimeout(()=>{clearTimeout(this.checkTimeout)},n)}async finalize(){if(!this.quoteId)throw new Error("No quoteId set.");let n;try{d4("Checking for minting status of %s",this.quoteId);const r=await this.wallet.getCashuWallet(this.mint),s=await this.wallet.state.getProofs({mint:this.mint});if(n=await r.mintProofs(this.amount,this.quoteId,{proofsWeHave:s}),n.length===0)return}catch(r){if(r.message.match(/not paid/i))return;if(r.message.match(/already issued/i)){d4("Mint is saying the quote has already been issued, destroying quote event: %s",r.message),this.destroyQuoteEvent(),this.finalized=!0;return}if(r.message.match(/rate limit/i)){d4("Mint seems to be rate limiting, lowering check interval"),this.checkIntervalLength+=5e3;return}d4(r.message);return}try{this.finalized=!0;const r=await this.wallet.state.update({store:n,mint:this.mint},"Deposit"),s=r.created;if(!s)throw new Error("no token event created");createInTxEvent(this.wallet.ndk,n,this.mint,r,{description:"Deposit"},this.wallet.relaySet),this.emit("success",s),this.destroyQuoteEvent()}catch(r){this.emit("error",r.message),console.error(r)}}async destroyQuoteEvent(){if(!this.quoteEvent)return;(await this.quoteEvent.delete(void 0,!1)).publish(this.wallet.relaySet)}},NDKCashuDepositMonitor=class extends import_tseep2.EventEmitter{constructor(){super(...arguments),__publicField(this,"deposits",new Map)}addDeposit(t){const{quoteId:n}=t;if(!n)throw new Error("deposit has no quote ID");return this.deposits.has(n)?!1:(t.once("success",r=>{this.removeDeposit(n)}),this.deposits.set(n,t),this.emit("change"),!0)}removeDeposit(t){this.deposits.delete(t),this.emit("change")}};async function handleEventDeletion(t){const n=t.getMatchingTags("e").map(r=>r[1]);for(const r of n)this.state.removeTokenId(r)}async function handleQuote(t){const n=await NDKCashuQuote.from(t);if(!n)return;const r=Date.now()/1e3-3600;if(t.created_at&&t.created_at<r)return;const s=NDKCashuDeposit.fromQuoteEvent(this,n);this.depositMonitor.addDeposit(s)&&s.finalize()}async function handleToken(t){if(this.state.tokens.has(t.id))return;const n=await NDKCashuToken.from(t);if(n){for(const r of n.deletedTokens)this.state.removeTokenId(r);this.state.addToken(n)}}setInterval(()=>{},5e3);var handlers={[NDKKind.CashuToken]:handleToken,[NDKKind.CashuQuote]:handleQuote,[NDKKind.EventDeletion]:handleEventDeletion},balanceUpdateTimer=null;async function eventHandler(t){const n=handlers[t.kind];n&&(balanceUpdateTimer&&clearTimeout(balanceUpdateTimer),await n.call(this,t),balanceUpdateTimer=setTimeout(()=>{this.emit("balance_updated")},100))}async function eventDupHandler(t,n,r,s,o){}var d22=(0,import_debug.default)("ndk-wallet:cashu:validate");async function consolidateTokens(){d22("checking %d tokens for spent proofs",this.state.tokens.size);const t=new Set(this.state.getMintsProofs({validStates:new Set(["available","reserved","deleted"])}).keys());d22("found %d mints",t.size),t.forEach(n=>{consolidateMintTokens(n,this)})}async function consolidateMintTokens(t,n,r,s,o){r??(r=n.state.getProofs({mint:t,includeDeleted:!0,onlyAvailable:!1}));const a=await walletForMint(t);if(!a)return;let f=[];try{f=await a.checkProofsStates(r)}catch{return}const g=[],_=[],P=[];r.forEach((k,B)=>{const{state:Y}=f[B];Y===ns.SPENT?g.push(k):Y===ns.UNSPENT?_.push(k):P.push(k)});const b={mint:t,store:_,destroy:g};if(g.reduce((k,B)=>k+B.amount,0),b.destroy?.length===0)return;b.store?.push(...P);const q=P.reduce((k,B)=>k+B.amount,0);return n.state.reserveProofs(P,q),n.state.update(b,"Consolidate")}function calculateFee(t,n,r){const s=n.reduce((f,g)=>f+g.amount,0),o=r.reduce((f,g)=>f+g.amount,0),a=s-t-o;if(a<0)throw new Error("Invalid fee calculation: received more proofs than sent to mint");return a}async function withProofReserve(t,n,r,s,o,a){n??(n=await t.getCashuWallet(r));const f=t.state.getProofs({mint:r,onlyAvailable:!0}),g=n.selectProofsToSend(f,s);if(g.send.reduce((k,B)=>k+B.amount,0)<s)return null;t.state.reserveProofs(g.send,s);let P=null,b=null,q=null;try{if(P=await a(g.send,f),!P)return null;b={mint:r,store:P.change,destroy:g.send},q=await t.state.update(b)}catch(k){throw t.state.unreserveProofs(g.send,s,"available"),k}return P?{result:P.result,proofsChange:b,stateUpdate:q,mint:r,fee:calculateFee(o,g.send,P.change)}:null}async function payLn(t,n,{amount:r,unit:s}={}){let o=getBolt11Amount(n);if(!o)throw new Error("invoice amount is required");o=o/1e3,r&&s&&s==="msat"&&(r=r/1e3);const a=t.getMintsWithBalance(o+3);if(!a.length)return null;for(const f of a)try{const g=await executePayment(f,n,r??o,t);if(g)return r&&(g.fee=calculateFee(r,g.proofsChange?.destroy??[],g.proofsChange?.store??[])),g}catch(g){t.warn(`Failed to execute payment with min ${f}: ${g}`)}return null}async function executePayment(t,n,r,s){const o=await s.getCashuWallet(t);try{const a=await o.createMeltQuote(n),f=a.amount+a.fee_reserve;return await withProofReserve(s,o,t,f,r,async(_,P)=>{const b=await o.meltProofs(a,_);return b.quote.state===tt.PAID?{result:{preimage:b.quote.payment_preimage??""},change:b.change}:null})}catch(a){if(a instanceof Error)if(a.message.match(/already spent/i))setTimeout(()=>{consolidateMintTokens(t,s)},2500);else throw a;return null}}function ensureIsCashuPubkey(t){if(!t)return;let n=t;if(n.length===64&&(n=`02${n}`),n.length!==66)throw new Error("Invalid pubkey");return n}async function mintProofs(t,n,r,s,o){const a=(f,g,_)=>{const P=ensureIsCashuPubkey(o);t.mintProofs(r,n.quote,{pubkey:P}).then(b=>{console.debug("minted tokens",b),f({proofs:b,mint:s})}).catch(b=>{_++,_<=3?(console.error("error minting tokens",b),setTimeout(()=>a(f,g,_),_*1500)):g(b)})};return new Promise((f,g)=>{a(f,g,0)})}async function createToken(t,n,r,s){console.log("[createToken] Starting token creation",{amount:n,recipientMints:r,p2pk:s}),s=ensureIsCashuPubkey(s);const o=t.getMintsWithBalance(n);console.log("[createToken] My mints with enough balance",o);const a=r&&r.length>0,f=a?findMintsInCommon([r,o]):o;console.log("[createToken] Mints in common",{hasRecipientMints:a,mintsInCommon:f});for(const g of f){console.log("[createToken] Attempting to create token in mint",g);try{const _=await createTokenInMint(t,g,n,s);if(_)return console.log("[createToken] Successfully created token in mint",g),_;console.log("[createToken] Failed to create token in mint",g)}catch(_){console.error("[createToken] Error creating token in mint",g,_)}}return a?(console.log("[createToken] Attempting cross-mint transfer"),await createTokenWithMintTransfer(t,n,r,s)):(console.error("[createToken] All token creation attempts failed"),null)}async function createTokenInMint(t,n,r,s){console.log("[createTokenInMint] Starting",{mint:n,amount:r,p2pk:s});const o=await t.getCashuWallet(n);console.log("[createTokenInMint] Got cashu wallet for mint",n);try{const a=await withProofReserve(t,o,n,r,r,async(f,g)=>{console.log("[createTokenInMint] Inside withProofReserve callback",{proofsToUseCount:f.length,allOurProofsCount:g.length});const _=await o.send(r,f,{pubkey:s,proofsWeHave:g});return console.log("[createTokenInMint] Send result",{sendCount:_.send.length,keepCount:_.keep.length}),{result:{proofs:_.send,mint:n},change:_.keep,mint:n}});return console.log("[createTokenInMint] Success",a),a}catch(a){console.error("[createTokenInMint] Error",{mint:n,error:a.message,stack:a.stack})}return null}async function createTokenWithMintTransfer(t,n,r,s){const o=async()=>{const B=async Ve=>{const $e=await walletForMint(Ve);if(!$e)throw new Error(`unable to load wallet for mint ${Ve}`);return{quote:await $e.createMintQuote(n),mint:Ve,targetMintWallet:$e}},Y=r.map(B),{quote:te,mint:ve,targetMintWallet:je}=await Promise.any(Y);if(!te)throw new Error("failed to get quote from any mint");return{quote:te,mint:ve,targetMintWallet:je}},{quote:a,mint:f,targetMintWallet:g}=await o();if(!a)return null;const _=getBolt11Amount(a.request);if(!_)throw new Error("invoice amount is required");const P=_/1e3;if(P>n)throw new Error(`invoice amount is more than the amount passed in (${P} vs ${n})`);const b=await payLn(t,a.request,{amount:n});if(!b)return null;const{proofs:q,mint:k}=await mintProofs(g,a,n,f,s);return{...b,result:{proofs:q,mint:k},fee:b.fee}}function findMintsInCommon(t){const n=new Map;for(const s of t)for(const o of s){const a=normalizeUrl(o);n.has(a)?n.set(a,n.get(a)+1):n.set(a,1)}const r=[];for(const[s,o]of n.entries())o===t.length&&r.push(s);return r}var PaymentHandler=class{constructor(t){__publicField(this,"wallet"),this.wallet=t}async lnPay(t,n=!0){if(!t.pr)throw new Error("pr is required");const r=getBolt11Amount(t.pr);if(!r)throw new Error("invoice amount is required");if(t.amount&&r>t.amount)throw new Error("invoice amount is more than the amount passed in");const s=await payLn(this.wallet,t.pr,{amount:t.amount,unit:t.unit});if(s?.result?.preimage)return n&&createOutTxEvent(this.wallet.ndk,t,s,this.wallet.relaySet),s.result}async cashuPay(t){console.log("[PaymentHandler.cashuPay] Starting cashu payment",{originalAmount:t.amount,unit:t.unit,mints:t.mints,p2pk:t.p2pk,allowIntramintFallback:t.allowIntramintFallback});const n={...t};n.unit?.startsWith("msat")&&(n.amount=n.amount/1e3,n.unit="sat",console.log("[PaymentHandler.cashuPay] Converted msat to sat",{newAmount:n.amount,newUnit:n.unit})),console.log("[PaymentHandler.cashuPay] Creating token with mints",t.mints);let r=await createToken(this.wallet,n.amount,t.mints,t.p2pk);if(!r?.result&&(console.log("[PaymentHandler.cashuPay] Token creation failed with specified mints"),t.allowIntramintFallback&&(console.log("[PaymentHandler.cashuPay] Attempting intramint fallback"),r=await createToken(this.wallet,n.amount,void 0,t.p2pk)),!r?.result)){console.error("[PaymentHandler.cashuPay] Token creation failed completely");return}return console.log("[PaymentHandler.cashuPay] Token created successfully",{proofsCount:r.result.proofs.length,mint:r.result.mint}),createOutTxEvent(this.wallet.ndk,n,r,this.wallet.relaySet),r.result}};function getBalance(t){return this.getProofEntries(t).reduce((r,s)=>r+s.proof.amount,0)}function getMintsBalances({onlyAvailable:t}={onlyAvailable:!0}){var n;const r={},s=this.getProofEntries({onlyAvailable:t});for(const o of s)o.mint&&(r[n=o.mint]??(r[n]=0),r[o.mint]+=o.proof.amount);return r}function addProof(t){this.proofs.set(t.proof.C,t),this.journal.push({memo:"Added proof",timestamp:Date.now(),metadata:{type:"proof",id:t.proof.C,amount:t.proof.amount,mint:t.mint}})}function reserveProofs(t,n){for(const r of t)this.updateProof(r,{state:"reserved"});this.reserveAmounts.push(n)}function unreserveProofs(t,n,r){for(const o of t)this.updateProof(o,{state:r});const s=this.reserveAmounts.indexOf(n);if(s!==-1)this.reserveAmounts.splice(s,1);else throw new Error(`BUG: Amount ${n} not found in reserveAmounts`)}function getProofEntries(t={}){const n=new Map,r=new Set(["available"]);let{mint:s,onlyAvailable:o,includeDeleted:a}=t;o??(o=!0),o||r.add("reserved"),a&&r.add("deleted");for(const f of this.proofs.values())s&&f.mint!==s||r.has(f.state)&&f.proof&&n.set(f.proof.C,f);return Array.from(n.values())}function updateProof(t,n){const r=t.C,s=this.proofs.get(r);if(!s)throw new Error("Proof not found");const o={...s,...n};this.proofs.set(r,o),this.journal.push({memo:`Updated proof state: ${JSON.stringify(n)}`,timestamp:Date.now(),metadata:{type:"proof",id:r,amount:t.amount,mint:s.mint}})}function addToken(t){if(!t.mint)throw new Error("BUG: Token has no mint");const r=this.tokens.get(t.id)?.state??"available";this.tokens.set(t.id,{token:t,state:r});for(const s of t.proofs)maybeAssociateProofWithToken(this,s,t,r)}function maybeAssociateProofWithToken(t,n,r,s){const o=n.C,a=t.proofs.get(o);if(!a)return t.addProof({mint:r.mint,state:s,tokenId:r.id,timestamp:r.created_at,proof:n}),!0;if(a.tokenId){if(a.tokenId===r.id)return null;const f=t.tokens.get(a.tokenId);if(!f)throw new Error(`BUG: Token id ${a.tokenId} not found, was expected to be associated with proof ${o}`);const g=f.token;return g&&g.created_at&&(!r.created_at||r.created_at<g.created_at)?!1:(t.updateProof(n,{tokenId:r.id,state:s}),!0)}return t.updateProof(n,{tokenId:r.id,state:s}),!0}function removeTokenId(t){const n=this.tokens.get(t)||{};this.tokens.set(t,{...n,state:"deleted"});for(const r of this.proofs.values()){const{proof:s}=r;if(r.tokenId===t){if(!s)throw new Error("BUG: Proof entry has no proof");this.updateProof(s,{state:"deleted"})}}}async function update(t,n){return updateInternalState(this,t),this.wallet.emit("balance_updated"),updateExternalState(this,t)}function updateInternalState(t,n){if(n.store&&n.store.length>0)for(const r of n.store)t.addProof({mint:n.mint,state:"available",proof:r,timestamp:Date.now()});if(n.destroy&&n.destroy.length>0)for(const r of n.destroy)t.updateProof(r,{state:"deleted"});if(n.reserve&&n.reserve.length>0)throw new Error("BUG: Proofs should not be reserved via update")}async function updateExternalState(t,n){const r=calculateNewState(t,n);if(r.deletedTokenIds.size>0){const o=new NDKEvent(t.wallet.ndk,{kind:NDKKind.EventDeletion,tags:[["k",NDKKind.CashuToken.toString()],...Array.from(r.deletedTokenIds).map(a=>["e",a])]});await o.sign(),publishWithRetry(t,o,t.wallet.relaySet);for(const a of r.deletedTokenIds)t.removeTokenId(a)}const s={};if(r.saveProofs.length>0){const o=await createTokenEvent(t,n.mint,r);s.created=o}return s}async function publishWithRetry(t,n,r,s=10*1e3){let o;o=await n.publish(r);let a;n.kind===NDKKind.EventDeletion&&(a="deletion"),n.kind===NDKKind.CashuToken&&(a="token"),n.kind===NDKKind.CashuWallet&&(a="wallet");const f={type:a,id:n.id,relayUrl:r?.relayUrls.join(",")};if(o)return t.journal.push({memo:`Publish kind:${n.kind} succeesfully`,timestamp:Date.now(),metadata:f}),o;t.journal.push({memo:"Publish failed",timestamp:Date.now(),metadata:f}),setTimeout(()=>{publishWithRetry(t,n,r,s)},s)}async function createTokenEvent(t,n,r){const s=new NDKCashuToken(t.wallet.ndk);return s.mint=n,s.proofs=r.saveProofs,await s.toNostrEvent(),t.addToken(s),s.deletedTokens=Array.from(r.deletedTokenIds),await s.sign(),t.addToken(s),publishWithRetry(t,s,t.wallet.relaySet),s}function calculateNewState(t,n){const r=new Set;for(const a of n.destroy||[])r.add(a.C);const s=new Map;let o;for(const a of n.store||[])s.set(a.C,a);o=getAffectedTokens(t,n);for(const a of o.values())for(const f of a.proofs)r.has(f.C)||s.set(f.C,f);return{deletedTokenIds:new Set(o.keys()),deletedProofs:r,reserveProofs:[],saveProofs:Array.from(s.values())}}function getAffectedTokens(t,n){const r=new Map;for(const s of n.destroy||[]){const o=t.proofs.get(s.C);if(!o)continue;const a=o.tokenId;if(!a)continue;const f=t.tokens.get(a);f?.token&&r.set(a,f.token)}return r}var WalletState=class{constructor(t,n=new Set){__publicField(this,"reserveAmounts",[]),__publicField(this,"proofs",new Map),__publicField(this,"tokens",new Map),__publicField(this,"journal",[]),__publicField(this,"addToken",addToken.bind(this)),__publicField(this,"removeTokenId",removeTokenId.bind(this)),__publicField(this,"addProof",addProof.bind(this)),__publicField(this,"reserveProofs",reserveProofs.bind(this)),__publicField(this,"unreserveProofs",unreserveProofs.bind(this)),__publicField(this,"getProofEntries",getProofEntries.bind(this)),__publicField(this,"updateProof",updateProof.bind(this)),__publicField(this,"getBalance",getBalance.bind(this)),__publicField(this,"getMintsBalance",getMintsBalances.bind(this)),__publicField(this,"update",update.bind(this)),this.wallet=t,this.reservedProofCs=n}dump(){return{proofs:Array.from(this.proofs.values()),balances:this.getMintsBalance(),totalBalance:this.getBalance(),tokens:Array.from(this.tokens.values())}}getProofs(t){return this.getProofEntries(t).map(n=>n.proof)}getTokens(t={onlyAvailable:!0}){const n=this.getProofEntries(t),r=new Map;for(const s of n){const o=s.tokenId??null,a=r.get(o)??{tokenId:o,mint:s.mint,proofEntries:[]};a.token??(a.token=o?this.tokens.get(o)?.token:void 0),a.proofEntries.push(s),r.set(o,a)}return r}getMintsProofs({validStates:t=new Set(["available"])}={}){const n=new Map;for(const r of this.proofs.values()){if(!r.mint||!r.proof||!t.has(r.state))continue;const s=n.get(r.mint)||[];s.push(r.proof),n.set(r.mint,s)}return n}},_a3,NDKCashuWallet=(_a3=class extends NDKWallet{constructor(t){if(super(t),__publicField(this,"_p2pk"),__publicField(this,"sub"),__publicField(this,"status","initial"),__publicField(this,"mints",[]),__publicField(this,"privkeys",new Map),__publicField(this,"signer"),__publicField(this,"walletId","nip-60"),__publicField(this,"depositMonitor",new NDKCashuDepositMonitor),__publicField(this,"warnings",[]),__publicField(this,"paymentHandler"),__publicField(this,"state"),__publicField(this,"relaySet"),__publicField(this,"_walletRelays",[]),__publicField(this,"consolidateTokens",consolidateTokens.bind(this)),__publicField(this,"wallets",new Map),this.ndk=t,this.paymentHandler=new PaymentHandler(this),this.state=new WalletState(this),t.cacheAdapter?.getCacheData&&t.cacheAdapter?.setCacheData){const n=createMintCacheCallbacks(t.cacheAdapter);this.onMintInfoNeeded=n.onMintInfoNeeded,this.onMintInfoLoaded=n.onMintInfoLoaded,this.onMintKeysNeeded=n.onMintKeysNeeded,this.onMintKeysLoaded=n.onMintKeysLoaded}}get type(){return"nip-60"}async backup(t=!0){if(this.privkeys.size===0)throw new Error("no privkey to backup");const n=new NDKCashuWalletBackup(this.ndk),r=[];for(const[s,o]of this.privkeys.entries())r.push(o.privateKey);return n.privkeys=r,n.mints=this.mints,t&&n.save(this.relaySet),n}async mintNuts(t){let n;const r=t.reduce((s,o)=>s+o,0);for(const s of this.mints){const o=await this.getCashuWallet(s),a=await this.state.getProofs({mint:s});if(n=await o.send(r,a,{proofsWeHave:a,includeFees:!0,outputAmounts:{sendAmounts:t}}),n.send.length>0){const f={store:n?.keep??[],destroy:n.send,mint:s},g=await this.state.update(f);return createOutTxEvent(this.ndk,{paymentDescription:"minted nuts",amount:t.reduce((_,P)=>_+P,0)},{result:{proofs:n.send},stateUpdate:g,mint:s,fee:0},this.relaySet),this.emit("balance_updated"),n}}}async send(t,n){if(this.mints.length===0)throw new Error("No mints configured");const r=await this.mintNuts([t]);if(!r)throw new Error("Failed to create token");return Ye({mint:this.mints[0],proofs:r.send,memo:n})}async loadFromEvent(t){const n=new NDKEvent(t.ndk,t.rawEvent());await n.decrypt();const r=JSON.parse(n.content);for(const s of r)s[0]==="mint"?this.mints.push(s[1]):s[0]==="privkey"?await this.addPrivkey(s[1]):s[0]==="relay"&&this._walletRelays.push(s[1]);await this.getP2pk()}static async from(t){if(!t.ndk)throw new Error("no ndk instance on event");const n=new _a3(t.ndk);return await n.loadFromEvent(t),n}static async create(t,n,r){const s=new _a3(t),o=NDKPrivateKeySigner.generate();return await s.addPrivkey(o.privateKey),s.mints=n,r&&r.length>0&&(s.relaySet=NDKRelaySet.fromRelayUrls(r,t)),await s.publish(),await s.backup(!0),s}async fetchWalletRelays(t){if(this._walletRelays.length>0)return NDKRelaySet.fromRelayUrls(this._walletRelays,this.ndk);const n=await this.ndk.fetchEvent({kinds:[NDKKind.RelayList],authors:[t]},{cacheUsage:NDKSubscriptionCacheUsage.PARALLEL});if(n)return NDKRelayList.from(n).relaySet}async start(t){const n=this.ndk?.activeUser;if(this.status==="ready")return Promise.resolve();this.setStatus("loading");const r=t?.pubkey??n?.pubkey;if(!r)throw new Error("no pubkey");this.relaySet||(this.relaySet=await this.fetchWalletRelays(r));const s=[{kinds:[NDKKind.CashuToken],authors:[r]},{kinds:[NDKKind.CashuQuote],authors:[r]},{kinds:[NDKKind.EventDeletion],authors:[r],"#k":[NDKKind.CashuToken.toString()]}];if(t?.since&&(s[0].since=t.since,s[1].since=t.since,s[2].since=t.since),this.ndk.cacheAdapter){const o=[],a=await this.ndk.fetchEvents([{kinds:[NDKKind.CashuToken],authors:[r]}],{cacheUsage:NDKSubscriptionCacheUsage.ONLY_CACHE});o.push(...a);for(const f of o)eventHandler.call(this,f);this.emit("balance_updated")}if(this.ndk.cacheAdapter)try{const o=await NDKSync.sync(this.ndk,s,{relaySet:this.relaySet,autoFetch:!0});for(const g of o.events)eventHandler.call(this,g);const a=t??{};a.subId??(a.subId="cashu-wallet-state");const f=s.map(g=>({...g,since:Math.floor(Date.now()/1e3)-60}));this.sub=this.ndk.subscribe(f,{...a,relaySet:this.relaySet,closeOnEose:!1,onEvent:g=>{eventHandler.call(this,g)},onEventDup:eventDupHandler.bind(this)}),this.emit("ready"),this.setStatus("ready")}catch(o){console.error("[NDKCashuWallet] Sync failed, falling back to subscription:",o),await this.startWithSubscription(s,t)}else await this.startWithSubscription(s,t)}async startWithSubscription(t,n){const r=n??{};return r.subId??(r.subId="cashu-wallet-state"),new Promise(s=>{this.sub=this.ndk.subscribe(t,{...r,relaySet:this.relaySet,onEvent:o=>{eventHandler.call(this,o)},onEose:async()=>{this.emit("ready"),this.setStatus("ready"),s()},onEventDup:eventDupHandler.bind(this)})})}stop(){this.sub?.stop(),this.setStatus("initial")}setStatus(t){this.status!==t&&(this.status=t,this.emit("status_changed",t))}async getP2pk(){if(this._p2pk)return this._p2pk;if(this.privkeys.size===0){const t=NDKPrivateKeySigner.generate();await this.addPrivkey(t.privateKey)}return this.p2pk}get p2pks(){return Array.from(this.privkeys.keys())}async addPrivkey(t){const n=new NDKPrivateKeySigner(t),r=await n.user();return this.privkeys.set(r.pubkey,n),this._p2pk??(this._p2pk=r.pubkey),this._p2pk}get p2pk(){if(!this._p2pk)throw new Error("p2pk not set");return this._p2pk}set p2pk(t){if(this.privkeys.has(t))this.signer=this.privkeys.get(t),this.p2pk=t;else throw new Error(`privkey for ${t} not found`)}walletPayload(){const t=Array.from(this.privkeys.values()).map(r=>r.privateKey),n=payloadForEvent(t,this.mints);return this._walletRelays.length>0&&n.push(...this._walletRelays.map(r=>["relay",r])),n}async publish(){this.relaySet&&(this._walletRelays=Array.from(this.relaySet.relays).map(r=>r.url));const t=new NDKEvent(this.ndk,{content:JSON.stringify(this.walletPayload()),kind:NDKKind.CashuWallet}),n=await this.ndk?.signer?.user();return await t.encrypt(n,void 0,"nip44"),t.publish(this.relaySet)}async publishMintList(){const t=new NDKCashuMintList(this.ndk);return t.mints=this.mints,this.relaySet&&(t.relays=Array.from(this.relaySet.relays).map(n=>n.url)),t.p2pk=this.p2pk,t.publishReplaceable(this.relaySet)}async update(t){this.mints=t.mints,t.relays&&t.relays.length>0?(this.relaySet=NDKRelaySet.fromRelayUrls(t.relays,this.ndk),this._walletRelays=t.relays):(this.relaySet=void 0,this._walletRelays=[]);const n=new NDKEvent(this.ndk,{content:JSON.stringify(this.walletPayload()),kind:NDKKind.CashuWallet}),r=await this.ndk?.signer?.user();return await n.encrypt(r,void 0,"nip44"),n.publishReplaceable(this.relaySet)}deposit(t,n){const r=new NDKCashuDeposit(this,t,n);return r.on("success",s=>{this.state.addToken(s)}),r}async receiveToken(t,n){const{mint:r}=Pe(t),o=await(await this.getCashuWallet(r)).receive(t),a=await this.state.update({store:o,mint:r}),f=a.created;return createInTxEvent(this.ndk,o,r,a,{description:n},this.relaySet),f}async lnPay(t,n=!0){return this.paymentHandler.lnPay(t,n)}async cashuPay(t){return this.paymentHandler.cashuPay(t)}async redeemNutzaps(t,n,{mint:r,proofs:s,cashuWallet:o}){if(o)r??(r=o.mint.mintUrl);else{if(!r)throw new Error("mint not set");o=await this.getCashuWallet(r)}if(!r)throw new Error("mint not set");if(!s)throw new Error("proofs not set");try{const a=this.state.getProofs({mint:r}),f=await o.receive({proofs:s,mint:r},{proofsWeHave:a,privkey:n}),g=s.reduce((q,k)=>q+k.amount,0),_=f.reduce((q,k)=>q+k.amount,0),P=g-_,b=await this.state.update({store:f,mint:r});return createInTxEvent(this.ndk,f,r,b,{nutzaps:t,fee:P},this.relaySet),g}catch(a){throw console.error("error redeeming nutzaps",t.map(f=>f.encode()),a),a}}warn(t,n,r){r??(r=n?.onRelays),this.warnings.push({msg:t,event:n,relays:r}),this.emit("warning",{msg:t,event:n,relays:r})}get balance(){return{amount:this.state.getBalance({onlyAvailable:!0})}}mintBalance(t){return this.mintBalances[t]||0}get mintBalances(){return this.state.getMintsBalance({onlyAvailable:!0})}getMintsWithBalance(t){const n=this.state.getMintsBalance({onlyAvailable:!0});return Object.entries(n).filter(([r,s])=>s>=t).map(([r])=>r)}async getMintInfo(t){return await(await this.getCashuWallet(t)).mint.getInfo()}},__publicField(_a3,"kind",NDKKind.CashuWallet),__publicField(_a3,"kinds",[NDKKind.CashuWallet]),_a3),NDKCashuWalletBackup=class vn extends NDKEvent{constructor(n,r){super(n,r),__publicField(this,"privkeys",[]),__publicField(this,"mints",[]),this.kind??(this.kind=NDKKind.CashuWalletBackup)}static async from(n){if(!n.ndk)throw new Error("no ndk instance on event");const r=new vn(n.ndk,n);try{await r.decrypt();const s=JSON.parse(r.content);for(const o of s)o[0]==="mint"?r.mints.push(o[1]):o[0]==="privkey"&&r.privkeys.push(o[1])}catch(s){console.error("error decrypting backup event",r.encode(),s);return}return r}async save(n){if(!this.ndk)throw new Error("no ndk instance");if(!this.privkeys.length)throw new Error("no privkeys");return this.content=JSON.stringify(payloadForEvent(this.privkeys,this.mints)),await this.encrypt(this.ndk.activeUser,void 0,"nip44"),this.publish(n)}};function payloadForEvent(t,n){if(t.length===0)throw new Error("privkey not set");return[...n.map(s=>["mint",s]),...t.map(s=>["privkey",s])]}async function fetchPage(t,n,r,s){const o=await t.fetchEvents(n,{cacheUsage:NDKSubscriptionCacheUsage.ONLY_RELAY,groupable:!1,subId:"recent-nutzap"},s);return Array.from(o).map(a=>NDKNutzap.from(a)).filter(a=>!!a)}function groupNutzaps(t,n){const r=new Map,s=(o,a="no-key")=>`${o}:${a}`;for(const o of t){if(!n.shouldTryRedeem(o))continue;const a=o.mint;for(const f of o.proofs){const g=proofP2pk(f)??"no-key",_=s(a,g),P=r.get(_)??{mint:a,cashuPubkey:g,nostrPubkey:cashuPubkeyToNostrPubkey(g),nutzaps:[]};P.nutzaps.push(o),r.set(_,P)}}return Array.from(r.values())}async function getProofSpendState(t,n){const r={unspentProofs:[],spentProofs:[],nutzapsWithUnspentProofs:[],nutzapsWithSpentProofs:[]},s=new Set,o=[],a=new Map;for(const g of n)for(const _ of g.proofs)s.has(_.C)||(s.add(_.C),o.push(_),a.set(_.C,g));const f=await t.checkProofsStates(o);for(let g=0;g<f.length;g++){const _=f[g],P=o[g],b=a.get(P.C);b&&(_.state===ns.SPENT?(r.spentProofs.push(P),r.nutzapsWithSpentProofs.some(q=>q.id===b.id)||r.nutzapsWithSpentProofs.push(b)):_.state===ns.UNSPENT&&(r.unspentProofs.push(P),r.nutzapsWithUnspentProofs.some(q=>q.id===b.id)||r.nutzapsWithUnspentProofs.push(b)))}return r}function log(t){}(class extends import_tseep2.EventEmitter{constructor(t,n,{mintList:r,store:s}){super(),__publicField(this,"store"),__publicField(this,"ndk"),__publicField(this,"user"),__publicField(this,"relaySet"),__publicField(this,"sub"),__publicField(this,"nutzapStates",new Map),__publicField(this,"_wallet"),__publicField(this,"mintList"),__publicField(this,"privkeys",new Map),__publicField(this,"cashuWallets",new Map),__publicField(this,"getCashuWallet",getCashuWallet.bind(this)),__publicField(this,"onMintInfoNeeded"),__publicField(this,"onMintInfoLoaded"),__publicField(this,"onMintKeysNeeded"),__publicField(this,"onMintKeysLoaded"),this.ndk=t,this.user=n,this.mintList=r,this.relaySet=r?.relaySet,this.store=s}set wallet(t){if(this._wallet=t,t&&(this.onMintInfoNeeded??(this.onMintInfoNeeded=t.onMintInfoNeeded),this.onMintInfoLoaded??(this.onMintInfoLoaded=t.onMintInfoLoaded),this.onMintKeysNeeded??(this.onMintKeysNeeded=t.onMintKeysNeeded),this.onMintKeysLoaded??(this.onMintKeysLoaded=t.onMintKeysLoaded),t instanceof NDKCashuWallet&&t?.privkeys))for(const[n,r]of t.privkeys.entries())try{this.addPrivkey(r)}catch(s){console.error("failed to add privkey from wallet with pubkey",n,s)}}get wallet(){return this._wallet}async addPrivkey(t){const n=(await t.user()).pubkey;if(this.privkeys.has(n)||(this.privkeys.set(n,t),!this.sub))return;const r=a=>a.status===NdkNutzapStatus.MISSING_PRIVKEY,s=a=>a.nutzap?.p2pk===n,o=Array.from(this.nutzapStates.values()).filter(r).filter(s);if(o.length>0){const a=o.map(g=>g.nutzap).filter(g=>!!g),f=groupNutzaps(a,this);for(const g of f)await this.checkAndRedeemGroup(g)}}async addUserPrivKey(){const{signer:t}=this.ndk;if(t instanceof NDKPrivateKeySigner){const r=(await t.user()).pubkey;this.privkeys.set(r,t)}}async getBackupKeys(){const t=await this.ndk.fetchEvents([{kinds:[NDKKind.CashuWalletBackup,NDKKind.CashuWallet],authors:[this.user.pubkey]}],void 0,this.relaySet),n=Array.from(this.privkeys.values()),r=new Set(n.map(s=>s.privateKey));for(const s of t)if(s.kind===NDKKind.CashuWalletBackup){const o=await NDKCashuWalletBackup.from(s);if(!o)continue;for(const a of o.privkeys){r.has(a)&&r.delete(a);try{const f=new NDKPrivateKeySigner(a);this.addPrivkey(f)}catch(f){console.error("failed to add privkey",a,f)}}}else if(s.kind===NDKKind.CashuWallet)try{await s.decrypt();const o=JSON.parse(s.content);for(const a of o)if(a[0]==="privkey"){const f=a[1];r.has(f)&&r.delete(f);try{const g=new NDKPrivateKeySigner(f);this.addPrivkey(g)}catch(g){console.error("failed to add privkey from wallet config",f,g)}}}catch(o){console.error("failed to decrypt wallet config event",s.encode(),o)}if(r.size>0){const s=new NDKCashuWalletBackup(this.ndk);s.privkeys=Array.from(r),await s.save(this.relaySet)}}async fetchMintList(){const t=await this.ndk.fetchEvent({kinds:[NDKKind.CashuMintList],authors:[this.user.pubkey]},{cacheUsage:NDKSubscriptionCacheUsage.PARALLEL,subId:"cashu-mint-list"});if(t)return this.mintList=NDKCashuMintList.from(t),this.mintList}async start({filter:t,opts:n}){if(this.sub&&this.sub.stop(),!this.mintList)try{const a=await this.fetchMintList();`${a?.mints.length??0}`}catch(a){console.error(" Failed to fetch mint list",a)}try{await this.getBackupKeys(),`${this.privkeys.size}`}catch(a){console.error(" Failed to get backup keys",a)}await this.addUserPrivKey(),`${this.privkeys.size}`;const r=Math.floor(Date.now()/1e3),s={kinds:[NDKKind.Nutzap],"#p":[this.user.pubkey],since:r};if(this.store)try{const a=await this.store.getAllNutzaps();`${a.size}`;for(const[f,g]of a.entries())this.nutzapStates.set(f,g);`${a.size}`}catch(a){console.error(" Failed to load nutzaps from store",a)}try{await this.processRedeemableNutzapsFromStore()}catch(a){console.error(" Failed to process redeemable nutzaps from store",a)}try{await this.processAccumulatedNutzaps(t,n),`${this.nutzapStates.size}`}catch(a){console.error(" Failed to process nutzaps",a)}`${JSON.stringify(s)}`;const o={subId:"ndk-wallet:nutzap-monitor",cacheUsage:NDKSubscriptionCacheUsage.ONLY_RELAY,wrap:!1,skipValidation:!0,...n,relaySet:this.relaySet};return this.sub=this.ndk.subscribe(s,o,{onEvent:a=>this.eventHandler(a)}),!0}async checkAndRedeemGroup(t,n){const r=await this.getCashuWallet(t.mint),s=await getProofSpendState(r,t.nutzaps);for(const o of s.nutzapsWithSpentProofs)this.updateNutzapState(o.id,{status:NdkNutzapStatus.SPENT,nutzap:o});for(const o of s.nutzapsWithUnspentProofs)this.emit("seen",o),this.updateNutzapState(o.id,{status:NdkNutzapStatus.INITIAL,nutzap:o});if(s.unspentProofs.length>0){for(const o of s.nutzapsWithUnspentProofs)(!n||n>o.created_at)&&(n=o.created_at);await this.redeemNutzaps(t.mint,s.nutzapsWithUnspentProofs,s.unspentProofs)}}async processAccumulatedNutzaps(t={},n){let r;const s={...t};s.kinds=[NDKKind.Nutzap],s["#p"]=[this.user.pubkey];const o=new Set(this.nutzapStates.keys()),a=await fetchPage(this.ndk,s,o,this.relaySet);`${a.length}`,r=await this.processNutzaps(a,r),r&&(s.since=r-1,await this.processAccumulatedNutzaps(s,n))}stop(){this.sub?.stop()}updateNutzapState(t,n){const r=this.nutzapStates.get(t)??{};if(r.status||(n.status??(n.status=NdkNutzapStatus.INITIAL)),Object.entries(n).every(([g,_])=>g==="nutzap"&&r.nutzap&&_?r.nutzap.id===_.id:r[g]===_))return;this.nutzapStates.set(t,{...r,...n}),this.emit("state_changed",t,r.status);const o=g=>{const _={...g};return _.nutzap&&(_.nutzap=_.nutzap.id),JSON.stringify(_)},a=o(r),f=o(n);`${t.substring(0,6)}${a}${f}`,this.store?.setNutzapState(t,n)}async eventHandler(t){if(this.nutzapStates.has(t.id))return;const n=await NDKNutzap.from(t);if(!n){this.updateNutzapState(t.id,{status:NdkNutzapStatus.PERMANENT_ERROR,errorMessage:"Failed to parse nutzap"});return}this.mintList&&!this.mintList.mints.includes(n.mint)&&this.emit("seen_in_unknown_mint",n),this.redeemNutzap(n)}async redeemNutzap(t){if(this.nutzapStates.has(t.id)||this.updateNutzapState(t.id,{status:NdkNutzapStatus.INITIAL,nutzap:t}),t.rawP2pk){const r=proofP2pk(t.proofs[0]);if(r){const s=cashuPubkeyToNostrPubkey(r);if(s&&!this.privkeys.has(s))return this.updateNutzapState(t.id,{status:NdkNutzapStatus.MISSING_PRIVKEY,errorMessage:"No privkey found for p2pk"}),this.nutzapStates.get(t.id)}}return await this.redeemNutzaps(t.mint,[t],t.proofs),this.nutzapStates.get(t.id)}async redeemNutzaps(t,n,r){if(!this.wallet)throw new Error("wallet not set");if(!this.wallet.redeemNutzaps)throw new Error("wallet does not support redeeming nutzaps");const s=await this.getCashuWallet(t),o=[];if(r.length>0){const _=proofP2pk(r[0]);if(!_){for(const q of n)this.updateNutzapState(q.id,{status:NdkNutzapStatus.INVALID_NUTZAP,errorMessage:"Invalid nutzap: proof is not p2pk"});return}const P=cashuPubkeyToNostrPubkey(_);if(!P){for(const q of n)this.updateNutzapState(q.id,{status:NdkNutzapStatus.INVALID_NUTZAP,errorMessage:"Invalid nutzap: locked to an invalid public key (not a nostr key)"});return}if(!this.privkeys.get(P)){for(const q of n)this.updateNutzapState(q.id,{status:NdkNutzapStatus.MISSING_PRIVKEY,errorMessage:"No privkey found for p2pk"});return}}for(const _ of n){if(!_.isValid){this.updateNutzapState(_.id,{status:NdkNutzapStatus.INVALID_NUTZAP,errorMessage:"Invalid nutzap"});continue}const P=_.rawP2pk;if(!P){this.updateNutzapState(_.id,{status:NdkNutzapStatus.INVALID_NUTZAP,errorMessage:"Invalid nutzap: locked to an invalid public key (no p2pk)"});continue}if(P.length!==66){this.updateNutzapState(_.id,{status:NdkNutzapStatus.INVALID_NUTZAP,errorMessage:`Invalid nutzap: locked to an invalid public key (length ${P.length})`});continue}o.push(_)}if(o.length===0)return;const a=proofP2pk(r[0]);if(!a)return;const f=cashuPubkeyToNostrPubkey(a);if(!f)return;const g=this.privkeys.get(f);if(!g){for(const _ of o)this.updateNutzapState(_.id,{status:NdkNutzapStatus.MISSING_PRIVKEY,errorMessage:"No privkey found for p2pk"});return}for(const _ of o)this.updateNutzapState(_.id,{status:NdkNutzapStatus.PROCESSING});try{const _=await this.wallet.redeemNutzaps(n,g.privateKey,{cashuWallet:s,proofs:r,mint:t});this.emit("redeemed",n,_);for(const P of n){const b=proofsTotal(proofsIntersection(r,P.proofs));this.updateNutzapState(P.id,{status:NdkNutzapStatus.REDEEMED,redeemedAmount:b})}}catch(_){if(console.error(" Failed to redeem nutzaps",_.message),_.message?.includes("unknown public key size"))for(const P of n)this.updateNutzapState(P.id,{status:NdkNutzapStatus.PERMANENT_ERROR,errorMessage:"Invalid p2pk: unknown public key size"}),this.emit("failed",P,"Invalid p2pk: unknown public key size");else for(const P of n)this.emit("failed",P,_.message)}}shouldTryRedeem(t){const n=this.nutzapStates.get(t.id);if(!n||[NdkNutzapStatus.INITIAL].includes(n.status))return!0;if(n.status===NdkNutzapStatus.MISSING_PRIVKEY){const r=n.nutzap?.p2pk;return!!(r&&this.privkeys.has(r))}return[NdkNutzapStatus.SPENT,NdkNutzapStatus.REDEEMED].includes(n.status)||[NdkNutzapStatus.PERMANENT_ERROR,NdkNutzapStatus.INVALID_NUTZAP].includes(n.status),!1}async processRedeemableNutzapsFromStore(){const t=[];for(const[n,r]of this.nutzapStates.entries())r.nutzap&&this.shouldTryRedeem(r.nutzap)&&t.push(r.nutzap);t.length!==0&&(`${t.length}`,await this.processNutzaps(t))}async processNutzaps(t,n){const r=groupNutzaps(t,this);for(const s of r){`${s.mint}${s.nutzaps.length}`;try{await this.checkAndRedeemGroup(s,n),`${s.mint}`}catch(o){`${s.mint}`,console.error(` Failed to process group ${s.mint}`,o)}}return n}});function proofsIntersection(t,n){const r=new Set(n.map(s=>s.C));return t.filter(s=>r.has(s.C))}function proofsTotal(t){return t.reduce((n,r)=>n+r.amount,0)}(0,import_debug.default)("ndk-wallet:nwc");export{NDKCashuDeposit,NDKCashuWallet,NDKCashuWalletBackup,NDKWallet,WalletState,calculateNewState,consolidateMintTokens,consolidateTokens,createMintCacheCallbacks,getBolt11Amount,getBolt11Description,getBolt11ExpiresAt,update};
